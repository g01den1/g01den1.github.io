



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta name="referrer" content="no-referrer"/>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="golden的部落阁" href="http://blog.g01den.top/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="golden的部落阁" href="http://blog.g01den.top/atom.xml" />
<link rel="alternate" type="application/json" title="golden的部落阁" href="http://blog.g01den.top/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="Pwn" />


<link rel="canonical" href="http://blog.g01den.top/posts/cbafa55d.html">



  <title>
pwn学习笔记（6）--堆基础概述 - Pwn手的自我修养 |
golden的部落阁 = golden的部落阁 = subtitle写得真好</title>
<meta name="generator" content="Hexo 7.2.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">pwn学习笔记（6）--堆基础概述
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2024-03-23 19:10:34">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2024-03-23T19:10:34+08:00">2024-03-23</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">golden的部落阁</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://gitee.com/gou-dengyue/images/raw/master/picture241.jpg">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Pwn/" itemprop="item" rel="index" title="分类于 Pwn手的自我修养"><span itemprop="name">Pwn手的自我修养</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="http://blog.g01den.top/posts/cbafa55d.html">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="g01den">
    <meta itemprop="description" content="subtitle写得真好, golden的部落阁">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="golden的部落阁">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="glibc堆概述"><a class="markdownIt-Anchor" href="#glibc堆概述">#</a> glibc 堆概述：</h1>
<h2 id="1内存管理与堆"><a class="markdownIt-Anchor" href="#1内存管理与堆">#</a> 1. 内存管理与堆：</h2>
<h3 id="概述"><a class="markdownIt-Anchor" href="#概述">#</a> 概述：</h3>
<p>​	内存管理是堆计算机的内存资源进行管理，这要求在程序请求时能够动态分配内存的一部分，并在程序不需要时释放分配的内存。CTF 竞赛中常见的 ptmalloc2 就是 glibc 实现的内存管理机制，它继承了 dlmalloc，并提供了对多线程的支持。</p>
<p>​	堆是程序虚拟内存中由低地址向高地址增长的线性区域。一般只有当用户向操作系统申请内存时，这片区域才会被内核分配出来，并且处于效率和页对齐的考虑，通常会分配相当大的连续内存。程序再次申请时便会从这片内存中分配，直到堆空间不能满足时才会再次增长。堆的位置一般在 BSS 段高地址处。</p>
<h3 id="brk和sbrk"><a class="markdownIt-Anchor" href="#brk和sbrk">#</a> brk () 和 sbrk ()：</h3>
<p>​	堆的属性是可读可写的，大小通过 brk () 和 sbrk () 函数进行控制。在堆未初始化时，program_break 指向 BSS 段的末尾，通过调用 brk () 和 sbrk () 来移动 program_break 使得堆增长。在堆初始化时，如果开启了 ASLR，则堆的起始地址 start_brk 会在 BSS 段之后的随机位移出，如果没有开启，则 start_brk 会紧接着 BSS 段。</p>
<p>​	两个函数相关内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">brk</span><span class="params">(<span class="type">void</span>* end_data_segment)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://img-blog.csdnimg.cn/direct/44bf6e33773c4e7c83318714e950a7e5.png#pic_center" alt="在这里插入图片描述"></p>
<p>​	brk () 函数的参数是一个指针，用于设置 program_break 指向的位置。sbrk () 函数的参数 increment (可以是负值) 用于与 program_break 相加来调整 program_break 的值。成功执行后 brk () 函数会返回 0 ，sbrk () 函数会返回上一次 program_break 值（可以设置参数 increment 为 0 来获得当前 program_break 的值）。</p>
<h3 id="mmap和unmmap"><a class="markdownIt-Anchor" href="#mmap和unmmap">#</a> mmap () 和 unmmap ()：</h3>
<p>​	当用户申请内存过大时，ptmalloc2 会选择通过 mmap () 函数创建匿名映射段供用户使用，并通过 unmmap () 函数回收。</p>
<h3 id="glibc中的堆"><a class="markdownIt-Anchor" href="#glibc中的堆">#</a> glibc 中的堆：</h3>
<p>​	通常来说，系统中的堆指的是主线程中 main_arena 所管理的区域。但 glibc 会同时维持多个区域来供多线程使用，每个线程都有属于自己的内存（成为 arena），这些连续的内存也可以成为堆。</p>
<p>​	glibc 的想法是：当用户申请堆块时，从堆中按顺序分配堆块交给用户，用户保存指向这些堆块的指针；当用户释放堆块时，glibc 会将释放的堆块组织成链表；当两块相堆块都为释放状态时将之合并成一个新的堆块；由此解决内存碎片的问题。用户正在使用中的堆块叫作 allocated chunk，被释放的堆块叫做 free chunk，由 free chunk 组成的链表叫 bin。** 我们称呼当前 chunk 低地址处相邻的 chunk 为上一个（后面的）chunk，高地址相邻处的 chunk 为下一个（前面的）chunk。** 为了方便管理，glibc 将不同大小范围的 chunk 组织成不同的 bin 。如 fast bin 、small bin 、large bin 等，在这些链表中的 chunk 分别叫作 fast chunk 、small chunk 和 large chunk 。</p>
<h2 id="2重要概念和结构体"><a class="markdownIt-Anchor" href="#2重要概念和结构体">#</a> 2. 重要概念和结构体：</h2>
<h3 id="arena"><a class="markdownIt-Anchor" href="#arena">#</a> arena：</h3>
<p>​	arena 包含一片或数片连续的内存，堆块将会从这片区域划分给用户。主线程的 arena 被称为 main_arena，它包含 start_brk 和 brk 之间的这片连续内存。</p>
<p>​	主线程的 arena 只有堆，子线程的 arena 可以有数片连续内存。如果主线程的堆大小不够分的话可以通过 brk () 调用来扩展，但是子线程分配的映射段大小是固定的，不可以扩展，所以子线程分配出来的一段映射段不够用的话就需要再次使用 mmap () 来分配新的内存。</p>
<h3 id="heap_info结构体"><a class="markdownIt-Anchor" href="#heap_info结构体">#</a> heap_info 结构体：</h3>
<p>​	如之前所说，子线程的 arena 可以有多片连续内存，这些内存被称为 heap。每一个 heap 都有自己的 heap header 。其定义如下，heap header 是通过链表相连接的，并且 heap header 里面保存了指向其他所属的 arena 的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr;				 	<span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> 			<span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="type">size_t</span> size;   					<span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; 			<span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           			   PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>
<h3 id="malloc_state结构体"><a class="markdownIt-Anchor" href="#malloc_state结构体">#</a> malloc_state 结构体：</h3>
<p>​	每个线程只有一个 arena header，里面保存了 bin、top chunk 等信息。主线程的 main_arena <span class="exturl" data-url="aHR0cDovL3huLS1saWJjLXA2NmZpMDBibmxoLnNv">保存在 libc.so</span> 的数据段里，其他线程的 arena 则保存在给该 arena 分配的 heap 里面。malloc_state 定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="malloc_chunk结构体"><a class="markdownIt-Anchor" href="#malloc_chunk结构体">#</a> malloc_chunk 结构体：</h3>
<p>​	chunk 是 glibc 管理内存的基本单位，整个堆在初始化后会被当成一个 free  chunk，称之为 top chunk ，每次用户请求内存时，如果 bins 中没有合适的 chunk ，malloc 就会从 top chunk 中进行划分，如果 top chunk 的大小不够，则调用 brk () 扩展堆的大小，然后从新生成的 top chunk 中进行切分。用户释放内存时，glibc 会先根据情况将释放的 chunk 与其他相邻的 free chunk 合并，然后加入合适的 bin 中。</p>
<p>​	下图展示了堆块申请和释放的过程。首先，用户连续申请了三个堆块 A、B、C，此时释放 chunk B ，由于它与 top chunk 不相邻，所以会被放入 bin 中，成为一个 free chunk。现在再次申请一个与 B 相同大小的堆块，则 malloc 将从 bin 中取出 chunk B ，回到一开始的状态，bin 的表头也会指向 null。。但如果用户连续释放 chunk A 和 chunk B ，由于他们相邻且都是 free chunk ，那么就会被合并成一个大的 chunk 放入 bin 中。</p>
<p><img data-src="https://img-blog.csdnimg.cn/direct/01387fb92db746dc8ec05b89342e1ee2.png#pic_center" alt="在这里插入图片描述"></p>
<p>​	对以上知识有了简单的印象之后，就可以看看 chunk 的信息是怎么被 glibc 记录的，下面是 malloc chunk 的结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​	在默认情况下，INTERNAL_SIZE_T 的大小在 64 位系统下是 8 字节，32 位系统下是 4 字节。以下是关于 malloc_chunk 的各个成员的功能：</p>
<blockquote>
<ul>
<li>
<p><strong>prev_size</strong>, 如果该 chunk 的 ** 物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）** 是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。<strong>这里的前一 chunk 指的是较低地址的 chunk</strong> 。</p>
</li>
<li>
<p>size</p>
<p>，该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示</p>
<ul>
<li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li>
<li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li>
</ul>
</li>
<li>
<p>fd，bk</p>
<p>。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</p>
<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
</li>
<li>
<p>fd_nextsize， bk_nextsize</p>
<p>，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。</p>
<ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li>
</ul>
</li>
</ul>
</blockquote>
<p>​	一个已经分配的 chunk 的样子如下。<strong>我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处，也就是 mem 处的地址。</strong></p>
<p>​	当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用。<strong>这就是 chunk 中的空间复用。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, <span class="keyword">if</span> <span class="title function_">unallocated</span> <span class="params">(P clear)</span>  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             <span class="params">(malloc_usable_size() bytes)</span>                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             <span class="params">(size of chunk, but used <span class="keyword">for</span> application data)</span>    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>​	被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, <span class="keyword">if</span> <span class="title function_">unallocated</span> <span class="params">(P clear)</span>  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:&#x27; |             Size of chunk, in bytes                     |A|0|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Forward pointer to next chunk in <span class="built_in">list</span>             |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Back pointer to previous chunk in <span class="built_in">list</span>            |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Unused <span class="title function_">space</span> <span class="params">(may be <span class="number">0</span> bytes <span class="type">long</span>)</span>                .</span><br><span class="line">        .                                                               .</span><br><span class="line"> next   .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`foot:&#x27; |             Size of chunk, in bytes                           |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|0|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h2 id="3各类bin介绍"><a class="markdownIt-Anchor" href="#3各类bin介绍">#</a> 3. 各类 bin 介绍：</h2>
<p>​	chunk 被释放时，glibc 会将它们重新组织起来，构成不同的 bin 链表，当用户再次申请时，就从中寻找合适的 chunk 返回用户。不同大小区间 chunk 被划分到不同的 bin 中，再加上一种特殊的 bin，一共有四种：Fast bin 、Samll bin 、 Large bin 、和 Unsorted bin 。这些 bin 记录在 malloc_state 结构中。</p>
<ul>
<li>fastbinsY ：这是一个 bin 数组，里面有 NFASTBINS 个 fast bin。</li>
<li>bins：也是一个 bin 数组，一共有 126 个 bin ，按顺序分别是：
<ul>
<li>bin 1 为 unsorted bin</li>
<li>bin 2 到 bin 63 为 small bin</li>
<li>bin 64 到 bin 126 为 large bin</li>
</ul>
</li>
</ul>
<h3 id="fast-bin"><a class="markdownIt-Anchor" href="#fast-bin">#</a> fast bin ：</h3>
<p>​	在实践中，程序申请和释放的堆块往往都比较小，所以 glibc 对这类 bin 使用单链表结构，并采用 LIFO（后进先出）的分配策略。为了加快速度，fast bin 里的 chunk 不会进行合并操作，所以下一个 chunk 的 PRV_INUSE 始终标记为 1，使其处于使用状态。同一个 fast bin 里 chunk 大小相同，并且在 fastbinY 数组里按照从小到大的顺序排列，序号为 0 的 fast bin 中容纳的 chunk 大小为 4<em>SIZE_SZ 字节，随着序号增加，所容纳的 chunk 递增 2</em>SIZE_SZ 字节。</p>
<p><img data-src="https://img-blog.csdnimg.cn/direct/08dc51489bb7469c8a03c0f73de586bb.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="unsorted-bin"><a class="markdownIt-Anchor" href="#unsorted-bin">#</a> unsorted bin：</h3>
<p>​	一定大小的 chunk 被释放时，在进入 small bin 或者 large bin 之前，会先加入 unsorted bin 。在实践中，一个释放的 chunk 常常很快就会被重新使用，所以将其先加入 unsorted bin 可以加快分配的速度。 unsorted bin 使用双链表结构，并采用 FIFO（先进先出）的分配策略。与 fastbinY 不同，unsorted bin 中的 chunk 大小可能是不同的，并且由于是双向链表结构，一个 bin 会占用 bins 的两个元素。</p>
<h3 id="small-bin"><a class="markdownIt-Anchor" href="#small-bin">#</a> small bin：</h3>
<p>​	同一个 small bin 里 chunk 的大小相同，采用双链表结构，使用频率介于 fast bin 和 large bin 之间。small bin 在 bins 里居第 2 到 63 位，共 62 个。根据排序，每个 small bin 的大小为 2<em>SIZE_SZ</em>inx（idx 表示 bins 数组的下标）。在 64 位系统下，最小的 small chunk 为 2*8*2=32 字节，最大的 small chunk 为 2*8*63=1008 字节。由于 small bin 和 fast bin 有重合的部分，所以这些 chunk 在某些情况下会被加入 small bin 中。</p>
<h3 id="large-bin"><a class="markdownIt-Anchor" href="#large-bin">#</a> large bin：</h3>
<p>​	large bin 在 bins 里居 64 到 126 位，共 63 个，被分成了 6 组，每组 bin 所能容纳的 chunk 按顺序排成等差数列，公差分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">32 bins of size			64</span><br><span class="line">16 bins of size		   512</span><br><span class="line"> 8 bins of size		  4096</span><br><span class="line"> 4 bins of size		 32768</span><br><span class="line"> 2 bins of size		262144</span><br><span class="line"> 1 bin  of size		what&#x27;sleft</span><br></pre></td></tr></table></figure>
<p>​	32 位系统下第一个 large bin 的 chunk 最小为 512 字节，第二个 large bin 的额 chunk 最小为 512+64 字节（处于 [512，512+64] 之间的 chunk 都属于第一个 large bin），以此类推。64 位系统也是一样的，第一个 large bin 的 chunk 最小为 1024 字节，第二个 large bin 的 chunk 最小为 1024+64 字节（处于 [1024，1024+64] 之间的 chunk 都属于第一个 large bin）以此类推。</p>
<p>​	large bin 也是采用双链表结构，里面的 chunk 从头节点的 fd 指针开始，按大小顺序进行排列。为了加快检索速度，fd_nextsize 和 bk_nextsize 指针用于指向第一个与自己大小不同的 chunk 时，所以也只有在加入了大小不同的 chunk 时，这两个指针才会被修改。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料">#</a> 参考资料：</h2>
<p>​	《CTF 竞赛权威指南 pwn 篇》</p>

      <div class="tags">
          <a href="/tags/Pwn/" rel="tag"><i class="ic i-tag"></i> Pwn</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2024-06-20 21:29:18" itemprop="dateModified" datetime="2024-06-20T21:29:18+08:00">2024-06-20</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="g01den 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="g01den 支付宝">
        <p>支付宝</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="g01den 贝宝">
        <p>贝宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>g01den <i class="ic i-at"><em>@</em></i>golden的部落阁
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="http://blog.g01den.top/posts/cbafa55d.html" title="pwn学习笔记（6）--堆基础概述">http://blog.g01den.top/posts/cbafa55d.html</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/posts/a698ff8.html" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;gou-dengyue&#x2F;images&#x2F;raw&#x2F;master&#x2F;picture281.jpg" title="pwn学习笔记（5）--格式化字符串漏洞（未完全完成）">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> Pwn手的自我修养</span>
  <h3>pwn学习笔记（5）--格式化字符串漏洞（未完全完成）</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/posts/efb4c08.html" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;gou-dengyue&#x2F;images&#x2F;raw&#x2F;master&#x2F;picture236.jpg" title="pwn学习笔记（7）--堆相关源码">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> Pwn手的自我修养</span>
  <h3>pwn学习笔记（7）--堆相关源码</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#glibc%E5%A0%86%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text"> glibc 堆概述：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%A0%86"><span class="toc-number">1.1.</span> <span class="toc-text"> 1. 内存管理与堆：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 概述：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#brk%E5%92%8Csbrk"><span class="toc-number">1.1.2.</span> <span class="toc-text"> brk () 和 sbrk ()：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap%E5%92%8Cunmmap"><span class="toc-number">1.1.3.</span> <span class="toc-text"> mmap () 和 unmmap ()：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#glibc%E4%B8%AD%E7%9A%84%E5%A0%86"><span class="toc-number">1.1.4.</span> <span class="toc-text"> glibc 中的堆：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.</span> <span class="toc-text"> 2. 重要概念和结构体：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arena"><span class="toc-number">1.2.1.</span> <span class="toc-text"> arena：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#heap_info%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.2.</span> <span class="toc-text"> heap_info 结构体：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc_state%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.3.</span> <span class="toc-text"> malloc_state 结构体：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc_chunk%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.4.</span> <span class="toc-text"> malloc_chunk 结构体：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E5%90%84%E7%B1%BBbin%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.</span> <span class="toc-text"> 3. 各类 bin 介绍：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fast-bin"><span class="toc-number">1.3.1.</span> <span class="toc-text"> fast bin ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsorted-bin"><span class="toc-number">1.3.2.</span> <span class="toc-text"> unsorted bin：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#small-bin"><span class="toc-number">1.3.3.</span> <span class="toc-text"> small bin：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#large-bin"><span class="toc-number">1.3.4.</span> <span class="toc-text"> large bin：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.4.</span> <span class="toc-text"> 参考资料：</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/posts/c06afb6e.html" rel="bookmark" title="Pwn学习笔记（1）--前置知识">Pwn学习笔记（1）--前置知识</a></li><li><a href="/posts/c3c1bd42.html" rel="bookmark" title="Pwn学习笔记（2）--ret_2_text_or_shellcode">Pwn学习笔记（2）--ret_2_text_or_shellcode</a></li><li><a href="/posts/e20e7502.html" rel="bookmark" title="pwn学习笔记（3）ret2syscall">pwn学习笔记（3）ret2syscall</a></li><li><a href="/posts/52965aaa.html" rel="bookmark" title="pwn学习笔记（4）ret2libc">pwn学习笔记（4）ret2libc</a></li><li><a href="/posts/a698ff8.html" rel="bookmark" title="pwn学习笔记（5）--格式化字符串漏洞（未完全完成）">pwn学习笔记（5）--格式化字符串漏洞（未完全完成）</a></li><li class="active"><a href="/posts/cbafa55d.html" rel="bookmark" title="pwn学习笔记（6）--堆基础概述">pwn学习笔记（6）--堆基础概述</a></li><li><a href="/posts/efb4c08.html" rel="bookmark" title="pwn学习笔记（7）--堆相关源码">pwn学习笔记（7）--堆相关源码</a></li><li><a href="/posts/d7e2e20f.html" rel="bookmark" title="pwn学习笔记（0）-事后补充">pwn学习笔记（0）-事后补充</a></li><li><a href="/posts/9b0d93f7.html" rel="bookmark" title="Pwn刷题记录（不停更新）">Pwn刷题记录（不停更新）</a></li><li><a href="/posts/2c0210e1.html" rel="bookmark" title="how2heap_zh">how2heap_zh</a></li><li><a href="/posts/9d5b1ce4.html" rel="bookmark" title="pwn学习笔记（8）-初识沙箱">pwn学习笔记（8）-初识沙箱</a></li><li><a href="/posts/c8624158.html" rel="bookmark" title="pwn学习笔记（9）-中级ROP--ret2csu">pwn学习笔记（9）-中级ROP--ret2csu</a></li><li><a href="/posts/540e5c20.html" rel="bookmark" title="Pwn学习笔记（10）--UAF">Pwn学习笔记（10）--UAF</a></li><li><a href="/posts/f1497b96.html" rel="bookmark" title="pwn学习笔记（11）--off_by_one">pwn学习笔记（11）--off_by_one</a></li><li><a href="/posts/d1a08bca.html" rel="bookmark" title="pwn学习笔记（12）--Chunk Extend and Overlapping">pwn学习笔记（12）--Chunk Extend and Overlapping</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="g01den"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">g01den</p>
  <div class="description" itemprop="description">golden的部落阁</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">49</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">10</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">8</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2cwMWRlbjE=" title="https:&#x2F;&#x2F;github.com&#x2F;g01den1"><i class="ic i-github"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/posts/a698ff8.html" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/posts/efb4c08.html" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Web/" title="分类于 Web狗的自我安慰">Web狗的自我安慰</a>
</div>

    <span><a href="/posts/b3ad4123.html" title="有小考点的Web题">有小考点的Web题</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Game/" title="分类于 CTFer的比赛之路">CTFer的比赛之路</a>
</div>

    <span><a href="/posts/de34fe7b.html" title="【2024】HECTF-个人整理向">【2024】HECTF-个人整理向</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Web/" title="分类于 Web狗的自我安慰">Web狗的自我安慰</a>
</div>

    <span><a href="/posts/88915f6f.html" title="无参数RCE的一些奇技淫巧">无参数RCE的一些奇技淫巧</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Pwn/" title="分类于 Pwn手的自我修养">Pwn手的自我修养</a>
</div>

    <span><a href="/posts/c06afb6e.html" title="Pwn学习笔记（1）--前置知识">Pwn学习笔记（1）--前置知识</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Web/" title="分类于 Web狗的自我安慰">Web狗的自我安慰</a>
</div>

    <span><a href="/posts/ff5b88d5.html" title="python原型链污染">python原型链污染</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Pwn/" title="分类于 Pwn手的自我修养">Pwn手的自我修养</a>
</div>

    <span><a href="/posts/d7e2e20f.html" title="pwn学习笔记（0）-事后补充">pwn学习笔记（0）-事后补充</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Pwn/" title="分类于 Pwn手的自我修养">Pwn手的自我修养</a>
</div>

    <span><a href="/posts/efb4c08.html" title="pwn学习笔记（7）--堆相关源码">pwn学习笔记（7）--堆相关源码</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Web/" title="分类于 Web狗的自我安慰">Web狗的自我安慰</a>
</div>

    <span><a href="/posts/53e2b2e1.html" title="ctfshow-命令执行">ctfshow-命令执行</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Game/" title="分类于 CTFer的比赛之路">CTFer的比赛之路</a>
</div>

    <span><a href="/posts/955175a5.html" title="【2024】H&amp;NCTF">【2024】H&NCTF</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Daily/" title="分类于 发电日常">发电日常</a>
</div>

    <span><a href="/posts/cf99ed43.html" title="从NSSCTF开始的复建之路">从NSSCTF开始的复建之路</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">g01den @ golden的部落阁</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
     <p><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">蜀ICP备2024083302号</a><!--|<a target="_blank" rel="noopener" href="https://beian.mps.gov.cn/#/query/webSearch">公网安备XXXXXXXX号</a> -->
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'posts/cbafa55d.html',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body>
</html>
