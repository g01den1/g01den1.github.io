



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta name="referrer" content="no-referrer"/>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="golden的部落阁" href="http://blog.g01den.top/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="golden的部落阁" href="http://blog.g01den.top/atom.xml" />
<link rel="alternate" type="application/json" title="golden的部落阁" href="http://blog.g01den.top/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="408" />


<link rel="canonical" href="http://blog.g01den.top/posts/2c763aa6.html">



  <title>
数据结构-3、栈、队列和数组 - 数据结构 - 考研专业课 |
golden的部落阁 = golden的部落阁 = subtitle写得真好</title>
<meta name="generator" content="Hexo 7.2.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">数据结构-3、栈、队列和数组
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2024-06-15 21:00:51">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2024-06-15T21:00:51+08:00">2024-06-15</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">golden的部落阁</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://gitee.com/gou-dengyue/images/raw/master/picture302.jpg">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Major/" itemprop="item" rel="index" title="分类于 考研专业课"><span itemprop="name">考研专业课</span></a>
<meta itemprop="position" content="1" /></span>
<i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Major/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="item" rel="index" title="分类于 数据结构"><span itemprop="name">数据结构</span></a>
<meta itemprop="position" content="2" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="http://blog.g01den.top/posts/2c763aa6.html">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="g01den">
    <meta itemprop="description" content="subtitle写得真好, golden的部落阁">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="golden的部落阁">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="31-栈"><a class="markdownIt-Anchor" href="#31-栈">#</a> 3.1、栈</h1>
<h2 id="311-栈的基本概念"><a class="markdownIt-Anchor" href="#311-栈的基本概念">#</a> 3.1.1、栈的基本概念：</h2>
<h3 id="1-栈的定义"><a class="markdownIt-Anchor" href="#1-栈的定义">#</a> 1、栈的定义：</h3>
<p>​	栈是只允许在一端进行插入或删除操作的线性表。首先，栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作，如下图：</p>
<p><img data-src="https://img-blog.csdnimg.cn/direct/277222dabf06428490300ed5d9714ed4.png#pic_center" alt="在这里插入图片描述"></p>
<p>​	栈顶（Top）。线性表允许进行插入删除的那一端。</p>
<p>​	栈底（Bottom）。固定的，不允许进行插入和删除的另一端。</p>
<p>​	空栈。不包含任何元素的空表。</p>
<p>​	假设某个栈 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>5</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S=(a_1,a_2,a_3,a_4,a_5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，如上图所示，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为栈底元素，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">a_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为栈顶元素。由于栈只能在栈顶进行插入和删除操作，进栈次序依次为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,a_3,a_4,a_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，而出栈次序则与入栈次序相反。由此可见，栈的操作特性可以明显地概括为后进先出（LIFO）。</p>
<p>​	栈的数学性质：n 个不同元素进栈，出栈元素不同排列的个数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><msubsup><mi>C</mi><mn>2</mn><mi>n</mi></msubsup><mi>n</mi></mrow><annotation encoding="application/x-tex">\frac{1}{n+1}C^n_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span> 。上述公式称为卡特兰数，可采用数学归纳法证明。</p>
<h3 id="2-栈的基本操作"><a class="markdownIt-Anchor" href="#2-栈的基本操作">#</a> 2、栈的基本操作：</h3>
<p>​	栈的基本操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InitStack(&amp;S)		<span class="comment">//初始化一个空栈。</span></span><br><span class="line">StackEmpty(S)		<span class="comment">//判断一个栈是否为空，若栈 S 为空则返回 ture ，否则返回 false。</span></span><br><span class="line">Push(&amp;S,x)			<span class="comment">//进栈，若栈 S 未满，则将 x 加入使之成为新栈顶。</span></span><br><span class="line">Pop(&amp;S,&amp;x)			<span class="comment">//出栈，若栈 S 非空，则弹出栈顶元素，并用 x 返回。</span></span><br><span class="line">GetTop(S,&amp;x)		<span class="comment">//读取栈顶元素，若栈 S 非空，则用 x 返回栈顶元素。</span></span><br><span class="line">DestroyStack(&amp;S)	<span class="comment">//销毁栈，并释放栈 S 占用的存储空间（“&amp; 表示引用调用”）。</span></span><br></pre></td></tr></table></figure>
<h2 id="312-栈的顺序存储结构"><a class="markdownIt-Anchor" href="#312-栈的顺序存储结构">#</a> 3.1.2、栈的顺序存储结构：</h2>
<p>​	栈是一种操作受限的线性表，类似于线性表，它也有对应的两种存储方式。</p>
<h3 id="1-顺序栈的实现"><a class="markdownIt-Anchor" href="#1-顺序栈的实现">#</a> 1、顺序栈的实现：</h3>
<p>​	采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈顶到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。</p>
<p>​	栈的顺序存储类型可描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure>
<p>​	栈顶指针：s.top，初始时设置 S.top=-1；栈顶元素：S.data [S.top]。</p>
<p>​	进栈操作：栈不满时，栈顶指针先加 1 ，再送值到栈顶元素。</p>
<p>​	出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减 1.</p>
<p>​	栈空条件：S.top==-1；栈满条件：S.top==MaxSize-1；栈长：S.top+1.</p>
<p>​	由于顺序栈的入栈操作受数组上界的约束，当对栈的最大使用空间估计不足时，有可能发生栈上溢，此时应及时向用户报告信息，以便及时处理，避免出错。</p>
<h3 id="2-顺序栈的基本运算"><a class="markdownIt-Anchor" href="#2-顺序栈的基本运算">#</a> 2、顺序栈的基本运算：</h3>
<p>​	栈操作的示意图如下图所示：（a）是空栈，（c）是 A、B、C、D、E 共 5 个元素依次入栈后的结果，（d）是在（c）之后 E、D、C 相继出栈，此时栈中还有 2 个元素，或许最近出栈的元素 C、D、E 仍在原先的单元存储着，但 top 指针已经指向了新的栈顶，元素 C、D、E 已不在栈中。</p>
<p><img data-src="https://img-blog.csdnimg.cn/direct/b96bea57eb3f411b9349911d140b2277.png#pic_center" alt="在这里插入图片描述"></p>
<p>​	下面是顺序栈上常用的基本运算实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack *S)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack *S)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Push</span><span class="params">(SqStack *S,<span class="type">int</span> x)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Pop</span><span class="params">(SqStack *S,<span class="type">int</span> *x)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(SqStack *S,<span class="type">int</span> *x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">6</span>;i++)&#123;</span><br><span class="line">        Push(&amp;S,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(GetTop(&amp;S,&amp;x))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack *S)</span>&#123;</span><br><span class="line">    S-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack *S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Push</span><span class="params">(SqStack *S,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top == MaxSize <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    S-&gt;data[++S-&gt;top] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Pop</span><span class="params">(SqStack *S,<span class="type">int</span> *x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *x = S-&gt;data[S-&gt;top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(SqStack *S,<span class="type">int</span> *x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *x = S-&gt;data[S-&gt;top];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-共享栈"><a class="markdownIt-Anchor" href="#3-共享栈">#</a> 3、共享栈：</h3>
<p>​	利用栈底位置相对不变的特性，可让两个顺序栈共享一个以为数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间眼神，如下图：</p>
<p><img data-src="https://img-blog.csdnimg.cn/direct/404d770f650a49e5bec8c623ef629c40.png#pic_center" alt="在这里插入图片描述"></p>
<p>​	两个栈的栈顶指针都指向栈顶元素，top0=-1 时 0 号栈为空，top1=MaxSize 时 1 号栈为空；仅当两个栈顶指针相邻 （top0-top1=1）时，判断为栈满。当 0 号栈进栈时 top0 先加 1 再赋值，1 号栈进栈时 top1 先减 1 再赋值；出栈时则刚好相反。</p>
<p>​	共享栈时为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满时才发生上溢。其存取数据的时间复杂度为 O (1) ，所以对存取效率没有什么影响。</p>
<h2 id="313-栈的链式存储结构"><a class="markdownIt-Anchor" href="#313-栈的链式存储结构">#</a> 3.1.3、栈的链式存储结构：</h2>
<p>​	采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头结点，Lhead 指向栈顶元素，如下图：</p>
<p><img data-src="https://img-blog.csdnimg.cn/direct/574afc86cafd4c37b2f51933fbd90877.png#pic_center" alt="在这里插入图片描述"></p>
<p>​	栈的链式存储类型可描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *LiStack;</span><br></pre></td></tr></table></figure>
<p>​	采用链式存储，便于结点的插入与删除。链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行。需要注意的是，对于带头结点和不带头结点的链栈，具体的实现会有所不同。</p>
<h1 id="32-队列"><a class="markdownIt-Anchor" href="#32-队列">#</a> 3.2、队列；</h1>
<h2 id="321-队列的基本概念"><a class="markdownIt-Anchor" href="#321-队列的基本概念">#</a> 3.2.1、队列的基本概念：</h2>
<h3 id="1-队列的定义"><a class="markdownIt-Anchor" href="#1-队列的定义">#</a> 1、队列的定义：</h3>
<p>​	队列，也是一种操作受限的线性表，只允许在表的一端进行插入，而表的另一端进行删除。向队列中插入元素成为入队或进队；删除元素称为出队或离队。这和我们日常生活中的排队时一致的，最早排队的也是最早离队的，其操作的特性是先进先出（FIFO），如下图：</p>
<p><img data-src="https://img-blog.csdnimg.cn/direct/0af06018a2fb45e7829ac849c4bc386d.png#pic_center" alt="在这里插入图片描述"></p>
<p>​	对头。允许删除的一端，又称队首。</p>
<p>​	队尾。允许插入的一端。</p>
<p>​	空队列。不含任何元素的空表。</p>
<h3 id="2-队列常见的基本操作"><a class="markdownIt-Anchor" href="#2-队列常见的基本操作">#</a> 2、队列常见的基本操作：</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InitQueue(*Q)		<span class="comment">//初始化队列，构造一个空队列 Q。</span></span><br><span class="line">QueueEmpty(*Q)		<span class="comment">//判队列空，若队列 Q 为空返回 true ，否则返回 false。</span></span><br><span class="line">EnQueue(*Q,x)		<span class="comment">//入队，若队列 Q 未满，将 x 加入，使之成为新的队尾。</span></span><br><span class="line">DeQueue(*Q,*x)		<span class="comment">//出队，若队列 Q 非空，删除队头元素，并用 x 返回。</span></span><br><span class="line">GetHead(*Q,*x)		<span class="comment">//读队头元素，若队列 Q 非空，则将对头元素赋值给 x。</span></span><br></pre></td></tr></table></figure>
<h2 id="322-队列的顺序存储结构"><a class="markdownIt-Anchor" href="#322-队列的顺序存储结构">#</a> 3.2.2、队列的顺序存储结构：</h2>
<h3 id="1-队列的顺序存储"><a class="markdownIt-Anchor" href="#1-队列的顺序存储">#</a> 1、队列的顺序存储：</h3>
<p>​	队列的顺序实现是指分配一块连续的存储单位存放队列的元素，并附设两个指针：队头指针 front 指向队头元素，队尾指针 rear 指向队尾元素的下一个位置。</p>
<p>​	队列的顺序存储类型可描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front,rear;</span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>
<p>​	初始时：Q.front = Q.rear = 0。</p>
<p>​	进队操作：队不满时，先送值到队尾元素，再将队尾指针加 1。</p>
<p>​	出队操作：队不空时，先取队头元素值，再将队头指针加 1.</p>
<p>​	如下图（a）所示为列表的初始状态，有  <code>Q.front==Qrear==0</code>  成立，该条件可以作为队列判断空的条件。但能否用 Q.rear==MaxSize 作为队列满的条件呢？显然不能，如图（d），队列中仅有一个元素，但扔满足该条件。这时入队出现 “上溢出”，但这种溢出不是真正的溢出，在 data 数组中依然存在可以存放元素的空位置，所以时一种 “假溢出”。</p>
<p><img data-src="https://img-blog.csdnimg.cn/direct/c906a4afeb404f1aa7fa40e6c3fbcfda.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-循环队列"><a class="markdownIt-Anchor" href="#2-循环队列">#</a> 2、循环队列：</h3>
<p>​		将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针   <code>Q.front=maxSize-1</code>  后，再前进一个位置就自动到 0，这可以利用取余运算（%）来实现。</p>
<p>​		初始时：Q.front=Q.rear=0。</p>
<p>​		队首指针进 1：Q.front=(Q.rear+1)% MaxSize。</p>
<p>​		队尾指针进 1：Q.rear=(Q.rear+1)% MaxSize。</p>
<p>​		队列长度：(Q.rear+MaxSize-Q.front)% MaxSize。</p>
<p>​		出入队列时：指针都按照顺时针方向进 1，如下图：</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/7f4b487d32bd4cb4a828631df8cffc86.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		队空的条件是 Q.front<mark>Q.rear。若入队元素的速度快于出队元素的速度，则队尾指针很快会赶上队首指针，此时可以看出队满时也有 Q.front</mark>Q.rear。</p>
<p>​		为了区分时空队还是队满的情况，有三种处理方式：</p>
<ol>
<li>
<p>牺牲一个单元来区分队空和队满，入队时少用一个队列单元，约定以 “队头指针在队尾指针的下一个位置作为满队的标志”。</p>
<p>队满条件：(Q.rear+1)% MaxSize==Q.front。</p>
<p>队空条件：Q.front==Q.rear。</p>
<p>队列中元素个数：(Q.rear-Q.front+MaxSize)% MaxSize。</p>
</li>
<li>
<p>类型中增设表示元素个数的数据员。这样，队空的条件为 Q.size<mark>0；队满的条件为 Q.size</mark>MaxSize。这两种情况都有 Q.front==Q.rear。</p>
</li>
<li>
<p>类型中增设 tag 数据员，以区分是队满还是队空。tag 等于 0 时，若因删除导致 Q.front<mark>Q.rear，则为空队；tag 等于 1 时，若因插入导致 Q.front</mark>Q.rear，则为队满。</p>
</li>
</ol>
<h3 id="3-循环队列的操作"><a class="markdownIt-Anchor" href="#3-循环队列的操作">#</a> 3、循环队列的操作：</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front,rear;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q,<span class="type">int</span> x)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q,<span class="type">int</span> *x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span>&#123;</span><br><span class="line">    Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(SqQueue *Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;rear == Q-&gt;front) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>)%MaxSize==Q-&gt;front) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = x;</span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q,<span class="type">int</span> *x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;rear == Q-&gt;front) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *x = Q-&gt;data[Q-&gt;front];</span><br><span class="line">    Q-&gt;front = (Q-&gt;front + <span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="323-队列的链式存储结构"><a class="markdownIt-Anchor" href="#323-队列的链式存储结构">#</a> 3.2.3、队列的链式存储结构:</h2>
<h3 id="1-队列的链式存储"><a class="markdownIt-Anchor" href="#1-队列的链式存储">#</a> 1、队列的链式存储：</h3>
<p>​		队列的链式表示称为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点（注意与顺序存储的不同）。队列的链式存储如下图所示：</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/add14de1f6754d479fda55fbfa6c9819.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		队列的链式存储类型可描述位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;*LinkQueue;</span><br></pre></td></tr></table></figure>
<p>​		当 Q.front<mark>NULL 且 Q.rear</mark>NULL 时，链式队列为空。</p>
<p>​		出队时，首先判断队是否为空，若不为空，则取出队头元素，将其从链表中摘除，并让 Q.front 指向下一个结点（若该结点为最后一个结点，则置 Q.front 和 Q.rear 都为 NULL）。入队时。建立一个新的结点，将新结点插入到链表的尾部，并让 Q.rear 指向这个新插入的结点（若原队列为空队，则令 Q.front 也指向该结点）。</p>
<p>​		不难看出，不带头系欸但的链式队列在操作上往往比较麻烦，因此通常将链式队列设计成一个带头结点的单链表，这样插入的删除操作就统一了，如下图：</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/44727a7b2f3748e8b6a54c529b02da42.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		用单链表表示的链式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。另外，假如程序中要使用多个队列，与多个栈的情形一样，最好使用链表队列，这样就不会出现存储分配不合理和 “溢出” 的问题。</p>
<h3 id="2-链式队列的基本操作"><a class="markdownIt-Anchor" href="#2-链式队列的基本操作">#</a> 2、链式队列的基本操作</h3>
<h4 id="1初始化"><a class="markdownIt-Anchor" href="#1初始化">#</a> （1）初始化：</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;*LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue Q)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现初始化队列的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear =  (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  <span class="comment">//建立头结点</span></span><br><span class="line">    Q-&gt;front-&gt;next = <span class="literal">NULL</span>;                                           <span class="comment">//初始为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2判队空"><a class="markdownIt-Anchor" href="#2判队空">#</a> （2）判队空</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;*LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue Q)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现初始化队列的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear =  (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  <span class="comment">//建立头结点</span></span><br><span class="line">    Q-&gt;front-&gt;next = <span class="literal">NULL</span>;                                           <span class="comment">//初始为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现判断队空的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3入队"><a class="markdownIt-Anchor" href="#3入队">#</a> （3）入队</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;*LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue Q)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue Q,<span class="type">int</span> x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现初始化队列的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear =  (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  <span class="comment">//建立头结点</span></span><br><span class="line">    Q-&gt;front-&gt;next = <span class="literal">NULL</span>;                                           <span class="comment">//初始为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现判断队空的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现入队的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    LinkNode *s = (LinkQueue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;rear-&gt;next = s;</span><br><span class="line">    Q-&gt;rear = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4出队"><a class="markdownIt-Anchor" href="#4出队">#</a> （4）出队</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;*LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue Q)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue Q,<span class="type">int</span> x)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue Q,<span class="type">int</span> *x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现初始化队列的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear =  (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  <span class="comment">//建立头结点</span></span><br><span class="line">    Q-&gt;front-&gt;next = <span class="literal">NULL</span>;                                           <span class="comment">//初始为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现判断队空的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现入队的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    LinkNode *s = (LinkQueue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;rear-&gt;next = s;</span><br><span class="line">    Q-&gt;rear = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现出队的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue Q,<span class="type">int</span> *x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LinkNode *p = Q-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;rear == p)</span><br><span class="line">        Q-&gt;rear = Q-&gt;front;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="324-双端队列"><a class="markdownIt-Anchor" href="#324-双端队列">#</a> 3.2.4、双端队列：</h2>
<p>​		双端队列是指允许两端都可以进行入队和出队的队列，如下图。其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端，两端都可以入队和出队。</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/688a5e8549b74b0c8f58c6678f983b4b.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		在双端队列进队时，前端进的元素排列在队列中后段的元素的前面，后端进的元素排列在队列中前端进的元素的后面。在双端队列出队时，无论是前端还是后端出队，先出的元素排列在后出的元素的前面。</p>
<p>​		输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为输出受限的双端队伍，如下图：</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/cc2c7aa99a804af7a6faf2612e07bfc2.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为输入受限的双端队列，如下图。若限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为两个栈底相邻接的栈。</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/9287fdacb0934a54866e1ed4e0578c88.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="33-栈和队列的应用"><a class="markdownIt-Anchor" href="#33-栈和队列的应用">#</a> 3.3、栈和队列的应用：</h1>
<h2 id="331-栈在括号匹配中的应用"><a class="markdownIt-Anchor" href="#331-栈在括号匹配中的应用">#</a> 3.3.1、栈在括号匹配中的应用：</h2>
<p>​		假设表达式中允许包含两种括号：圆括号和方括号，其嵌套的顺序任意即 <code>([] ())</code>  或  <code>[([][])]</code>  等均为正确的格式， <code>[(])</code>  或 <code>([())]</code>  或 <code>(()]</code>  均为不正确的格式。</p>
<p>​		考虑下列括号序列：</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/4e69aed09fbd410992af8df3f2df86d1.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		分析如下：</p>
<ol>
<li>计算机接收第 1 个括号 “[” 后，期待与之匹配的第 8 个括号 “]” 出现。</li>
<li>获得了第 2 个括号 “(” ，此时第 1 个括号 “[” 暂时放在一起，而急迫期待与之匹配的第 7 个括号 ”)“ 出现。</li>
<li>获得了第 3 个括号 ”[“，此时第 2 个括号 “(” 暂时放在一边，而急迫期待与之匹配的第 4 个括号 “]” 出现。第 3 个括号的期待得到满足，消解之后，第 2 个括号的期待匹配又成为当前最急迫的任务。</li>
<li>；以此类推，可见该处理过程与栈的思想吻合。</li>
</ol>
<p>​		算法的思想如下：</p>
<ol>
<li>初始设置一个空栈，顺序读入括号。</li>
<li>若是右括号，则或使置于栈顶的最急迫期待得以消解，或是不合法的情况（括号序列不匹配，退出程序）</li>
<li>若是左括号，则作为一个新的更急迫的期待压入栈中，自然使原有的在栈中的所有未消解的期待的急迫性降了一级。算法结束时，栈未空，否则括号序列不匹配。</li>
</ol>
<h2 id="332-栈在表达式求值中的应用"><a class="markdownIt-Anchor" href="#332-栈在表达式求值中的应用">#</a> 3.3.2、栈在表达式求值中的应用</h2>
<p>​		表达式求值是程序设计语言编译中一个最基本的问题，它的实现是栈应用的一个典型范例。中缀表达式不仅依赖运算符的优先级，而且还要处理括号。后缀表达式的运算符在操作数后面，在后缀表达式中已考虑了运算符的优先级，没有括号，只有操作数和运算符。中缀表达式 A+B*(C-D)-E/F 所对应的后缀表达式为 ABCD-*+EF/-。</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/1d4649050bf0453aac036d3dab4592df.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		通过后缀表达式计算表达式值的过程为：顺序扫描表达式的每一项，然后根据它的类型做如下相应操作：若该项是操作数，则将其压入栈中；若该项是操作符 &lt;op&gt;，则连续从栈中退出两个操作数 Y 和 X ，形成运算指令 X&lt;op&gt;Y，并将计算结果重新压入栈中。当表达式的所有项都扫描并处理完后，栈顶存放的就是最后的计算结果。</p>
<p>​		例如，后缀表达式 ABCD-*+EF/- 求值的过程需要 12 步，如下图：</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/7ba31fee1b684dd283898fd4e5b7c4fc.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="333-栈在递归中的应用"><a class="markdownIt-Anchor" href="#333-栈在递归中的应用">#</a> 3.3.3、栈在递归中的应用</h2>
<p>​		递归是一种重要的程序设计方法。加单地说，若在一个函数、过程或数据结构的定义中又应用了它自身，则这个函数、过程或数据结构称为是递归定义的，简称递归。</p>
<p>​		它通常把一个大型的复杂问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需要少量代码就可以描述出解题过程所需要的多次重复计算，大大减少了程序的代码量。但在通常情况下，它的效率并不是太高。</p>
<p>​		以斐波那契数列为例，其定义为：</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/2687dbe7f9b14f979a452f4c008b052c.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		这就是递归的一个典型例子，用程序实现时如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Fib</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Fib(n<span class="number">-1</span>) + Fiib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		必须注意递归模型不能是循环定义，其必须满足下面的两个条件：</p>
<ul>
<li>递归表达式（递归体）</li>
<li>边界条件</li>
</ul>
<p>​		递归的精髓在于能否将原始问题转换为属性相同但规模较小的问题。</p>
<p>​		在递归调用的过程中，系统为每一层的返回点、局部变量、传入参数等开辟了递归工作栈来进行数据存储，递归次数过多容易造成栈溢出等。而其效率不高的原因是递归调用过程中包含很多重复的计算。下面以 n=5 为例，列出递归调用执行过程，如图 3.16 所示。</p>
<p>​		显然，在递归调用的过程中，Fib (3) 被计算了 2 次，Fib (2) 被计算了 3 次。Fib (1) 被调用了 5 次，Fib (0) 被调用了 3 次。所以，递归的效率低下，但优点是代码简单，容易理解。<br>
<img data-src="https://i-blog.csdnimg.cn/direct/07312c9b322744598548511bd5dbfb81.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="334-队列在层次遍历中的应用"><a class="markdownIt-Anchor" href="#334-队列在层次遍历中的应用">#</a> 3.3.4、队列在层次遍历中的应用</h2>
<p>​		在信息处理中又一大堆问题需要逐层或逐行处理。这类问题的解决方法往往是在处理当前层或当前行时就对下一层或下一行做预处理，把处理顺序安排好，等到当前层或当前行处理完毕，就可以处理下一层或下一行。使用队列时为了保存下一步的处理顺序。</p>
<h2 id="335-队列在计算机系统中的应用"><a class="markdownIt-Anchor" href="#335-队列在计算机系统中的应用">#</a> 3.3.5、队列在计算机系统中的应用</h2>
<p>​		队列在计算机系统中等应用非常广泛，两个例子：第一个时结局主机与外部设备之间速度不匹配的问题，第二个方面时解决由多用户引起的资源竞争问题。</p>
<h1 id="34-数组和特殊矩阵"><a class="markdownIt-Anchor" href="#34-数组和特殊矩阵">#</a> 3.4、数组和特殊矩阵</h1>
<p>​		矩阵在计算机图形学、工程计算中占有举足轻重的地位。在数据结构中考虑的是如何用最小的内存空间来存储同样的一组数据。所以，我们不研究矩阵及其运算等，而把精力放在如何将矩阵更有效地存储在内存中，并能方便地提取矩阵中的元素。</p>
<h2 id="341-数组的定义"><a class="markdownIt-Anchor" href="#341-数组的定义">#</a> 3.4.1、数组的定义</h2>
<p>​		数组是由 n (n&gt;=1) 个相同类型的数据元素构成的有限序列，每个数据元素称为一个数组元素，每个元素在 n 个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的维界。</p>
<p>​		数组与线性表的关系：数组是线性表的推广。一维数组可视为一个线性表；二维数组可视为其元素也是定长线性表的线性表，以此类推。数组一旦被定义，其维数和维界就不再改变。因此，除结构的初始化和销毁外，数组只会有存取元素和修改元素的操作。</p>
<h2 id="342-数组的存储结构"><a class="markdownIt-Anchor" href="#342-数组的存储结构">#</a> 3.4.2、数组的存储结构</h2>
<p>​		大多数计算机语言都提供了数组数据类型，逻辑意义上的数组可采用计算机语言中的数组数据类型进行存储，一个数组的所有元素的内存中占用一段连续的存储空间。</p>
<p>​		以一维数组 A [0…n-1] 为例，其存储结构关系式为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>×</mo><mi>L</mi><mo stretchy="false">(</mo><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LOC(a_i)=LOC(a_0)+i\times L(0&lt;=i&lt;n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>​		其中，L 是每个数组元素所占的存储单元。</p>
<p>​		对于多维数组，有两种映射方法：按行优先和按列优先。以二维数组为例，按行优先存储的基本思想是：先行后列，先存储行号较小的元素，行号相等先存储列好较小的元素。设二维数组的行下标与列下标的范围分别为 [0,h1] 与 [0,h2]，则存储结构关系是为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">[</mo><mi>i</mi><mo>×</mo><mo stretchy="false">(</mo><msub><mi>h</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>j</mi><mo stretchy="false">]</mo><mo>×</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">LOC(a_{i,j})=LOC(a_{0,0})+[i\times (h_2 + 1) + j]\times L
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span></span></p>
<p>​		例如，对于数组  <code>A[2][3]</code> ，它按行优先方式在内存中的存储形式如下图：</p>
<p>`<img data-src="https://i-blog.csdnimg.cn/direct/576457ac022746b385f9ad0bec3a0f7e.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		当以列优先方式存储时，得出存储结构关系式为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">[</mo><mi>j</mi><mo>×</mo><mo stretchy="false">(</mo><msub><mi>h</mi><mn>1</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">LOC(a_{i,j})=LOC(a_{0,0})+[j\times (h_1 + 1) + i]\times L
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span></span></p>
<p>​		例如，对于数组  <code>A[2][3]</code> ，它按列优先方式在内存中的存储形式如下图：</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/a3b1764beefe443995c34f3c76038062.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="343-特殊矩阵的压缩存储"><a class="markdownIt-Anchor" href="#343-特殊矩阵的压缩存储">#</a> 3.4.3、特殊矩阵的压缩存储</h2>
<p>​		压缩存储：指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是节省空间。</p>
<p>​		特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。常见的特殊矩阵有对称矩阵、上（下）三角矩阵、对角矩阵。</p>
<p>​		特殊矩阵的压缩存储方法：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩道一个存储空间中。</p>
<h3 id="1-对称矩阵"><a class="markdownIt-Anchor" href="#1-对称矩阵">#</a> 1、对称矩阵</h3>
<p>​		若对一个 n 阶矩阵 A 中的任意一个元素 a [i,j] 都有 <code>a[i,j]=a[j,i](1&lt;=i,j&lt;=n)</code> ，则称其为对称矩阵。其中的元素可以划分为 3 个部分，即上三角区、主对角线和下三角区，如下图：</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/faf3cba2c0204112b592a54ad8446e4e.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		对于 n 阶对称矩阵，上三角区的所有元素和下三角区的对应元素相同，若仍采用二维数组存放，则会浪费几乎一半的空间，为此将 n 阶对称矩阵 A 存放在以为数组  <code>[n(n+1)/2]</code>  中，即元素 a [i,j] 存放在 b_k 中。比如只存放下三角部分（含主对角）的元素。</p>
<p>​		在数组 B 中，位于元素  <code>a[i,j](i&gt;=j)</code>  前面的元素个数为</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/00b2e2af94f94712907d5ceb80084ffe.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		因此，元素 a [i,j] 在数组 B 中的下标 k = 1+2+…(i-1)+j-1=i (i-1) / 2 + j-1 （数组下标从 0 开始）。因此，元素下标之间的对应关系如下：</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/cbcad10b1b584fbbb8b0002d1d3939ef.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		当数组下标从 1 开始时，可以采用同样的推导方法，请读者自行思考。</p>
<p>​		** 注意：** 二维数组  <code>A[n][n]</code>  和  <code>A[0...n-1][0...n-1]</code>  的写法是等价的。如果数组写为  <code>A[1...n][1...n]</code> ，则说明指定了从下标 1 开始存储元素。二维数组元素写为  <code>a[i][j]</code> ，注意数组元素下标 i 和 j 通常是从 0 开始的。矩阵元素通常写为  ai,j 或 a (i)(j)，注意行号 i 和 列号 j 是从 1 开始的。</p>
<h3 id="2-三角矩阵"><a class="markdownIt-Anchor" href="#2-三角矩阵">#</a> 2、三角矩阵</h3>
<p>​		下三角矩阵中，上三角区的所有元素均为同一常量。其存储思想与对称矩阵类似，不同之处在于存储完下三角区和主对角线上的元素之后，紧接着存储对角线上方的常量一次，故可以将 n 阶下三角矩阵 A 压缩存储在 B [n (n+1)/2+1] 中。</p>
<p>​		元素下标之间的对应关系为：</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/c7c97b11d99841f8939acea97ae54579.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		下三角矩阵在内存中的压缩存储形式如下图：</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/2fc8fb16a4e84f438851dadc1a1f17c6.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		上三角矩阵中，下三角区的所有元素均为同一常量。只需存储对角线、上三角区上的元素和下三角区的常量一次，可将其压缩存储在 B [n (n+1)/2+1] 中。</p>
<p>​		因此，元素 a [i,j] 在数组 B 中的下标 k = n+(n-1)+…+(n-i+2)+(j-i+1)-1=(i-1)(2n-i+2)/2+(j-i)。因此，元素下标之间的对应关系如下：</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/6c3165bd9a374456b8daf479ae658e86.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		上三角矩阵在内存中的压缩存储形式如下图：</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/ad73d481dfb541b88f11a334e1c0a728.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		以上推到均假设下标从 0 开始。</p>
<h3 id="3-三对角矩阵"><a class="markdownIt-Anchor" href="#3-三对角矩阵">#</a> 3、三对角矩阵</h3>
<p>​		对角矩阵也称带状矩阵。对于 n 阶矩阵 A 中的任意一个元素 a [i,j]，当 |i-j|&gt;1 时，有 a [i,j]=0 (1&lt;=i,j&lt;n)，则称为三对角矩阵，如下图。在三对角矩阵中，所有非零元素都集中在以主对角线为中心的 3 条对角线的区域，其他区域的元素都为 0.</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/525858a40a3b4ef6a69ecfa88f9ec98a.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		三对角矩阵 A 也可以采用压缩存储，将 3 条对角线上的元素按行优先方式存放在一维数组 B 中，且 a [1,1] 存放在 B [0] 中，其存储形式下图。</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/76c317f9a83f43c9a0c31bd6578e82c3.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		因此可以计算矩阵 A 中 3 条对角线上的元素  <code>a[i,j](1&lt;=i,j&lt;=n,|i-j|&lt;=1)</code>  在一维数组 B 中存放的下标为 k=2i+j-3.</p>
<p>​		反之，若已知三对角线矩阵中某元素 a [i,j] 存放于一维数组 B 的第 k 个位置，则可得 i=[(k+1)/3+1]，j=k-2i+3。</p>
<h2 id="344-稀疏矩阵"><a class="markdownIt-Anchor" href="#344-稀疏矩阵">#</a> 3.4.4、稀疏矩阵</h2>
<p>​		矩阵中非零元素的个数 t，相对矩阵元素的个数 s 来说非常少，即 s&gt;&gt;t 的矩阵称为稀疏矩阵。</p>
<p>​		若采用常规的方法存储稀疏矩阵，则相当浪费存储资源，因此仅存储非零元素。但通常非零元素的分布没有规律，所以仅存储非零元素的值时不够的，还要存储它所在的行和列。因此，将非零元素及其相应的行和列构成一个三元数组（航标，列标，值），如下图。然后按照某种规律存储这些三元组。稀疏矩阵压缩存储后便失去了随机存取特性。</p>
<p><img data-src="https://i-blog.csdnimg.cn/direct/d96a70ff96604dc5abae39505f306ba3.png#pic_center" alt="在这里插入图片描述"></p>
<p>​		稀疏矩阵的三元组既可以采用数组存储，也可以采用十字链表发存储。</p>

      <div class="tags">
          <a href="/tags/408/" rel="tag"><i class="ic i-tag"></i> 408</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2024-08-19 00:35:18" itemprop="dateModified" datetime="2024-08-19T00:35:18+08:00">2024-08-19</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="g01den 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="g01den 支付宝">
        <p>支付宝</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="g01den 贝宝">
        <p>贝宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>g01den <i class="ic i-at"><em>@</em></i>golden的部落阁
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="http://blog.g01den.top/posts/2c763aa6.html" title="数据结构-3、栈、队列和数组">http://blog.g01den.top/posts/2c763aa6.html</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/posts/27a95d1a.html" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;gou-dengyue&#x2F;images&#x2F;raw&#x2F;master&#x2F;picture294.jpg" title="hexo部署服务器">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> 发电日常</span>
  <h3>hexo部署服务器</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/posts/2bb7953f.html" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;gou-dengyue&#x2F;images&#x2F;raw&#x2F;master&#x2F;picture301.jpg" title="部分CVE复现Web（1）">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> Web</span>
  <h3>部分CVE复现Web（1）</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#31-%E6%A0%88"><span class="toc-number">1.</span> <span class="toc-text"> 3.1、栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#311-%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text"> 3.1.1、栈的基本概念：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 1、栈的定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 2、栈的基本操作：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#312-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text"> 3.1.2、栈的顺序存储结构：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 1、顺序栈的实现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 2、顺序栈的基本运算：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B1%E4%BA%AB%E6%A0%88"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 3、共享栈：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#313-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text"> 3.1.3、栈的链式存储结构：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-%E9%98%9F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text"> 3.2、队列；</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#321-%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text"> 3.2.1、队列的基本概念：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 1、队列的定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 2、队列常见的基本操作：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#322-%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text"> 3.2.2、队列的顺序存储结构：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 1、队列的顺序存储：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 2、循环队列：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.3.</span> <span class="toc-text"> 3、循环队列的操作：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#323-%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text"> 3.2.3、队列的链式存储结构:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 1、队列的链式存储：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 2、链式队列的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.3.2.1.</span> <span class="toc-text"> （1）初始化：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%88%A4%E9%98%9F%E7%A9%BA"><span class="toc-number">2.3.2.2.</span> <span class="toc-text"> （2）判队空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%85%A5%E9%98%9F"><span class="toc-number">2.3.2.3.</span> <span class="toc-text"> （3）入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%87%BA%E9%98%9F"><span class="toc-number">2.3.2.4.</span> <span class="toc-text"> （4）出队</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#324-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">2.4.</span> <span class="toc-text"> 3.2.4、双端队列：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text"> 3.3、栈和队列的应用：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#331-%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.3.1、栈在括号匹配中的应用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#332-%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.3.2、栈在表达式求值中的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#333-%E6%A0%88%E5%9C%A8%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3.3、栈在递归中的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#334-%E9%98%9F%E5%88%97%E5%9C%A8%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.4.</span> <span class="toc-text"> 3.3.4、队列在层次遍历中的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#335-%E9%98%9F%E5%88%97%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.5.</span> <span class="toc-text"> 3.3.5、队列在计算机系统中的应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#34-%E6%95%B0%E7%BB%84%E5%92%8C%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5"><span class="toc-number">4.</span> <span class="toc-text"> 3.4、数组和特殊矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#341-%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.</span> <span class="toc-text"> 3.4.1、数组的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#342-%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text"> 3.4.2、数组的存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#343-%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">4.3.</span> <span class="toc-text"> 3.4.3、特殊矩阵的压缩存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5"><span class="toc-number">4.3.1.</span> <span class="toc-text"> 1、对称矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="toc-number">4.3.2.</span> <span class="toc-text"> 2、三角矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="toc-number">4.3.3.</span> <span class="toc-text"> 3、三对角矩阵</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#344-%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="toc-number">4.4.</span> <span class="toc-text"> 3.4.4、稀疏矩阵</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/posts/95e7063c.html" rel="bookmark" title="数据结构笔记-2、线性表">数据结构笔记-2、线性表</a></li><li class="active"><a href="/posts/2c763aa6.html" rel="bookmark" title="数据结构-3、栈、队列和数组">数据结构-3、栈、队列和数组</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="g01den"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">g01den</p>
  <div class="description" itemprop="description">golden的部落阁</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">50</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">10</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">8</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2cwMWRlbjE=" title="https:&#x2F;&#x2F;github.com&#x2F;g01den1"><i class="ic i-github"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/posts/27a95d1a.html" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/posts/2bb7953f.html" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Daily/" title="分类于 发电日常">发电日常</a>
</div>

    <span><a href="/posts/7232a36b.html" title="小小的总结（日常发癫）">小小的总结（日常发癫）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Pwn/" title="分类于 Pwn手的自我修养">Pwn手的自我修养</a>
</div>

    <span><a href="/posts/c8624158.html" title="pwn学习笔记（9）-中级ROP--ret2csu">pwn学习笔记（9）-中级ROP--ret2csu</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Daily/" title="分类于 发电日常">发电日常</a>
</div>

    <span><a href="/posts/e3418ca3.html" title="随机二次元图api相关">随机二次元图api相关</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Pwn/" title="分类于 Pwn手的自我修养">Pwn手的自我修养</a>
</div>

    <span><a href="/posts/d7e2e20f.html" title="pwn学习笔记（0）-事后补充">pwn学习笔记（0）-事后补充</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Pwn/" title="分类于 Pwn手的自我修养">Pwn手的自我修养</a>
</div>

    <span><a href="/posts/cbafa55d.html" title="pwn学习笔记（6）--堆基础概述">pwn学习笔记（6）--堆基础概述</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Pwn/" title="分类于 Pwn手的自我修养">Pwn手的自我修养</a>
</div>

    <span><a href="/posts/c3c1bd42.html" title="Pwn学习笔记（2）--ret_2_text_or_shellcode">Pwn学习笔记（2）--ret_2_text_or_shellcode</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Pwn/" title="分类于 Pwn手的自我修养">Pwn手的自我修养</a>
</div>

    <span><a href="/posts/e20e7502.html" title="pwn学习笔记（3）ret2syscall">pwn学习笔记（3）ret2syscall</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Daily/" title="分类于 发电日常">发电日常</a>
</div>

    <span><a href="/posts/27a95d1a.html" title="hexo部署服务器">hexo部署服务器</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Pwn/" title="分类于 Pwn手的自我修养">Pwn手的自我修养</a>
</div>

    <span><a href="/posts/f1497b96.html" title="pwn学习笔记（11）--off_by_one">pwn学习笔记（11）--off_by_one</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Pwn/" title="分类于 Pwn手的自我修养">Pwn手的自我修养</a>
</div>

    <span><a href="/posts/540e5c20.html" title="Pwn学习笔记（10）--UAF">Pwn学习笔记（10）--UAF</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">g01den @ golden的部落阁</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
     <p><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">蜀ICP备2024083302号</a><!--|<a target="_blank" rel="noopener" href="https://beian.mps.gov.cn/#/query/webSearch">公网安备XXXXXXXX号</a> -->
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'posts/2c763aa6.html',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body>
</html>
