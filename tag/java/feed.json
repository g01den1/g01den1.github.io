{
    "version": "https://jsonfeed.org/version/1",
    "title": "golden的部落阁 • All posts by \"java\" tag",
    "description": "golden的部落阁",
    "home_page_url": "http://blog.g01den.top",
    "items": [
        {
            "id": "http://blog.g01den.top/posts/20a3be2d.html",
            "url": "http://blog.g01den.top/posts/20a3be2d.html",
            "title": "JavaWeb基础(一)-IO操作",
            "date_published": "2024-05-29T14:16:55.000Z",
            "content_html": "<h1 id=\"java-io工作机制\"><a class=\"markdownIt-Anchor\" href=\"#java-io工作机制\">#</a> Java I/O 工作机制：</h1>\n<p><strong>注：简要笔记，示例代码可能较少，甚至没有。</strong></p>\n<h2 id=\"1-java-的-io-类库的基本架构\"><a class=\"markdownIt-Anchor\" href=\"#1-java-的-io-类库的基本架构\">#</a> 1、Java 的 I/O 类库的基本架构。</h2>\n<pre><code>\tJava 的 I/O 操作类在包 java.io 下，大概有将近80个类，这些类大概可以分为如下四组。\n</code></pre>\n<ul>\n<li>基于字节操作的 I/O 接口：InputStream 和 OutputStream 。</li>\n<li>基于字符操作的 I/O 接口：Writer 和 Reader 。</li>\n<li>基于磁盘操作的 I/O 接口：File。</li>\n<li>基于网络操作的 I/O 接口：Socket。</li>\n</ul>\n<h3 id=\"11-基于字节的-io-操作接口\"><a class=\"markdownIt-Anchor\" href=\"#11-基于字节的-io-操作接口\">#</a> 1.1、基于字节的 I/O 操作接口</h3>\n<pre><code>\t基于字节的 I/O 操作接口输入和输出分别是：InputStream 和 OutputStream 。InputStream 的类层次如下：\n</code></pre>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/93c3c26c8f0c429d9c12af10d397733a.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<pre><code>\t输入流根据数据类型和操作方式又被划分为若干个子类，每个子类分别处理不同操作类型。OutputStream  的类层次结构也类似，如下图：\n</code></pre>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/00775864970f46c398a03144a73f5731.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"12-基于字符的-io-操作接口\"><a class=\"markdownIt-Anchor\" href=\"#12-基于字符的-io-操作接口\">#</a> 1.2、基于字符的 I/O 操作接口</h3>\n<pre><code>\t下图是写字符的 I/O 操作接口涉及的类，Writer 类提供了一个抽象方法 write(char cbuf[],int off,int len)。\n</code></pre>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/c64a10bb54654d2582c6ab90569e86af.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<pre><code>\t读字符的操作接口也有类似的结构，如下图：\n</code></pre>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/f5005cbcaaff4263931e50ded600ba04.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<pre><code>\t读字符的操作接口是 int read(char cbuf[],int off,int len)，。返回读到的n个字节数，不管是 Writer 还是 Reader 类，它们都只定义了读取或写入的数据字符的方式，也就是怎么写或读。\n</code></pre>\n<h3 id=\"13-字节与字符的转化接口\"><a class=\"markdownIt-Anchor\" href=\"#13-字节与字符的转化接口\">#</a> 1.3、字节与字符的转化接口</h3>\n<pre><code>\t字符到字节需要转化，其中，读的转化过程如下：\n</code></pre>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/0430cb0a57574ced8bd3c3a5d50eb254.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<pre><code>\tInputStreamReader 类是字节到字符的转化桥梁，InputSream 到 Reader 的过程要指定编码字符集，否则将采用操作系统默认字符集，很可能会出现乱码问题。SteamDecoder 正是完成字节到字符的解码的实现类。类似如下代码读到一个文件时：\n</code></pre>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">StringBuffer</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">            <span class=\"type\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">            <span class=\"type\">FileReader</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>(<span class=\"string\">&quot;file&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (f.read(buf) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                str.append(buf);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            str.toString();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<pre><code>\tFileReader 类就是按照上面的工作方式读取文件的，FileReader 继承了 InputStramReader 类，实际上时读取文件流，然后通过 StreamDecoder 解码成 char ，只不过这里的编码字符集时默认字符集。\n\n\t写入也是类似的过程：\n</code></pre>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/8b8af04f03ea4ba9851c5648efe58d48.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<pre><code>\t通过 OutputStreamWriter 类完成字符到字节的编码过程，由 StreamEncoder 完成编码过程。\n</code></pre>\n<h2 id=\"2-磁盘-io-工作机制\"><a class=\"markdownIt-Anchor\" href=\"#2-磁盘-io-工作机制\">#</a> 2、磁盘 I/O 工作机制：</h2>\n<h3 id=\"21-几种访问文件的方式\"><a class=\"markdownIt-Anchor\" href=\"#21-几种访问文件的方式\">#</a> 2.1、几种访问文件的方式</h3>\n<ol>\n<li>标准访问文件方式。</li>\n<li>直接 I/O 方式。</li>\n<li>同步访问文件方式。</li>\n<li>异步访问文件方式。</li>\n<li>内存映射方式。</li>\n</ol>\n<h3 id=\"22-java-访问磁盘文件\"><a class=\"markdownIt-Anchor\" href=\"#22-java-访问磁盘文件\">#</a> 2.2、Java 访问磁盘文件</h3>\n<pre><code>\t当传入一个文件路径时，将会根据这个路径创建一个 File 对象来表示这个文件，然后根据这个 File 对象创建真正读取文件的操作对象，这时将会真正创建一个关联真实存在的磁盘文件的文件描述符 FileDescriptor，通过这个对象可以直接控制这个磁盘文件，。\n</code></pre>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/d55db7d024654510987ff7e1cbce21c1.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"23-java-序列化技术\"><a class=\"markdownIt-Anchor\" href=\"#23-java-序列化技术\">#</a> 2.3、Java 序列化技术</h3>\n<pre><code>\tJava 序列化就是将一个对象转化为一串二进制表示的字节数组，通过保存或转移这些字节数据来达到持久化的目的。需要持久化，对象必须继承 java.io.Serializable 接口。反序列化则是相反的过程，将这个字节数组再重新构造成对象。我们知道反序列化时，必须有原始类作为模板，才能将这个对象还原，从这个过程我们可以猜测，序列化的数据并不像 class 文件那样保存类的完整的结构信息。下面是一个简单的序列化的代码：\n</code></pre>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Serialize</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> - <span class=\"number\">6849794470754660011L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">1390</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">FileOutputStream</span> <span class=\"variable\">fos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(<span class=\"string\">&quot;d:/serialize.dat&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">oos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(fos);</span><br><span class=\"line\">            <span class=\"type\">Serialize</span> <span class=\"variable\">serialize</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Serialize</span>();</span><br><span class=\"line\">            oos.writeObject(serialize);</span><br><span class=\"line\">            oos.flush();</span><br><span class=\"line\">            oos.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>\t序列化的文件二进制字节数据如下：\n</code></pre>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/6544ad53b377490c9f7a60d5ad99cb04.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<ol>\n<li>\n<p>第一部分是反序列化文件头。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/ab3ed5c157264bbc833860233f8b314a.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li>\n<p>第二部分是要反序列化的类的描述，在这里是 Serialize 类。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/7f9959f931e741a4bee64dbd23c56c97.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li>\n<p>第三部分是对象中各个属性项的描述</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/4e058285c2b246fa9cfc8c911e61ecfd.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li>\n<p>第四部分输出该对象的父类信息描述，这里没有父类，如果有，数据格式与第二部分一样。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/67a0a799eefe4e809e27094075061210.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li>\n<p>第五部分输出对象的属性项的实际值，如果属性项是一个对象，那么这里还将序列化这个对象，规则和第二部分一样。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/e6306bc60426477eb218df3426486b27.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ol>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/3d5d6561.html",
            "url": "http://blog.g01den.top/posts/3d5d6561.html",
            "title": "三、Servlet基础",
            "date_published": "2024-05-27T04:07:54.000Z",
            "content_html": "<p><strong>注：因为我并不完全是为了从 0 开始 Java 开发，因此，我这里先暂时跳过第二章服务器环境相关的内容，直接开始第三章的内容。</strong></p>\n<h1 id=\"31-servlet-的基本结构\"><a class=\"markdownIt-Anchor\" href=\"#31-servlet-的基本结构\">#</a> 3.1、Servlet 的基本结构：</h1>\n<p>​\t下面的代码给出了一个基本的 Servlet ，它处理 GET 请求。GET 请求是浏览器请求的常见类型，用来请求 Web 页面。用户在地址栏中输入 URL 、点击 Web 页面内的连接、或提交没有指定 METHOD 或 METHOD=“GET” 的 HTML 表单时，浏览器都会生成这个请求。 Servlet 还可以容易地处理 POST 请求（提交 METHOD=“POST” 的 HTML 表单时，会生成 POST 请求）。HTML 表单的使用细节以及 GET 和 POST 之间的区别。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.firstweb.study01;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.ServletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServletTemplate</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//Use &quot;request&quot; to read incoming HTTP headers</span></span><br><span class=\"line\">        <span class=\"comment\">//(e.g.,Cookies) and query data from HTML forms .</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//Use &quot;response&quot; to specify the HTTP response status</span></span><br><span class=\"line\">        <span class=\"comment\">//code and headers (e.g.,the content type ,cookies)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> resp.getWriter();</span><br><span class=\"line\">        <span class=\"comment\">//Use &quot;out&quot; to send content to browser</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\tServlet 一般扩展 HttpServlet ，并依数据发送方式的不同（GET 或 POST），覆盖 doGet 或 doPost 方法。如果希望 Servlet 对 GET 和 POST 请求采用同样的行动，只需要让 doGet 调用 doPost ，反之，依然。</p>\n<p>​\tdoGet 和 doPost 都接受两个参数：HttpServletRequest 和 HttpServletResponse 。通过 HttpServletRequest，可以得到所有的输入数据；这个类提供相应的方法，通过这些方法可以找出诸如表单（查询）数据、HTTP 请求报头和客户的主机名等信息。通过 HttpServletResponse 可以制定输出信息，比如 HTTP 状态代码（200，404 等）和响应报头（Content-Type，Set-Cookie 等）。最重要的是，通过 HttpServletResponse 可以获得 PrintWriter ，用它可以将文档内容发送给客户。对于简单的 Servlet ，大部分工作都花在用 println 语句生成期望的页面上。</p>\n<p>​\t由于 doGet 和 doPost  抛出两种异常（ServletException 和 IOException），所以在方法声明中包括他们。最后，还必须导入 <span class=\"exturl\" data-url=\"aHR0cDovL2phdmEuaW8=\">java.io</span>（PrintWrite 等）、javax.servlet（HttpServlet 等）和 javax.servlet.http（HttpServletResponse 和 HttpServletRequest）中的类。</p>\n<h1 id=\"32-生成纯文本的-servlet\"><a class=\"markdownIt-Anchor\" href=\"#32-生成纯文本的-servlet\">#</a> 3.2、生成纯文本的 Servlet ：</h1>\n<p>​\t代码 3.2 列出了一个输出纯文本的简单 Servlet，图 3.2 是它的输出。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码 3.2 </span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.firstweb.study01;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.ServletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@WebServlet(&quot;/hello&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> resp.getWriter();</span><br><span class=\"line\">        out.println(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t图 3.2：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/5c0bf5adcfa84c18800d9ca4c37c61c3.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"33-生成-html-的-servlet\"><a class=\"markdownIt-Anchor\" href=\"#33-生成-html-的-servlet\">#</a> 3.3、生成 HTML 的 Servlet：</h1>\n<p>​\t大多数的 Servlet 生成 HTML ，而非前述例子中的纯文本。要生成 HTML ，需要在刚才介绍的过程中加入如下三步：</p>\n<ol>\n<li>\n<p>告知浏览器，即将向它发送  HTML 。</p>\n</li>\n<li>\n<p>修改 println 语句，构建合法的 Web 页面。</p>\n</li>\n<li>\n<p>用形式语法检验其（format syntax validator）检查生成的 HTML。</p>\n<p>第一步通过将 HTTP Content-Type 响应报头设为 text/html 来完成。一般而言，报头使用 HttpServletResponse 的 setHeader 方法来设置，但由于设置内容的类型是一项十分常见的任务，因而，HttpServletResponse 提供特殊的 setContentType 方法，专门用于这种目的。指明 HTML 的方式是使用 text/html 类型，因此，代码应该如下：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resp.setContentType(<span class=\"string\">&quot;text/html&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>​\t尽管 HTML 是 Servlet 创建的最常见的文档类型，但是，Servlet 创建其他类型文档的情况也很常见。例如，使用 Servlet 生成的 Excel 表格（内容类型是 application/vnd.ms-excel）、JPEG 图像（内容类型是 image/jpeg ）和 XML 文档（内容类型是 text/xml）的情况也是十分常见。同时，一般很少使用 Servlet 生成格式相对固定的 HTML 页面（即每次请求，页面的布局改动很小）；这种情况下 JSP 常常更为方便。</p>\n<p>​\t需要注意的是：需要在 PrintWriter 实际返回任何内容之前，设置响应报头。这是由于 HTTP 响应由状态行、一个或多个报头、一个空行和实际的文档一次次序构成。包头的出现次序并不重要，Servlet 会缓冲报头数据，将他们一次法案送到客户端，因此，即使在设定报头之后，依旧可以设置状态代码（属于返回内容的第一行）。但是，Servlet 不是一定要缓冲文档本身，因为对于篇幅较长的页面，用户或许只希望看到部分结果。Servlet 引擎可以缓冲部分输出，但并未规定缓冲区的大小。可以使用 HttpServletResponse 和 getBufferSize 方法确定这个大小，或使用 setBufferSize 指定这个大小。也可以在缓冲区填满，要发往客户时，对报头进行设置。如果不确定缓冲区是否已经发送出去，可以使用 isCommitted 方法来检查。及时如此，最佳的方案还是将 setContentType 行放在任何 PrintWrite 的行之前。</p>\n<p>​\t<strong>警告：必须在传送实际的文档之前设定内容的类型。</strong></p>\n<p>​\t在编写构建 HTML 文档的 Servlet 时，第二步时用 println 语句输出 HTML（不再是纯文本）。代码 303 列出了 HelloServlet.java ，结果如图 3.3 所示，浏览器按照 HTML 来格式化得到的结果，而非按照纯文本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码 3.3</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.firstweb.study01;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.ServletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@WebServlet(&quot;/hello&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        resp.setContentType(<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> resp.getWriter();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">docType</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;!DOCTYPE HTML PUBLIC \\&quot;-//W3C//DTD HTML 4.0&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;Transitional//EN\\&quot;&gt;\\n&quot;</span>;</span><br><span class=\"line\">        out.println(docType +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;HTML&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;HEAD&gt;&lt;TITLE&gt;Hello&lt;/TITLE&gt;&lt;HEAD&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;BODY BGCOLOR=\\&quot;#FDF5E6\\&quot;&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;H1&gt;Hello&lt;/H1&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t图 3.3 ：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/2ff45d069c9f4963b377e8952ef0ca66.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t最后一步时合适生成的 HTML 中，不存在有可能会在不同的浏览器上引起不可预期结果的语法错误。参考 3.5 节中有关 HTML 验证其的论述。</p>\n<h1 id=\"34-servlet-的打包\"><a class=\"markdownIt-Anchor\" href=\"#34-servlet-的打包\">#</a> 3.4、Servlet 的打包：</h1>\n<p>​\t在产品开发过程中，多个程序员可能为同一服务器开发 Servlet。因此，将所有的 Servlet 放到同一目录中将会生成数目庞大且难以管理的类，如果两个开发人员为 Servlet 或使用工具类名时，不经意间选择了相同的名称，还会导致命名冲突。现在，通过 Web 应用，可以将内容划分到多个单独的目录中，每个目录都有自己的一套 Servlet、实用工具类、JSP 页面和 HTML 文件，避免了这个问题。然而，由于单个 Web 应用也可能比较庞大，因此，我们依旧需要采用 Java 中用以避免命名冲突的标准解决方案：包。</p>\n<p>​\t在将 Servlet 放到包中，需要执行下面两个额外的步骤。</p>\n<ol>\n<li>将文件放到与预定的包名匹配的子目录中。</li>\n<li>在类文件中插入包语句。</li>\n</ol>\n<h1 id=\"35-简单的-html-构建工具\"><a class=\"markdownIt-Anchor\" href=\"#35-简单的-html-构建工具\">#</a> 3.5、简单的 HTML 构建工具：</h1>\n<p>​\t由于 HTML 文档的结构如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE ...&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">HTML</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">HEAD</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">TITLE</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">TITLE</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">HEAD</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">BODY</span> <span class=\"attr\">...</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">BODY</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">HTML</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>​\t在使用 Servlet 构建 HTML 时，可能会略去这个结构的某个部分，尤其是 DOCTYPE 行，因为虽然 HTML 规范需要它，但几乎所有主流的浏览器都忽略它。我们极不赞成这种做法。DOCTYPE 行的长处是，它告诉 HTML 验证器您使用的是 HTML 的哪个版本，从而验证器知道应该按照哪种规范对文档进行检查。这些验证器对调试很有价值，能够帮助您捕获那些您的路 i 兰奇可以推测出来，但其他浏览器在显示时可能会有困难的 HTML 语法错误。</p>\n<p>​\t毫无疑问，使用 println 语句生成 HTML 有些笨重，尤其是那些冗长乏味的行，如 DOCTYPE 声明。有些人编写很长的 HTML 生成使用工具程序，然后，在编写 Servlet 时使用这些实用工具程序，，以此来解决这个问题。我们对这类扩展库的有效性持怀疑态度。首先且最重要的是，变成生成 HTML 的不便是 JSP 解决的主要问题之一。其次，用来生成 HTML 的例程可能十分笨重，一般并不支持所有的 HTML 属性。</p>\n<p>​\t标准 Servlet 中，Web 页面中的两部分内容（DOCTYPE 和 HEAD）一般不会发生变化，因而可以归结到一个简单的使用工具文件中。代码 3.5 就是这样一个文件，代码 3.6 列出 HelloServlet 类的又一个变体，它使用这个实用工具类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码 3.5</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.firstweb.study01;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServletUtilities</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">DOCTYPE</span> <span class=\"operator\">=</span></span><br><span class=\"line\">            <span class=\"string\">&quot;&lt;!DOCTYPE HTML PUBLIC \\&quot;-//W3C//DTD HTML 4.0 &quot;</span> + <span class=\"string\">&quot;\\n&quot;</span> +</span><br><span class=\"line\">                    <span class=\"string\">&quot;Transitional//EN\\&quot;&gt;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">headWithTitle</span><span class=\"params\">(String title)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (DOCTYPE + <span class=\"string\">&quot;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;HTML&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;HEAD&gt;&lt;TITLE&gt;&quot;</span> + title + <span class=\"string\">&quot;&lt;/TITLE&gt;&lt;HEAD&gt;\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码 3.6</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.firstweb.study01;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.ServletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@WebServlet(&quot;/hello&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloServlet3</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        resp.setContentType(<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> resp.getWriter();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">title</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello3&quot;</span>;</span><br><span class=\"line\">        out.println(ServletUtilities.headWithTitle(title) +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;BODY BGCOLOR=\\&quot;#FDF5E6\\&quot;&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;H1&gt;&quot;</span> + title + <span class=\"string\">&quot;&lt;/H1&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t编译完 HelloServlet3.java 之后（会导致自动编译 ServletUtilities.java），需要将这两个类文件移动到服务器默认部署位置（…/WEB-INF/classes）中，的相应的包中。最后结果如下图所示：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/8eb34a2c73134aec92788cccbfd1c2d0.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"36-servlet-的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#36-servlet-的生命周期\">#</a> 3.6、Servlet 的生命周期：</h1>\n<p>​\t服务器只创建每个  Servlet 的单一实例，每个用户请求都会引发新的线程 —— 将用户请求交付给相应的 doGet 或 doPost 进行处理。</p>\n<p>​\t首次创建 Servlet 时，它的 init 方法会得到调用，因此，init 是放置一次性设置代码的地方。在这之后，针对每个用户请求，都会创造一个线程，该线程调用前面创建的实例的 Servlet 方法。多个并发请求一般会导致多个线程同时调用 service。之后由 service 方法依据接收到的 HTTP 请求的类型，调用 doGet，doPost，或其他 doXxx 方法。最后，如果服务器决定卸载某个 Servlet ，它会首先调用 Servlet 的 destroy 方法。</p>\n<h2 id=\"361-service-方法\"><a class=\"markdownIt-Anchor\" href=\"#361-service-方法\">#</a> 3.6.1、service 方法：</h2>\n<p>​\t服务器每次接收到对 Servlet 的请求，都会产生一个新的线程，调用 service 方法。service 方法检查 HTTP 请求的类型（GET，POST，PUT，DELETE 等）并相应地调用 doGet，doPost，doPut，doDelete 等方法。</p>\n<p>​\t如果需要在 Servlet 中等同地处理 POST 和 GET 请求，只需要让 doPost 调用 doGet 或者反过来即可，尽量别直接覆盖 service 方法。</p>\n<p>​\t虽然这种方法要多出几行代码，但相对于直接覆盖 service ，它有几个有点。首先，之后还可以加入 doPut，doTrace 等，支持其他的 HTTP 请求方法。直接覆盖 service 则排除了这种可能性。其次，还可以通过添加 getLastModified 方法，加入对修改日期的支持，由于 getLastModified 由默认的 service 方法调用，所以覆盖 service 方法也就失去了这个选项。最后，service 提供对 HEAD，OPTION 和 TRACE 请求的自动支持。</p>\n<h2 id=\"362-dogetdopost-和-doxxx-方法\"><a class=\"markdownIt-Anchor\" href=\"#362-dogetdopost-和-doxxx-方法\">#</a> 3.6.2、doGet，doPost 和 doXxx 方法：</h2>\n<p>​\t这些部分才是 Servlet 的主体。因此，可以覆盖 doGet 和 doPost。如果愿意，也可以覆盖 DELETE 请求的 doDelete、PUT 请求的 doPut 、OPTIONS 请求的 doOptions 以及 TRACE 请求的 doTrace。然而，要记住已经拥有对 OPTION 和 TRACE 的自动支持。</p>\n<p>​\t一般情况下，不需要实现 doHead 以处理 HEAD 请求（HEAD 请求规定，服务器应该只返回正常的 HTTP 报头，不含与之相关联的文档）。由于系统会自动调用 doGet ，并用生成的状态行和报头设定来应答 HEAD 请求，故而，一般不需要实现 doHead 。有时，为了能够更快地生成对 HEAD 请求的响应，会实现 doHead 方法。</p>\n<h2 id=\"363-init-方法\"><a class=\"markdownIt-Anchor\" href=\"#363-init-方法\">#</a> 3.6.3、init 方法：</h2>\n<p>​\t大多数时候，Servlet 只需处理单个请求的数据，doGet 或 doPost 是生命周期中唯一需要的方法。然而，有时候希望在 Servlet 首次载入时，执行复杂的初始化任务，但并不想每个请求都重复这些任务。init 方法就是专门针对这种情况设计；它在 Servlet 初次创建时被调用，之后处理每个用户的请求时，则不再调用这个方法。因此，它主要用于一次性的初始化，和 applet 的 init 方法相同。Servlet 一般在用户首次调用对应的 Servlet 的 URL 时创建，但也可以指定 Servlet 在服务器启动后载入。</p>\n<p>​\tinit 方法执行两种类型的初始化：常规初始化，以及由初始化参数控制的初始化。</p>\n<ol>\n<li>\n<p><strong>常规初始化：</strong></p>\n<p>init 只是创建或载入在 Servlet 声明周期内用到的一些数据，或者执行某些一次性的计算。</p>\n</li>\n<li>\n<p><strong>由初始化参数控制的初始化：</strong></p>\n</li>\n</ol>\n<h2 id=\"364-destroy-方法\"><a class=\"markdownIt-Anchor\" href=\"#364-destroy-方法\">#</a> 3.6.4、destroy 方法：</h2>\n<p>​\t服务器可能会决定移除之前载入的 Servlet 实例，或许因为服务器的管理员要求它这样做。但是，在服务器移除 Servlet 的实例之前，它会调用 Servlet 的 destroy 方法，从而使得 Servlet 有机会关闭数据库连接、停止后台的线程、将 Cookie 列表和点击计数写入到磁盘、并执行其他清理活动。但是，要意识到 Web 服务器有可能崩溃。因此，不要将 destroy 机制作为向磁盘上保存状态的唯一机制。如果服务器执行诸如点击计数，或对 Cookie 值的列表进行累加等活动，应该主动地定期将数据写到磁盘上。</p>\n<h1 id=\"37-singlethreadmodel-接口\"><a class=\"markdownIt-Anchor\" href=\"#37-singlethreadmodel-接口\">#</a> 3.7、SingleThreadModel 接口：</h1>\n<p>​\t<strong>注：由于我缺少前置知识，所以这部分内容先临时跳过，借鉴我的博客内容学习的师傅可以去支持下这本书。</strong></p>\n<h1 id=\"38-servlet-的调试\"><a class=\"markdownIt-Anchor\" href=\"#38-servlet-的调试\">#</a> 3.8、Servlet 的调试：</h1>\n<p>​\t如下，书中列出了一部分的调试技巧：</p>\n<ol>\n<li>使用打印语句。</li>\n<li>使用集成在 IDE 中的调试器。</li>\n<li>使用日志文件。</li>\n<li>使用 Apache Log4J。</li>\n<li>编写独立类。</li>\n<li>预先做好数据缺失或异常的准备。</li>\n<li>检查 HTML 源代码。</li>\n<li>单独检查请求数据。</li>\n<li>单独检查响应数据。</li>\n<li>停止和重启服务器。<br>\n<strong>注：由于我缺少前置知识，所以这部分内容先临时跳过，借鉴我的博客内容学习的师傅可以去支持下这本书。</strong></li>\n</ol>\n<h1 id=\"38-servlet-的调试-2\"><a class=\"markdownIt-Anchor\" href=\"#38-servlet-的调试-2\">#</a> 3.8、Servlet 的调试：</h1>\n<p>​\t如下，书中列出了一部分的调试技巧：</p>\n<ol>\n<li>使用打印语句。</li>\n<li>使用集成在 IDE 中的调试器。</li>\n<li>使用日志文件。</li>\n<li>使用 Apache Log4J。</li>\n<li>编写独立类。</li>\n<li>预先做好数据缺失或异常的准备。</li>\n<li>检查 HTML 源代码。</li>\n<li>单独检查请求数据。</li>\n<li>单独检查响应数据。</li>\n<li>停止和重启服务器。</li>\n</ol>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/3fe30769.html",
            "url": "http://blog.g01den.top/posts/3fe30769.html",
            "title": "一、Servlet和JSP技术概述",
            "date_published": "2024-05-26T12:53:19.000Z",
            "content_html": "<p><strong>注：该系列笔记是用于我在 《Servlet 与 JSP 核心编程》这本书中的学习笔记，无其他意思，侵权请联系 2082045221@qq.com 删除。</strong></p>\n<p>​\t第一章内容较少，所以暂时有用的笔记也不多。</p>\n<h1 id=\"11-servlet-的功用\"><a class=\"markdownIt-Anchor\" href=\"#11-servlet-的功用\">#</a> 1.1、Servlet 的功用：</h1>\n<p>​\tServlet 是运行在 Web 服务器或应用服务器上的 Java 程序，它是一个，负责连接来自 Web 浏览器或其他 HTTP 客户程序的请求和 HTTP 服务器上的数据库或应用程序。Servlet 的工作是执行下面的任务，如图 1.1 所示：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/764d654f16ff499ca886496abc121f94.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<ol>\n<li>\n<p>读取客户发送的显式数据。</p>\n<p>最终用户一般在网页的 HTML 表单中输入的这些数据。然而，数据还有可能来自于 Applet 或定制的 HTTP 客户程序。</p>\n</li>\n<li>\n<p>读取由浏览器发送的隐式请求数据。</p>\n<p>图 1.1 中显示了一条从客户端到 Web 服务器（Servlet 和 JSP 所在的层）的单箭头，但实际上从客户端传送到  Web 服务器的数据有两种，它们分别为用户在表单中输入的显式数据，以及后台的 HTTP 信息。两种数据都很重要。HTTP 信息包括 Cookie、浏览器所能识别的媒体类型和压缩模式等。</p>\n</li>\n<li>\n<p>生成结果。</p>\n<p>这个过程可能需要访问数据库、执行 RMI 或 EJB 调用 、调用 Web 服务，或者直接计算得出对应的响应。实际的数据可能存储在关系型数据库中。该数据库可能不理解 HTTP ，或者不能返回 HTML 形式的结果，所以 Web 浏览器不能直接与数据库进行会话。及时能够做到这一点，为了安全，也不希望让它这么做。对于大多数其他应用程序，也存在类似的问题。因此，需要 Web 中间层从 HTTP 流中提取输入数据，与应用程序会话，并将结果嵌入到文档中。</p>\n</li>\n<li>\n<p>向客户发送显式数据（即文档）。</p>\n<p>这个文档可以用各种发送，包括文本（HTML 或 XML），二进制（GIF 图），甚至可以是建立在其他底层格式，如 gzip。但是，到目前为止，HTML 是最常用的格式，故而 Servlet 和 JSP 的重要任务之一就是将结果包装到 HTML 中。</p>\n</li>\n<li>\n<p>发送隐式的 HTTP 响应数据。</p>\n<p>图 1.1 中显示了一条从 Web 中间层（Servlet 或 JSP 页面）到客户端的单箭头。但是，实际发送的数据有两种：文档本身，以及后台的 HTTP 信息。同样，两种数据对开发来说都是至关重要的。HTTP 响应数据的发送过程涉及告知浏览器或其他客户程序所返回文档的类型（例如 HTML），是指 Cookie 和缓存参数，以及其他类似的任务。</p>\n</li>\n</ol>\n<h1 id=\"12-动态构建网页的原因\"><a class=\"markdownIt-Anchor\" href=\"#12-动态构建网页的原因\">#</a> 1.2、动态构建网页的原因：</h1>\n<p>​\t\t实时构建网页的理由：</p>\n<ul>\n<li>\n<p>网页基于客户发送的数据。</p>\n</li>\n<li>\n<p>网页由频繁改变的数据导出。</p>\n</li>\n<li>\n<p>网页中使用了来自公司数据库或其他服务器端数据源的信息。</p>\n<p>理论上讲，Servlet 并非只用于处理 HTTP 请求的 Web 服务器或应用服务器，它同样可以用于其他类型的服务器。而且，用于会话启动协议（Session Initiation Protocol， SIP）服务器的 Servlet API 最近已经被标准化。但是在实践中，Servlet 的这种用法尚不流行，所以以下都只说 HTTP Servlet 。</p>\n</li>\n</ul>\n<h1 id=\"13-servlet-代码初探\"><a class=\"markdownIt-Anchor\" href=\"#13-servlet-代码初探\">#</a> 1.3、Servlet 代码初探：</h1>\n<p>​\t现在，先快速地观察一个简单的 Servlet ，以对它的复杂程度有一个基本的了解。</p>\n<p>​\t首先，给一个简单的 Servlet 代码，它向客户端输出了一个简单的 HTML 页面，不过需要注意以下几点：</p>\n<ul>\n<li>它是常规的 Java 代码。</li>\n<li>它有不熟悉的重要语句。</li>\n<li>它对标准的类（HttpServlet）进行了扩展。</li>\n<li>它覆盖（override）了 doGet 方法。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.firstweb.study01;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.ServletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@WebServlet(&quot;/hello&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        resp.setContentType(<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> resp.getWriter();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">docType</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;!DOCTYPE HTML PUBLIC \\&quot;-//W3C//DTD HTML 4.0&quot;</span> +</span><br><span class=\"line\">                        <span class=\"string\">&quot;Transitional//EN\\&quot;&gt;\\n&quot;</span>;</span><br><span class=\"line\">        out.println(docType +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;HTML&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;HEAD&gt;&lt;TITLE&gt;Hello&lt;/TITLE&gt;&lt;HEAD&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;BODY BGCOLOR=\\&quot;#FDF5E6\\&quot;&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;H1&gt;Hello&lt;/H1&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果如下：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/d18f9356267b41459a74fd01cd064c76.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"14-jsp-的作用\"><a class=\"markdownIt-Anchor\" href=\"#14-jsp-的作用\">#</a> 1.4、JSP 的作用：</h1>\n<pre><code>\t为了简化起见，某种程度上，可以将 Servlet 看作是含有 HTML 的 Java 程序：将 JSP 看作是含有 Java 代码的 HTML 页面。\n</code></pre>\n",
            "tags": [
                "Java"
            ]
        }
    ]
}